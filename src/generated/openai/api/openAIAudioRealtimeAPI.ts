/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * OpenAI Audio & Realtime API
 * OpenAI Audio API - Transcription, Translation, Speech, and Realtime streaming endpoints. Filtered from the official OpenAI API spec (Stainless-hosted).
 * OpenAPI spec version: 2.3.0
 */
import axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CreateSpeechRequest,
  CreateSpeechResponseStreamEvent,
  CreateTranscription200One,
  CreateTranscriptionRequest,
  CreateTranscriptionResponseStreamEvent,
  CreateTranslation200,
  CreateTranslationRequest,
  CreateVoiceRequest,
  RealtimeCreateClientSecretRequest,
  RealtimeCreateClientSecretResponse,
  RealtimeSessionCreateRequest,
  RealtimeSessionCreateResponse,
  RealtimeTranscriptionSessionCreateRequest,
  RealtimeTranscriptionSessionCreateResponse,
  VoiceResource
} from '../schema';

/**
 * Generates audio from the input text.
 * @summary Create speech
 */
export const createSpeech = <TData = AxiosResponse<Blob | CreateSpeechResponseStreamEvent>>(
    createSpeechRequest: CreateSpeechRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/audio/speech`,
      createSpeechRequest,options
    );
  }

/**
 * Transcribes audio into the input language.
 * @summary Create transcription
 */
export const createTranscription = <TData = AxiosResponse<CreateTranscription200One | CreateTranscriptionResponseStreamEvent>>(
    createTranscriptionRequest: CreateTranscriptionRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
formData.append(`file`, createTranscriptionRequest.file)
formData.append(`model`, createTranscriptionRequest.model)
if(createTranscriptionRequest.language !== undefined) {
 formData.append(`language`, createTranscriptionRequest.language)
 }
if(createTranscriptionRequest.prompt !== undefined) {
 formData.append(`prompt`, createTranscriptionRequest.prompt)
 }
if(createTranscriptionRequest.response_format !== undefined) {
 formData.append(`response_format`, createTranscriptionRequest.response_format)
 }
if(createTranscriptionRequest.temperature !== undefined) {
 formData.append(`temperature`, createTranscriptionRequest.temperature.toString())
 }
if(createTranscriptionRequest.include !== undefined) {
 createTranscriptionRequest.include.forEach(value => formData.append(`include`, value));
 }
if(createTranscriptionRequest.timestamp_granularities !== undefined) {
 createTranscriptionRequest.timestamp_granularities.forEach(value => formData.append(`timestamp_granularities`, value));
 }
if(createTranscriptionRequest.stream !== undefined && createTranscriptionRequest.stream !== null) {
 formData.append(`stream`, createTranscriptionRequest.stream.toString())
 }
if(createTranscriptionRequest.chunking_strategy !== undefined && createTranscriptionRequest.chunking_strategy !== null) {
 formData.append("chunking_strategy", typeof createTranscriptionRequest.chunking_strategy === "object" ? JSON.stringify(createTranscriptionRequest.chunking_strategy) : String(createTranscriptionRequest.chunking_strategy))
 }
if(createTranscriptionRequest.known_speaker_names !== undefined) {
 createTranscriptionRequest.known_speaker_names.forEach(value => formData.append(`known_speaker_names`, value));
 }
if(createTranscriptionRequest.known_speaker_references !== undefined) {
 createTranscriptionRequest.known_speaker_references.forEach(value => formData.append(`known_speaker_references`, value));
 }

    return axios.post(
      `/audio/transcriptions`,
      formData,options
    );
  }

/**
 * Translates audio into English.
 * @summary Create translation
 */
export const createTranslation = <TData = AxiosResponse<CreateTranslation200>>(
    createTranslationRequest: CreateTranslationRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
formData.append(`file`, createTranslationRequest.file)
formData.append(`model`, createTranslationRequest.model)
if(createTranslationRequest.prompt !== undefined) {
 formData.append(`prompt`, createTranslationRequest.prompt)
 }
if(createTranslationRequest.response_format !== undefined) {
 formData.append(`response_format`, createTranslationRequest.response_format)
 }
if(createTranslationRequest.temperature !== undefined) {
 formData.append(`temperature`, createTranslationRequest.temperature.toString())
 }

    return axios.post(
      `/audio/translations`,
      formData,options
    );
  }

/**
 * Creates a custom voice.
 * @summary Create voice
 */
export const createVoice = <TData = AxiosResponse<VoiceResource>>(
    createVoiceRequest: CreateVoiceRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
formData.append(`name`, createVoiceRequest.name)
formData.append(`audio_sample`, createVoiceRequest.audio_sample)
formData.append(`consent`, createVoiceRequest.consent)

    return axios.post(
      `/audio/voices`,
      formData,options
    );
  }

/**
 * Create a Realtime client secret with an associated session configuration.

 * @summary Create client secret
 */
export const createRealtimeClientSecret = <TData = AxiosResponse<RealtimeCreateClientSecretResponse>>(
    realtimeCreateClientSecretRequest: RealtimeCreateClientSecretRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/realtime/client_secrets`,
      realtimeCreateClientSecretRequest,options
    );
  }

/**
 * Create an ephemeral API token for use in client-side applications with the
Realtime API. Can be configured with the same session parameters as the
`session.update` client event.

It responds with a session object, plus a `client_secret` key which contains
a usable ephemeral API token that can be used to authenticate browser clients
for the Realtime API.

 * @summary Create session
 */
export const createRealtimeSession = <TData = AxiosResponse<RealtimeSessionCreateResponse>>(
    realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/realtime/sessions`,
      realtimeSessionCreateRequest,options
    );
  }

/**
 * Create an ephemeral API token for use in client-side applications with the
Realtime API specifically for realtime transcriptions. 
Can be configured with the same session parameters as the `transcription_session.update` client event.

It responds with a session object, plus a `client_secret` key which contains
a usable ephemeral API token that can be used to authenticate browser clients
for the Realtime API.

 * @summary Create transcription session
 */
export const createRealtimeTranscriptionSession = <TData = AxiosResponse<RealtimeTranscriptionSessionCreateResponse>>(
    realtimeTranscriptionSessionCreateRequest: RealtimeTranscriptionSessionCreateRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/realtime/transcription_sessions`,
      realtimeTranscriptionSessionCreateRequest,options
    );
  }

export type CreateSpeechResult = AxiosResponse<Blob | CreateSpeechResponseStreamEvent>
export type CreateTranscriptionResult = AxiosResponse<CreateTranscription200One | CreateTranscriptionResponseStreamEvent>
export type CreateTranslationResult = AxiosResponse<CreateTranslation200>
export type CreateVoiceResult = AxiosResponse<VoiceResource>
export type CreateRealtimeClientSecretResult = AxiosResponse<RealtimeCreateClientSecretResponse>
export type CreateRealtimeSessionResult = AxiosResponse<RealtimeSessionCreateResponse>
export type CreateRealtimeTranscriptionSessionResult = AxiosResponse<RealtimeTranscriptionSessionCreateResponse>
