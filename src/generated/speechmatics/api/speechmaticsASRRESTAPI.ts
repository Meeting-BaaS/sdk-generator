/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Speechmatics ASR REST API
 * The Speechmatics Automatic Speech Recognition REST API is used to submit ASR jobs and receive the results. The supported job type is transcription of audio files.
 * OpenAPI spec version: 2.0.0
 */

import { faker } from "@faker-js/faker"
import type { AxiosRequestConfig, AxiosResponse } from "axios"
import axios from "axios"
import { delay, HttpResponse, http } from "msw"
import type {
  CreateJobResponse,
  DeleteJobResponse,
  DeleteJobsJobidParams,
  GetJobsJobidAlignmentParams,
  GetJobsJobidTranscriptParams,
  GetJobsParams,
  GetUsageParams,
  PostJobsBody,
  RetrieveJobResponse,
  RetrieveJobsResponse,
  RetrieveTranscriptResponse,
  UsageResponse
} from "../schema"
import { JobMode, JobType, OperatingPoint } from "../schema"

/**
 * @summary Create a new job.
 */
export const postJobs = <TData = AxiosResponse<CreateJobResponse>>(
  postJobsBody: PostJobsBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  const formData = new FormData()
  formData.append("config", postJobsBody.config)
  if (postJobsBody.data_file !== undefined) {
    formData.append("data_file", postJobsBody.data_file)
  }
  if (postJobsBody.text_file !== undefined) {
    formData.append("text_file", postJobsBody.text_file)
  }

  return axios.post("/jobs", formData, options)
}

/**
 * @summary List all jobs.
 */
export const getJobs = <TData = AxiosResponse<RetrieveJobsResponse>>(
  params?: GetJobsParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get("/jobs", {
    ...options,
    params: { ...params, ...options?.params }
  })
}

/**
 * @summary Get job details, including progress and any error reports.
 */
export const getJobsJobid = <TData = AxiosResponse<RetrieveJobResponse>>(
  jobid: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}`, options)
}

/**
 * @summary Delete a job and remove all associated resources.
 */
export const deleteJobsJobid = <TData = AxiosResponse<DeleteJobResponse>>(
  jobid: string,
  params?: DeleteJobsJobidParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.delete(`/jobs/${jobid}`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

/**
 * @summary Get the data file used as input to a job.
 */
export const getJobsJobidData = <TData = AxiosResponse<Blob>>(
  jobid: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}/data`, {
    responseType: "blob",
    ...options
  })
}

/**
 * @summary Get the text file used as input to an alignment job.
 */
export const getJobsJobidText = <TData = AxiosResponse<Blob>>(
  jobid: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}/text`, {
    responseType: "blob",
    ...options
  })
}

/**
 * @summary Get the transcript for a transcription job.
 */
export const getJobsJobidTranscript = <TData = AxiosResponse<RetrieveTranscriptResponse>>(
  jobid: string,
  params?: GetJobsJobidTranscriptParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}/transcript`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}

/**
 * @summary Get the aligned text file for an alignment job.
 */
export const getJobsJobidAlignment = <TData = AxiosResponse<Blob>>(
  jobid: string,
  params?: GetJobsJobidAlignmentParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}/alignment`, {
    responseType: "blob",
    ...options,
    params: { ...params, ...options?.params }
  })
}

/**
 * @summary Get the log file for a job.
 */
export const getJobsJobidLog = <TData = AxiosResponse<Blob>>(
  jobid: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/jobs/${jobid}/log`, {
    responseType: "blob",
    ...options
  })
}

/**
 * @summary Get the usage statistics.
 */
export const getUsage = <TData = AxiosResponse<UsageResponse>>(
  params?: GetUsageParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get("/usage", {
    ...options,
    params: { ...params, ...options?.params }
  })
}

export type PostJobsResult = AxiosResponse<CreateJobResponse>
export type GetJobsResult = AxiosResponse<RetrieveJobsResponse>
export type GetJobsJobidResult = AxiosResponse<RetrieveJobResponse>
export type DeleteJobsJobidResult = AxiosResponse<DeleteJobResponse>
export type GetJobsJobidDataResult = AxiosResponse<Blob>
export type GetJobsJobidTextResult = AxiosResponse<Blob>
export type GetJobsJobidTranscriptResult = AxiosResponse<RetrieveTranscriptResponse>
export type GetJobsJobidAlignmentResult = AxiosResponse<Blob>
export type GetJobsJobidLogResult = AxiosResponse<Blob>
export type GetUsageResult = AxiosResponse<UsageResponse>

export const getPostJobsResponseMock = (
  overrideResponse: Partial<CreateJobResponse> = {}
): CreateJobResponse => ({ id: faker.string.alpha(20), ...overrideResponse })

export const getGetJobsResponseMock = (
  overrideResponse: Partial<RetrieveJobsResponse> = {}
): RetrieveJobsResponse => ({
  jobs: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    data_name: faker.string.alpha(20),
    text_name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    duration: faker.helpers.arrayElement([faker.number.int({ min: 0, max: undefined }), undefined]),
    id: faker.string.alpha(20),
    status: faker.helpers.arrayElement([
      "running",
      "done",
      "rejected",
      "deleted",
      "expired"
    ] as const),
    config: faker.helpers.arrayElement([
      {
        type: faker.helpers.arrayElement(Object.values(JobType)),
        fetch_data: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        fetch_text: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        alignment_config: faker.helpers.arrayElement([
          { language: faker.string.alpha(20) },
          undefined
        ]),
        transcription_config: faker.helpers.arrayElement([
          {
            language: faker.string.alpha(20),
            domain: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            output_locale: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            operating_point: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(OperatingPoint)),
              undefined
            ]),
            additional_vocab: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  content: faker.string.alpha(20),
                  sounds_like: faker.helpers.arrayElement([
                    Array.from(
                      { length: faker.number.int({ min: 1, max: 10 }) },
                      (_, i) => i + 1
                    ).map(() => faker.string.alpha(20)),
                    undefined
                  ])
                })
              ),
              undefined
            ]),
            punctuation_overrides: faker.helpers.arrayElement([
              {
                sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined]),
                permitted_marks: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.helpers.fromRegExp("^(.|all)$")),
                  undefined
                ])
              },
              undefined
            ]),
            diarization: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["none", "speaker", "channel"] as const),
              undefined
            ]),
            channel_diarization_labels: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.helpers.fromRegExp("^[A-Za-z0-9._]+$")
              ),
              undefined
            ]),
            enable_entities: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
            max_delay_mode: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["fixed", "flexible"] as const),
              undefined
            ]),
            transcript_filtering_config: faker.helpers.arrayElement([
              {
                remove_disfluencies: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                replacements: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => ({ from: faker.string.alpha(20), to: faker.string.alpha(20) })),
                  undefined
                ])
              },
              undefined
            ]),
            speaker_diarization_config: faker.helpers.arrayElement([
              {
                prefer_current_speaker: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                speaker_sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined])
              },
              undefined
            ])
          },
          undefined
        ]),
        notification_config: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              url: faker.string.alpha(20),
              contents: faker.helpers.arrayElement([
                faker.helpers.arrayElements([
                  "jobinfo",
                  "transcript",
                  "transcript.json-v2",
                  "transcript.txt",
                  "transcript.srt",
                  "alignment",
                  "alignment.word_start_and_end",
                  "alignment.one_per_line",
                  "data",
                  "text"
                ] as const),
                undefined
              ]),
              method: faker.helpers.arrayElement([
                faker.helpers.arrayElement(["post", "put"] as const),
                undefined
              ]),
              auth_headers: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.string.alpha(20)
                ),
                undefined
              ])
            })
          ),
          undefined
        ]),
        tracking: faker.helpers.arrayElement([
          {
            title: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            reference: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            tags: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            details: faker.helpers.arrayElement([{}, undefined])
          },
          undefined
        ]),
        output_config: faker.helpers.arrayElement([
          {
            srt_overrides: faker.helpers.arrayElement([
              {
                max_line_length: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ]),
                max_lines: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ])
              },
              undefined
            ])
          },
          undefined
        ]),
        translation_config: faker.helpers.arrayElement([
          {
            target_languages: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.string.alpha(20))
          },
          undefined
        ]),
        language_identification_config: faker.helpers.arrayElement([
          {
            expected_languages: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            low_confidence_action: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["allow", "reject", "use_default_language"] as const),
              undefined
            ]),
            default_language: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
          },
          undefined
        ]),
        summarization_config: faker.helpers.arrayElement([
          {
            content_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["auto", "informative", "conversational"] as const),
              undefined
            ]),
            summary_length: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["brief", "detailed"] as const),
              undefined
            ]),
            summary_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["paragraphs", "bullets"] as const),
              undefined
            ])
          },
          undefined
        ]),
        sentiment_analysis_config: faker.helpers.arrayElement([{}, undefined]),
        topic_detection_config: faker.helpers.arrayElement([
          {
            topics: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        auto_chapters_config: faker.helpers.arrayElement([{}, undefined]),
        audio_events_config: faker.helpers.arrayElement([
          {
            types: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ])
      },
      undefined
    ]),
    lang: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        timestamp: faker.string.alpha(20),
        message: faker.string.alpha(20)
      })),
      undefined
    ])
  })),
  ...overrideResponse
})

export const getGetJobsJobidResponseMock = (
  overrideResponse: Partial<RetrieveJobResponse> = {}
): RetrieveJobResponse => ({
  job: {
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    data_name: faker.string.alpha(20),
    text_name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    duration: faker.helpers.arrayElement([faker.number.int({ min: 0, max: undefined }), undefined]),
    id: faker.string.alpha(20),
    status: faker.helpers.arrayElement([
      "running",
      "done",
      "rejected",
      "deleted",
      "expired"
    ] as const),
    config: faker.helpers.arrayElement([
      {
        type: faker.helpers.arrayElement(Object.values(JobType)),
        fetch_data: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        fetch_text: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        alignment_config: faker.helpers.arrayElement([
          { language: faker.string.alpha(20) },
          undefined
        ]),
        transcription_config: faker.helpers.arrayElement([
          {
            language: faker.string.alpha(20),
            domain: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            output_locale: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            operating_point: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(OperatingPoint)),
              undefined
            ]),
            additional_vocab: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  content: faker.string.alpha(20),
                  sounds_like: faker.helpers.arrayElement([
                    Array.from(
                      { length: faker.number.int({ min: 1, max: 10 }) },
                      (_, i) => i + 1
                    ).map(() => faker.string.alpha(20)),
                    undefined
                  ])
                })
              ),
              undefined
            ]),
            punctuation_overrides: faker.helpers.arrayElement([
              {
                sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined]),
                permitted_marks: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.helpers.fromRegExp("^(.|all)$")),
                  undefined
                ])
              },
              undefined
            ]),
            diarization: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["none", "speaker", "channel"] as const),
              undefined
            ]),
            channel_diarization_labels: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.helpers.fromRegExp("^[A-Za-z0-9._]+$")
              ),
              undefined
            ]),
            enable_entities: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
            max_delay_mode: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["fixed", "flexible"] as const),
              undefined
            ]),
            transcript_filtering_config: faker.helpers.arrayElement([
              {
                remove_disfluencies: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                replacements: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => ({ from: faker.string.alpha(20), to: faker.string.alpha(20) })),
                  undefined
                ])
              },
              undefined
            ]),
            speaker_diarization_config: faker.helpers.arrayElement([
              {
                prefer_current_speaker: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                speaker_sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined])
              },
              undefined
            ])
          },
          undefined
        ]),
        notification_config: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              url: faker.string.alpha(20),
              contents: faker.helpers.arrayElement([
                faker.helpers.arrayElements([
                  "jobinfo",
                  "transcript",
                  "transcript.json-v2",
                  "transcript.txt",
                  "transcript.srt",
                  "alignment",
                  "alignment.word_start_and_end",
                  "alignment.one_per_line",
                  "data",
                  "text"
                ] as const),
                undefined
              ]),
              method: faker.helpers.arrayElement([
                faker.helpers.arrayElement(["post", "put"] as const),
                undefined
              ]),
              auth_headers: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.string.alpha(20)
                ),
                undefined
              ])
            })
          ),
          undefined
        ]),
        tracking: faker.helpers.arrayElement([
          {
            title: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            reference: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            tags: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            details: faker.helpers.arrayElement([{}, undefined])
          },
          undefined
        ]),
        output_config: faker.helpers.arrayElement([
          {
            srt_overrides: faker.helpers.arrayElement([
              {
                max_line_length: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ]),
                max_lines: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ])
              },
              undefined
            ])
          },
          undefined
        ]),
        translation_config: faker.helpers.arrayElement([
          {
            target_languages: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.string.alpha(20))
          },
          undefined
        ]),
        language_identification_config: faker.helpers.arrayElement([
          {
            expected_languages: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            low_confidence_action: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["allow", "reject", "use_default_language"] as const),
              undefined
            ]),
            default_language: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
          },
          undefined
        ]),
        summarization_config: faker.helpers.arrayElement([
          {
            content_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["auto", "informative", "conversational"] as const),
              undefined
            ]),
            summary_length: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["brief", "detailed"] as const),
              undefined
            ]),
            summary_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["paragraphs", "bullets"] as const),
              undefined
            ])
          },
          undefined
        ]),
        sentiment_analysis_config: faker.helpers.arrayElement([{}, undefined]),
        topic_detection_config: faker.helpers.arrayElement([
          {
            topics: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        auto_chapters_config: faker.helpers.arrayElement([{}, undefined]),
        audio_events_config: faker.helpers.arrayElement([
          {
            types: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ])
      },
      undefined
    ]),
    lang: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        timestamp: faker.string.alpha(20),
        message: faker.string.alpha(20)
      })),
      undefined
    ])
  },
  ...overrideResponse
})

export const getDeleteJobsJobidResponseMock = (
  overrideResponse: Partial<DeleteJobResponse> = {}
): DeleteJobResponse => ({
  job: {
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    data_name: faker.string.alpha(20),
    text_name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    duration: faker.helpers.arrayElement([faker.number.int({ min: 0, max: undefined }), undefined]),
    id: faker.string.alpha(20),
    status: faker.helpers.arrayElement([
      "running",
      "done",
      "rejected",
      "deleted",
      "expired"
    ] as const),
    config: faker.helpers.arrayElement([
      {
        type: faker.helpers.arrayElement(Object.values(JobType)),
        fetch_data: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        fetch_text: faker.helpers.arrayElement([
          {
            url: faker.string.alpha(20),
            auth_headers: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        alignment_config: faker.helpers.arrayElement([
          { language: faker.string.alpha(20) },
          undefined
        ]),
        transcription_config: faker.helpers.arrayElement([
          {
            language: faker.string.alpha(20),
            domain: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            output_locale: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            operating_point: faker.helpers.arrayElement([
              faker.helpers.arrayElement(Object.values(OperatingPoint)),
              undefined
            ]),
            additional_vocab: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({
                  content: faker.string.alpha(20),
                  sounds_like: faker.helpers.arrayElement([
                    Array.from(
                      { length: faker.number.int({ min: 1, max: 10 }) },
                      (_, i) => i + 1
                    ).map(() => faker.string.alpha(20)),
                    undefined
                  ])
                })
              ),
              undefined
            ]),
            punctuation_overrides: faker.helpers.arrayElement([
              {
                sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined]),
                permitted_marks: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => faker.helpers.fromRegExp("^(.|all)$")),
                  undefined
                ])
              },
              undefined
            ]),
            diarization: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["none", "speaker", "channel"] as const),
              undefined
            ]),
            channel_diarization_labels: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.helpers.fromRegExp("^[A-Za-z0-9._]+$")
              ),
              undefined
            ]),
            enable_entities: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
            max_delay_mode: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["fixed", "flexible"] as const),
              undefined
            ]),
            transcript_filtering_config: faker.helpers.arrayElement([
              {
                remove_disfluencies: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                replacements: faker.helpers.arrayElement([
                  Array.from(
                    { length: faker.number.int({ min: 1, max: 10 }) },
                    (_, i) => i + 1
                  ).map(() => ({ from: faker.string.alpha(20), to: faker.string.alpha(20) })),
                  undefined
                ])
              },
              undefined
            ]),
            speaker_diarization_config: faker.helpers.arrayElement([
              {
                prefer_current_speaker: faker.helpers.arrayElement([
                  faker.datatype.boolean(),
                  undefined
                ]),
                speaker_sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined])
              },
              undefined
            ])
          },
          undefined
        ]),
        notification_config: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              url: faker.string.alpha(20),
              contents: faker.helpers.arrayElement([
                faker.helpers.arrayElements([
                  "jobinfo",
                  "transcript",
                  "transcript.json-v2",
                  "transcript.txt",
                  "transcript.srt",
                  "alignment",
                  "alignment.word_start_and_end",
                  "alignment.one_per_line",
                  "data",
                  "text"
                ] as const),
                undefined
              ]),
              method: faker.helpers.arrayElement([
                faker.helpers.arrayElement(["post", "put"] as const),
                undefined
              ]),
              auth_headers: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.string.alpha(20)
                ),
                undefined
              ])
            })
          ),
          undefined
        ]),
        tracking: faker.helpers.arrayElement([
          {
            title: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            reference: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            tags: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            details: faker.helpers.arrayElement([{}, undefined])
          },
          undefined
        ]),
        output_config: faker.helpers.arrayElement([
          {
            srt_overrides: faker.helpers.arrayElement([
              {
                max_line_length: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ]),
                max_lines: faker.helpers.arrayElement([
                  faker.number.int({ min: undefined, max: undefined }),
                  undefined
                ])
              },
              undefined
            ])
          },
          undefined
        ]),
        translation_config: faker.helpers.arrayElement([
          {
            target_languages: Array.from(
              { length: faker.number.int({ min: 1, max: 10 }) },
              (_, i) => i + 1
            ).map(() => faker.string.alpha(20))
          },
          undefined
        ]),
        language_identification_config: faker.helpers.arrayElement([
          {
            expected_languages: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ]),
            low_confidence_action: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["allow", "reject", "use_default_language"] as const),
              undefined
            ]),
            default_language: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
          },
          undefined
        ]),
        summarization_config: faker.helpers.arrayElement([
          {
            content_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["auto", "informative", "conversational"] as const),
              undefined
            ]),
            summary_length: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["brief", "detailed"] as const),
              undefined
            ]),
            summary_type: faker.helpers.arrayElement([
              faker.helpers.arrayElement(["paragraphs", "bullets"] as const),
              undefined
            ])
          },
          undefined
        ]),
        sentiment_analysis_config: faker.helpers.arrayElement([{}, undefined]),
        topic_detection_config: faker.helpers.arrayElement([
          {
            topics: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ]),
        auto_chapters_config: faker.helpers.arrayElement([{}, undefined]),
        audio_events_config: faker.helpers.arrayElement([
          {
            types: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          },
          undefined
        ])
      },
      undefined
    ]),
    lang: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        timestamp: faker.string.alpha(20),
        message: faker.string.alpha(20)
      })),
      undefined
    ])
  },
  ...overrideResponse
})

export const getGetJobsJobidDataResponseMock = (): Blob =>
  new Blob(faker.helpers.arrayElements(faker.word.words(10).split(" ")))

export const getGetJobsJobidTextResponseMock = (): Blob =>
  new Blob(faker.helpers.arrayElements(faker.word.words(10).split(" ")))

export const getGetJobsJobidTranscriptResponseMock = (
  overrideResponse: Partial<RetrieveTranscriptResponse> = {}
): RetrieveTranscriptResponse => ({
  format: faker.string.alpha(20),
  job: {
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    data_name: faker.string.alpha(20),
    duration: faker.number.int({ min: 0, max: undefined }),
    id: faker.string.alpha(20),
    text_name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
    tracking: faker.helpers.arrayElement([
      {
        title: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        reference: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        tags: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.string.alpha(20)
          ),
          undefined
        ]),
        details: faker.helpers.arrayElement([{}, undefined])
      },
      undefined
    ])
  },
  metadata: {
    created_at: `${faker.date.past().toISOString().split(".")[0]}Z`,
    type: faker.helpers.arrayElement(Object.values(JobType)),
    transcription_config: faker.helpers.arrayElement([
      {
        language: faker.string.alpha(20),
        domain: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        output_locale: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        operating_point: faker.helpers.arrayElement([
          faker.helpers.arrayElement(Object.values(OperatingPoint)),
          undefined
        ]),
        additional_vocab: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              content: faker.string.alpha(20),
              sounds_like: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => faker.string.alpha(20)
                ),
                undefined
              ])
            })
          ),
          undefined
        ]),
        punctuation_overrides: faker.helpers.arrayElement([
          {
            sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined]),
            permitted_marks: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.helpers.fromRegExp("^(.|all)$")
              ),
              undefined
            ])
          },
          undefined
        ]),
        diarization: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["none", "speaker", "channel"] as const),
          undefined
        ]),
        channel_diarization_labels: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
            faker.helpers.fromRegExp("^[A-Za-z0-9._]+$")
          ),
          undefined
        ]),
        enable_entities: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
        max_delay_mode: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["fixed", "flexible"] as const),
          undefined
        ]),
        transcript_filtering_config: faker.helpers.arrayElement([
          {
            remove_disfluencies: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
            replacements: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => ({ from: faker.string.alpha(20), to: faker.string.alpha(20) })
              ),
              undefined
            ])
          },
          undefined
        ]),
        speaker_diarization_config: faker.helpers.arrayElement([
          {
            prefer_current_speaker: faker.helpers.arrayElement([
              faker.datatype.boolean(),
              undefined
            ]),
            speaker_sensitivity: faker.helpers.arrayElement([faker.number.float(), undefined])
          },
          undefined
        ])
      },
      undefined
    ]),
    translation_errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        type: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "translation_failed",
            "unsupported_translation_pair"
          ] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      })),
      undefined
    ]),
    summarization_errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        type: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["summarization_failed", "unsupported_language"] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      })),
      undefined
    ]),
    sentiment_analysis_errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        type: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "sentiment_analysis_failed",
            "unsupported_language"
          ] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      })),
      undefined
    ]),
    topic_detection_errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        type: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "topic_detection_failed",
            "unsupported_list_of_topics",
            "unsupported_language"
          ] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      })),
      undefined
    ]),
    auto_chapters_errors: faker.helpers.arrayElement([
      Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
        type: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["auto_chapters_failed", "unsupported_language"] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      })),
      undefined
    ]),
    alignment_config: faker.helpers.arrayElement([{ language: faker.string.alpha(20) }, undefined]),
    output_config: faker.helpers.arrayElement([
      {
        srt_overrides: faker.helpers.arrayElement([
          {
            max_line_length: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined
            ]),
            max_lines: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined
            ])
          },
          undefined
        ])
      },
      undefined
    ]),
    language_pack_info: faker.helpers.arrayElement([
      {
        language_description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        word_delimiter: faker.string.alpha(20),
        writing_direction: faker.helpers.arrayElement([
          faker.helpers.arrayElement(["left-to-right", "right-to-left"] as const),
          undefined
        ]),
        itn: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
        adapted: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])
      },
      undefined
    ]),
    language_identification: faker.helpers.arrayElement([
      {
        results: faker.helpers.arrayElement([
          Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
            () => ({
              alternatives: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    language: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                    confidence: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ])
                  })
                ),
                undefined
              ]),
              start_time: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined
              ]),
              end_time: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined
              ])
            })
          ),
          undefined
        ]),
        error: faker.helpers.arrayElement([
          faker.helpers.arrayElement([
            "LOW_CONFIDENCE",
            "UNEXPECTED_LANGUAGE",
            "NO_SPEECH",
            "FILE_UNREADABLE",
            "OTHER"
          ] as const),
          undefined
        ]),
        message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      },
      undefined
    ]),
    orchestrator_version: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
  },
  results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => ({
      channel: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      start_time: faker.number.float(),
      end_time: faker.number.float(),
      volume: faker.helpers.arrayElement([faker.number.float(), undefined]),
      is_eos: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]),
      type: faker.helpers.arrayElement(["word", "punctuation", "entity"] as const),
      written_form: faker.helpers.arrayElement([
        Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          alternatives: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => ({
            content: faker.string.alpha(20),
            confidence: faker.number.float(),
            language: faker.string.alpha(20),
            display: faker.helpers.arrayElement([
              { direction: faker.helpers.arrayElement(["ltr", "rtl"] as const) },
              undefined
            ]),
            speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            tags: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          })),
          end_time: faker.number.float(),
          start_time: faker.number.float(),
          type: faker.helpers.arrayElement(["word"] as const)
        })),
        undefined
      ]),
      spoken_form: faker.helpers.arrayElement([
        Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          alternatives: Array.from(
            { length: faker.number.int({ min: 1, max: 10 }) },
            (_, i) => i + 1
          ).map(() => ({
            content: faker.string.alpha(20),
            confidence: faker.number.float(),
            language: faker.string.alpha(20),
            display: faker.helpers.arrayElement([
              { direction: faker.helpers.arrayElement(["ltr", "rtl"] as const) },
              undefined
            ]),
            speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
            tags: faker.helpers.arrayElement([
              Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                () => faker.string.alpha(20)
              ),
              undefined
            ])
          })),
          end_time: faker.number.float(),
          start_time: faker.number.float(),
          type: faker.helpers.arrayElement(["word", "punctuation"] as const)
        })),
        undefined
      ]),
      alternatives: faker.helpers.arrayElement([
        Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          content: faker.string.alpha(20),
          confidence: faker.number.float(),
          language: faker.string.alpha(20),
          display: faker.helpers.arrayElement([
            { direction: faker.helpers.arrayElement(["ltr", "rtl"] as const) },
            undefined
          ]),
          speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
          tags: faker.helpers.arrayElement([
            Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() =>
              faker.string.alpha(20)
            ),
            undefined
          ])
        })),
        undefined
      ]),
      attaches_to: faker.helpers.arrayElement([
        faker.helpers.arrayElement(["previous", "next", "both", "none"] as const),
        undefined
      ])
    })
  ),
  translations: faker.helpers.arrayElement([
    {
      [faker.string.alphanumeric(5)]: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1
      ).map(() => ({
        start_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
        end_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
        content: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
        channel: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
      }))
    },
    undefined
  ]),
  summary: faker.helpers.arrayElement([
    { content: faker.helpers.arrayElement([faker.string.alpha(20), undefined]) },
    undefined
  ]),
  sentiment_analysis: faker.helpers.arrayElement([
    {
      sentiment_analysis: faker.helpers.arrayElement([
        {
          segments: faker.helpers.arrayElement([
            Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({
                text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                start_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
                end_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
                sentiment: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                channel: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                confidence: faker.helpers.arrayElement([faker.number.float(), undefined])
              })
            ),
            undefined
          ]),
          summary: faker.helpers.arrayElement([
            {
              overall: faker.helpers.arrayElement([
                {
                  positive_count: faker.helpers.arrayElement([
                    faker.number.int({ min: undefined, max: undefined }),
                    undefined
                  ]),
                  negative_count: faker.helpers.arrayElement([
                    faker.number.int({ min: undefined, max: undefined }),
                    undefined
                  ]),
                  neutral_count: faker.helpers.arrayElement([
                    faker.number.int({ min: undefined, max: undefined }),
                    undefined
                  ])
                },
                undefined
              ]),
              speakers: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    speaker: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                    positive_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ]),
                    negative_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ]),
                    neutral_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ])
                  })
                ),
                undefined
              ]),
              channels: faker.helpers.arrayElement([
                Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
                  () => ({
                    channel: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
                    positive_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ]),
                    negative_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ]),
                    neutral_count: faker.helpers.arrayElement([
                      faker.number.int({ min: undefined, max: undefined }),
                      undefined
                    ])
                  })
                ),
                undefined
              ])
            },
            undefined
          ])
        },
        undefined
      ])
    },
    undefined
  ]),
  topics: faker.helpers.arrayElement([
    {
      segments: faker.helpers.arrayElement([
        Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
          text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
          start_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
          end_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
          topics: faker.helpers.arrayElement([
            Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
              () => ({ topic: faker.helpers.arrayElement([faker.string.alpha(20), undefined]) })
            ),
            undefined
          ])
        })),
        undefined
      ]),
      summary: faker.helpers.arrayElement([
        {
          overall: faker.helpers.arrayElement([
            {
              [faker.string.alphanumeric(5)]: faker.number.int({ min: undefined, max: undefined })
            },
            undefined
          ])
        },
        undefined
      ])
    },
    undefined
  ]),
  chapters: faker.helpers.arrayElement([
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      title: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      summary: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      start_time: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined
      ]),
      end_time: faker.helpers.arrayElement([
        faker.number.int({ min: undefined, max: undefined }),
        undefined
      ])
    })),
    undefined
  ]),
  audio_events: faker.helpers.arrayElement([
    Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({
      type: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      start_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
      end_time: faker.helpers.arrayElement([faker.number.float(), undefined]),
      confidence: faker.helpers.arrayElement([faker.number.float(), undefined]),
      channel: faker.helpers.arrayElement([faker.string.alpha(20), undefined])
    })),
    undefined
  ]),
  audio_event_summary: faker.helpers.arrayElement([
    {
      overall: faker.helpers.arrayElement([
        {
          [faker.string.alphanumeric(5)]: {
            total_duration: faker.helpers.arrayElement([faker.number.float(), undefined]),
            count: faker.helpers.arrayElement([
              faker.number.int({ min: undefined, max: undefined }),
              undefined
            ])
          }
        },
        undefined
      ]),
      channels: faker.helpers.arrayElement([
        {
          [faker.string.alphanumeric(5)]: {
            [faker.string.alphanumeric(5)]: {
              total_duration: faker.helpers.arrayElement([faker.number.float(), undefined]),
              count: faker.helpers.arrayElement([
                faker.number.int({ min: undefined, max: undefined }),
                undefined
              ])
            }
          }
        },
        undefined
      ])
    },
    undefined
  ]),
  ...overrideResponse
})

export const getGetJobsJobidAlignmentResponseMock = (): Blob =>
  new Blob(faker.helpers.arrayElements(faker.word.words(10).split(" ")))

export const getGetJobsJobidLogResponseMock = (): Blob =>
  new Blob(faker.helpers.arrayElements(faker.word.words(10).split(" ")))

export const getGetUsageResponseMock = (
  overrideResponse: Partial<UsageResponse> = {}
): UsageResponse => ({
  since: `${faker.date.past().toISOString().split(".")[0]}Z`,
  until: `${faker.date.past().toISOString().split(".")[0]}Z`,
  summary: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => ({
      mode: faker.helpers.arrayElement(Object.values(JobMode)),
      type: faker.helpers.arrayElement(Object.values(JobType)),
      language: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      operating_point: faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(OperatingPoint)),
        undefined
      ]),
      count: faker.number.int({ min: undefined, max: undefined }),
      duration_hrs: faker.number.float()
    })
  ),
  details: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(
    () => ({
      mode: faker.helpers.arrayElement(Object.values(JobMode)),
      type: faker.helpers.arrayElement(Object.values(JobType)),
      language: faker.helpers.arrayElement([faker.string.alpha(20), undefined]),
      operating_point: faker.helpers.arrayElement([
        faker.helpers.arrayElement(Object.values(OperatingPoint)),
        undefined
      ]),
      count: faker.number.int({ min: undefined, max: undefined }),
      duration_hrs: faker.number.float()
    })
  ),
  ...overrideResponse
})

export const getPostJobsMockHandler = (
  overrideResponse?:
    | CreateJobResponse
    | ((
        info: Parameters<Parameters<typeof http.post>[1]>[0]
      ) => Promise<CreateJobResponse> | CreateJobResponse)
) => {
  return http.post("https://asr.api.speechmatics.com/jobs", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getPostJobsResponseMock()
      ),
      { status: 201, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetJobsMockHandler = (
  overrideResponse?:
    | RetrieveJobsResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<RetrieveJobsResponse> | RetrieveJobsResponse)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetJobsResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetJobsJobidMockHandler = (
  overrideResponse?:
    | RetrieveJobResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<RetrieveJobResponse> | RetrieveJobResponse)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetJobsJobidResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getDeleteJobsJobidMockHandler = (
  overrideResponse?:
    | DeleteJobResponse
    | ((
        info: Parameters<Parameters<typeof http.delete>[1]>[0]
      ) => Promise<DeleteJobResponse> | DeleteJobResponse)
) => {
  return http.delete("https://asr.api.speechmatics.com/jobs/:jobid", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getDeleteJobsJobidResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetJobsJobidDataMockHandler = (
  overrideResponse?:
    | Blob
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid/data", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetJobsJobidDataResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetJobsJobidTextMockHandler = (
  overrideResponse?:
    | Blob
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid/text", async (info) => {
    await delay(1000)

    return new HttpResponse(getGetJobsJobidTextResponseMock(), {
      status: 200,
      headers: { "Content-Type": "text/plain" }
    })
  })
}

export const getGetJobsJobidTranscriptMockHandler = (
  overrideResponse?:
    | RetrieveTranscriptResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<RetrieveTranscriptResponse> | RetrieveTranscriptResponse)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid/transcript", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetJobsJobidTranscriptResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetJobsJobidAlignmentMockHandler = (
  overrideResponse?:
    | Blob
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid/alignment", async (info) => {
    await delay(1000)

    return new HttpResponse(getGetJobsJobidAlignmentResponseMock(), {
      status: 200,
      headers: { "Content-Type": "text/plain" }
    })
  })
}

export const getGetJobsJobidLogMockHandler = (
  overrideResponse?:
    | Blob
    | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob)
) => {
  return http.get("https://asr.api.speechmatics.com/jobs/:jobid/log", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetJobsJobidLogResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}

export const getGetUsageMockHandler = (
  overrideResponse?:
    | UsageResponse
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<UsageResponse> | UsageResponse)
) => {
  return http.get("https://asr.api.speechmatics.com/usage", async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === "function"
            ? await overrideResponse(info)
            : overrideResponse
          : getGetUsageResponseMock()
      ),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  })
}
export const getSpeechmaticsASRRESTAPIMock = () => [
  getPostJobsMockHandler(),
  getGetJobsMockHandler(),
  getGetJobsJobidMockHandler(),
  getDeleteJobsJobidMockHandler(),
  getGetJobsJobidDataMockHandler(),
  getGetJobsJobidTextMockHandler(),
  getGetJobsJobidTranscriptMockHandler(),
  getGetJobsJobidAlignmentMockHandler(),
  getGetJobsJobidLogMockHandler(),
  getGetUsageMockHandler()
]
