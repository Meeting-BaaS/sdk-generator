/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Speech Services API version 3.2
 * Speech Services API version 3.2.
 * OpenAPI spec version: 3.2
 */
import axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CommitBlocksEntry,
  DatasetUpdate,
  DatasetsGetFileParams,
  DatasetsListFilesParams,
  DatasetsListParams,
  DatasetsUploadBlockParams,
  DatasetsUploadBody,
  EndpointUpdate,
  EndpointsDeleteBaseModelLogsParams,
  EndpointsDeleteLogsParams,
  EndpointsGetBaseModelLogParams,
  EndpointsGetLogParams,
  EndpointsListBaseModelLogsParams,
  EndpointsListLogsParams,
  EndpointsListParams,
  EvaluationUpdate,
  EvaluationsGetFileParams,
  EvaluationsListFilesParams,
  EvaluationsListParams,
  ModelCopyAuthorizationDefinition,
  ModelUpdate,
  ModelsGetBaseModelManifestParams,
  ModelsGetCustomModelManifestParams,
  ModelsGetFileParams,
  ModelsListBaseModelsParams,
  ModelsListCustomModelsParams,
  ModelsListFilesParams,
  ProjectUpdate,
  ProjectsListDatasetsParams,
  ProjectsListEndpointsParams,
  ProjectsListEvaluationsParams,
  ProjectsListModelsParams,
  ProjectsListParams,
  ProjectsListTranscriptionsParams,
  TranscriptionUpdate,
  TranscriptionsGetFileParams,
  TranscriptionsListFilesParams,
  TranscriptionsListParams,
  WebHookUpdate,
  WebHooksListParams
} from '../schema';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import {
  DatasetKind,
  FileKind,
  LanguageIdentificationMode,
  OutputFormatType,
  ProfanityFilterMode,
  PunctuationMode,
  Status,
  TextNormalizationKind
} from '../schema';
import type {
  BaseModel,
  CustomModel,
  Dataset,
  DatasetLocales,
  Endpoint,
  Evaluation,
  File,
  ModelCopyAuthorization,
  ModelManifest,
  Operation,
  PaginatedBaseModels,
  PaginatedCustomModels,
  PaginatedDatasets,
  PaginatedEndpoints,
  PaginatedEvaluations,
  PaginatedFiles,
  PaginatedProjects,
  PaginatedTranscriptions,
  PaginatedWebHooks,
  Project,
  Transcription,
  UploadedBlocks,
  WebHook
} from '../schema';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * @summary Gets a list of supported locales for datasets.
 */
export const datasetsListSupportedLocales = <TData = AxiosResponse<DatasetLocales>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/locales`,options
    );
  }

/**
 * @summary Gets a list of datasets for the authenticated subscription.
 */
export const datasetsList = <TData = AxiosResponse<PaginatedDatasets>>(
    params?: DatasetsListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Uploads and creates a new dataset by getting the data from a specified URL or starts waiting for data blocks to be uploaded.
 */
export const datasetsCreate = <TData = AxiosResponse<Dataset>>(
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/datasets`,
      dataset,options
    );
  }

/**
 * @summary Gets the dataset identified by the given ID.
 */
export const datasetsGet = <TData = AxiosResponse<Dataset>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${id}`,options
    );
  }

/**
 * @summary Updates the mutable details of the dataset identified by its ID.
 */
export const datasetsUpdate = <TData = AxiosResponse<Dataset>>(
    id: string,
    datasetUpdate: DatasetUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/datasets/${id}`,
      datasetUpdate,options
    );
  }

/**
 * @summary Deletes the specified dataset.
 */
export const datasetsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/datasets/${id}`,options
    );
  }

/**
 * @summary Gets the list of uploaded blocks for this dataset.
 */
export const datasetsGetBlocks = <TData = AxiosResponse<UploadedBlocks>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${id}/blocks`,options
    );
  }

/**
 * @summary Upload a block of data for the dataset. The maximum size of the block is 8MiB.
 */
export const datasetsUploadBlock = <TData = AxiosResponse<void>>(
    id: string,
    datasetsUploadBlockBody: Blob,
    params: DatasetsUploadBlockParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.put(
      `/datasets/${id}/blocks`,
      datasetsUploadBlockBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @deprecated
 * @summary Uploads data and creates a new dataset.
 */
export const datasetsUpload = <TData = AxiosResponse<Dataset>>(
    datasetsUploadBody: DatasetsUploadBody, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
if(datasetsUploadBody.project !== undefined) {
 formData.append(`project`, datasetsUploadBody.project)
 }
formData.append(`displayName`, datasetsUploadBody.displayName)
if(datasetsUploadBody.description !== undefined) {
 formData.append(`description`, datasetsUploadBody.description)
 }
formData.append(`locale`, datasetsUploadBody.locale)
formData.append(`kind`, datasetsUploadBody.kind)
if(datasetsUploadBody.customProperties !== undefined) {
 formData.append(`customProperties`, datasetsUploadBody.customProperties)
 }
if(datasetsUploadBody.data !== undefined) {
 formData.append(`data`, datasetsUploadBody.data)
 }
if(datasetsUploadBody.email !== undefined) {
 formData.append(`email`, datasetsUploadBody.email)
 }

    return axios.post(
      `/datasets/upload`,
      formData,options
    );
  }

/**
 * @summary Commit block list to complete the upload of the dataset.
 */
export const datasetsCommitBlocks = <TData = AxiosResponse<void>>(
    id: string,
    commitBlocksEntry: CommitBlocksEntry[], options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/datasets/${id}/blocks:commit`,
      commitBlocksEntry,options
    );
  }

/**
 * @summary Gets the files of the dataset identified by the given ID.
 */
export const datasetsListFiles = <TData = AxiosResponse<PaginatedFiles>>(
    id: string,
    params?: DatasetsListFilesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${id}/files`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets one specific file (identified with fileId) from a dataset (identified with id).
 */
export const datasetsGetFile = <TData = AxiosResponse<File>>(
    id: string,
    fileId: string,
    params?: DatasetsGetFileParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/datasets/${id}/files/${fileId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets a list of supported locales for endpoint creations.
 */
export const endpointsListSupportedLocales = <TData = AxiosResponse<string[]>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/locales`,options
    );
  }

/**
 * @summary Gets the list of endpoints for the authenticated subscription.
 */
export const endpointsList = <TData = AxiosResponse<PaginatedEndpoints>>(
    params?: EndpointsListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Creates a new endpoint.
 */
export const endpointsCreate = <TData = AxiosResponse<Endpoint>>(
    endpoint: NonReadonly<Endpoint>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/endpoints`,
      endpoint,options
    );
  }

/**
 * @summary Gets the endpoint identified by the given ID.
 */
export const endpointsGet = <TData = AxiosResponse<Endpoint>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/${id}`,options
    );
  }

/**
 * @summary Deletes the endpoint identified by the given ID.
 */
export const endpointsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/endpoints/${id}`,options
    );
  }

/**
 * @summary Updates the metadata of the endpoint identified by the given ID.
 */
export const endpointsUpdate = <TData = AxiosResponse<Endpoint>>(
    id: string,
    endpointUpdate: EndpointUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/endpoints/${id}`,
      endpointUpdate,options
    );
  }

/**
 * @summary Gets the list of audio and transcription logs that have been stored for a given endpoint.
 */
export const endpointsListLogs = <TData = AxiosResponse<PaginatedFiles>>(
    id: string,
    params?: EndpointsListLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/${id}/files/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * The deletion process is done asynchronously and can take up to one day depending on the amount of log files.
 * @summary Deletes the specified audio and transcription logs that have been stored for a given endpoint. It deletes all logs before (and including) a specific day.
 */
export const endpointsDeleteLogs = <TData = AxiosResponse<void>>(
    id: string,
    params?: EndpointsDeleteLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/endpoints/${id}/files/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets a specific audio or transcription log for a given endpoint.
 */
export const endpointsGetLog = <TData = AxiosResponse<File>>(
    id: string,
    logId: string,
    params?: EndpointsGetLogParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/${id}/files/logs/${logId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Deletes one audio or transcription log that have been stored for a given endpoint.
 */
export const endpointsDeleteLog = <TData = AxiosResponse<void>>(
    id: string,
    logId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/endpoints/${id}/files/logs/${logId}`,options
    );
  }

/**
 * @summary Gets the list of audio and transcription logs that have been stored when using the default base model of a given language.
 */
export const endpointsListBaseModelLogs = <TData = AxiosResponse<PaginatedFiles>>(
    locale: string,
    params?: EndpointsListBaseModelLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/base/${locale}/files/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Deletion process is done asynchronously and can take up to one day depending on the amount of log files.
 * @summary Deletes the specified audio and transcription logs that have been stored when using the default base model of a given language. It deletes all logs before (and including) a specific day.
 */
export const endpointsDeleteBaseModelLogs = <TData = AxiosResponse<void>>(
    locale: string,
    params?: EndpointsDeleteBaseModelLogsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/endpoints/base/${locale}/files/logs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets a specific audio or transcription log for the default base model in a given language.
 */
export const endpointsGetBaseModelLog = <TData = AxiosResponse<File>>(
    locale: string,
    logId: string,
    params?: EndpointsGetBaseModelLogParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/endpoints/base/${locale}/files/logs/${logId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Deletes one audio or transcription log that have been stored when using the default base model of a given language.
 */
export const endpointsDeleteBaseModelLog = <TData = AxiosResponse<void>>(
    locale: string,
    logId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/endpoints/base/${locale}/files/logs/${logId}`,options
    );
  }

/**
 * @summary Gets a list of supported locales for evaluations.
 */
export const evaluationsListSupportedLocales = <TData = AxiosResponse<string[]>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/evaluations/locales`,options
    );
  }

/**
 * @summary Gets the list of evaluations for the authenticated subscription.
 */
export const evaluationsList = <TData = AxiosResponse<PaginatedEvaluations>>(
    params?: EvaluationsListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/evaluations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Creates a new evaluation.
 */
export const evaluationsCreate = <TData = AxiosResponse<Evaluation>>(
    evaluation: NonReadonly<Evaluation>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/evaluations`,
      evaluation,options
    );
  }

/**
 * @summary Gets the files of the evaluation identified by the given ID.
 */
export const evaluationsListFiles = <TData = AxiosResponse<PaginatedFiles>>(
    id: string,
    params?: EvaluationsListFilesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/evaluations/${id}/files`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets one specific file (identified with fileId) from an evaluation (identified with id).
 */
export const evaluationsGetFile = <TData = AxiosResponse<File>>(
    id: string,
    fileId: string,
    params?: EvaluationsGetFileParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/evaluations/${id}/files/${fileId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the evaluation identified by the given ID.
 */
export const evaluationsGet = <TData = AxiosResponse<Evaluation>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/evaluations/${id}`,options
    );
  }

/**
 * @summary Updates the mutable details of the evaluation identified by its id.
 */
export const evaluationsUpdate = <TData = AxiosResponse<Evaluation>>(
    id: string,
    evaluationUpdate: EvaluationUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/evaluations/${id}`,
      evaluationUpdate,options
    );
  }

/**
 * @summary Deletes the evaluation identified by the given ID.
 */
export const evaluationsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/evaluations/${id}`,options
    );
  }

/**
 * @summary Gets a list of supported locales for model adaptation.
 */
export const modelsListSupportedLocales = <TData = AxiosResponse<string[]>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/locales`,options
    );
  }

/**
 * @summary Gets the list of custom models for the authenticated subscription.
 */
export const modelsListCustomModels = <TData = AxiosResponse<PaginatedCustomModels>>(
    params?: ModelsListCustomModelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Creates a new model.
 */
export const modelsCreate = <TData = AxiosResponse<CustomModel>>(
    customModel: NonReadonly<CustomModel>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/models`,
      customModel,options
    );
  }

/**
 * @summary Gets the list of base models for the authenticated subscription.
 */
export const modelsListBaseModels = <TData = AxiosResponse<PaginatedBaseModels>>(
    params?: ModelsListBaseModelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/base`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the model identified by the given ID.
 */
export const modelsGetCustomModel = <TData = AxiosResponse<CustomModel>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/${id}`,options
    );
  }

/**
 * @summary Updates the metadata of the model identified by the given ID.
 */
export const modelsUpdate = <TData = AxiosResponse<CustomModel>>(
    id: string,
    modelUpdate: ModelUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/models/${id}`,
      modelUpdate,options
    );
  }

/**
 * @summary Deletes the model identified by the given ID.
 */
export const modelsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/models/${id}`,options
    );
  }

/**
 * @summary Gets the base model identified by the given ID.
 */
export const modelsGetBaseModel = <TData = AxiosResponse<BaseModel>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/base/${id}`,options
    );
  }

/**
 * This method can be used to copy a model from this speech resource to a target one.
The authorization is obtained on the target speech resource.
Only custom models can be copied to another speech resource.
 * @summary Copies a model from one subscription to another.
 */
export const modelsCopy = <TData = AxiosResponse<Operation>>(
    id: string,
    modelCopyAuthorization: ModelCopyAuthorization, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/models/${id}:copy`,
      modelCopyAuthorization,options
    );
  }

/**
 * This method can be used to allow copying a model from another speech resource.
Only custom models can be copied from another speech resource.
 * @summary Allows another speech resource (source) to copy a model to this speech resource (target).
 */
export const modelsAuthorizeCopy = <TData = AxiosResponse<ModelCopyAuthorization>>(
    modelCopyAuthorizationDefinition: ModelCopyAuthorizationDefinition, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/models:authorizecopy`,
      modelCopyAuthorizationDefinition,options
    );
  }

/**
 * @summary Returns an manifest for this model which can be used in an on-premise container.
 */
export const modelsGetCustomModelManifest = <TData = AxiosResponse<ModelManifest>>(
    id: string,
    params?: ModelsGetCustomModelManifestParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/${id}/manifest`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Returns an manifest for this base model which can be used in an on-premise container.
 */
export const modelsGetBaseModelManifest = <TData = AxiosResponse<ModelManifest>>(
    id: string,
    params?: ModelsGetBaseModelManifestParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/base/${id}/manifest`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the files of the model identified by the given ID.
 */
export const modelsListFiles = <TData = AxiosResponse<PaginatedFiles>>(
    id: string,
    params?: ModelsListFilesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/${id}/files`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets one specific file (identified with fileId) from a model (identified with id).
 */
export const modelsGetFile = <TData = AxiosResponse<File>>(
    id: string,
    fileId: string,
    params?: ModelsGetFileParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/models/${id}/files/${fileId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the operation identified by the given ID.
 */
export const operationsGetModelCopy = <TData = AxiosResponse<Operation>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/operations/models/copy/${id}`,options
    );
  }

/**
 * @summary Gets the list of supported locales.
 */
export const projectsListSupportedLocales = <TData = AxiosResponse<string[]>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/locales`,options
    );
  }

/**
 * @summary Gets the list of projects for the authenticated subscription.
 */
export const projectsList = <TData = AxiosResponse<PaginatedProjects>>(
    params?: ProjectsListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Creates a new project.
 */
export const projectsCreate = <TData = AxiosResponse<Project>>(
    project: NonReadonly<Project>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/projects`,
      project,options
    );
  }

/**
 * @summary Gets the project identified by the given ID.
 */
export const projectsGet = <TData = AxiosResponse<Project>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}`,options
    );
  }

/**
 * @summary Updates the project identified by the given ID.
 */
export const projectsUpdate = <TData = AxiosResponse<Project>>(
    id: string,
    projectUpdate: ProjectUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/projects/${id}`,
      projectUpdate,options
    );
  }

/**
 * @summary Deletes the project identified by the given ID.
 */
export const projectsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/projects/${id}`,options
    );
  }

/**
 * @summary Gets the list of evaluations for specified project.
 */
export const projectsListEvaluations = <TData = AxiosResponse<PaginatedEvaluations>>(
    id: string,
    params?: ProjectsListEvaluationsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}/evaluations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the list of datasets for specified project.
 */
export const projectsListDatasets = <TData = AxiosResponse<PaginatedDatasets>>(
    id: string,
    params?: ProjectsListDatasetsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}/datasets`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the list of endpoints for specified project.
 */
export const projectsListEndpoints = <TData = AxiosResponse<PaginatedEndpoints>>(
    id: string,
    params?: ProjectsListEndpointsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}/endpoints`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the list of models for specified project.
 */
export const projectsListModels = <TData = AxiosResponse<PaginatedCustomModels>>(
    id: string,
    params?: ProjectsListModelsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}/models`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the list of transcriptions for specified project.
 */
export const projectsListTranscriptions = <TData = AxiosResponse<PaginatedTranscriptions>>(
    id: string,
    params?: ProjectsListTranscriptionsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/projects/${id}/transcriptions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets a list of supported locales for offline transcriptions.
 */
export const transcriptionsListSupportedLocales = <TData = AxiosResponse<string[]>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/transcriptions/locales`,options
    );
  }

/**
 * @summary Gets a list of transcriptions for the authenticated subscription.
 */
export const transcriptionsList = <TData = AxiosResponse<PaginatedTranscriptions>>(
    params?: TranscriptionsListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/transcriptions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Creates a new transcription.
 */
export const transcriptionsCreate = <TData = AxiosResponse<Transcription>>(
    transcription: NonReadonly<Transcription>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/transcriptions`,
      transcription,options
    );
  }

/**
 * @summary Gets the transcription identified by the given ID.
 */
export const transcriptionsGet = <TData = AxiosResponse<Transcription>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/transcriptions/${id}`,options
    );
  }

/**
 * @summary Updates the mutable details of the transcription identified by its ID.
 */
export const transcriptionsUpdate = <TData = AxiosResponse<Transcription>>(
    id: string,
    transcriptionUpdate: TranscriptionUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/transcriptions/${id}`,
      transcriptionUpdate,options
    );
  }

/**
 * @summary Deletes the specified transcription task.
 */
export const transcriptionsDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/transcriptions/${id}`,options
    );
  }

/**
 * @summary Gets the files of the transcription identified by the given ID.
 */
export const transcriptionsListFiles = <TData = AxiosResponse<PaginatedFiles>>(
    id: string,
    params?: TranscriptionsListFilesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/transcriptions/${id}/files`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets one specific file (identified with fileId) from a transcription (identified with id).
 */
export const transcriptionsGetFile = <TData = AxiosResponse<File>>(
    id: string,
    fileId: string,
    params?: TranscriptionsGetFileParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/transcriptions/${id}/files/${fileId}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Gets the list of web hooks for the authenticated subscription.
 */
export const webHooksList = <TData = AxiosResponse<PaginatedWebHooks>>(
    params?: WebHooksListParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/webhooks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * If the property secret in the configuration is present and contains a non-empty string, it will be used to create a SHA256 hash of the payload with
the secret as HMAC key. This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.
            
When calling back into the registered URL, the request will contain a X-MicrosoftSpeechServices-Event header containing one of the registered event
types. There will be one request per registered event type.
            
After successfully registering the web hook, it will not be usable until a challenge/response is completed. To do this, a request with the event type
challenge will be made with a query parameter called validationToken. Respond to the challenge with a 200 OK containing the value of the validationToken
query parameter as the response body. When the challenge/response is successfully completed, the web hook will begin receiving events.
 * @summary Creates a new web hook.
 */
export const webHooksCreate = <TData = AxiosResponse<WebHook>>(
    webHook: NonReadonly<WebHook>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/webhooks`,
      webHook,options
    );
  }

/**
 * @summary Gets the web hook identified by the given ID.
 */
export const webHooksGet = <TData = AxiosResponse<WebHook>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/webhooks/${id}`,options
    );
  }

/**
 * If the property secret in the configuration is omitted or contains an empty string, future callbacks won't contain X-MicrosoftSpeechServices-Signature
headers. If the property contains a non-empty string, it will be used to create a SHA256 hash of the payload with the secret as HMAC key. This hash
will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL.
            
If the URL changes,  the web hook will stop receiving events until a
challenge/response is completed. To do this, a request with the event type challenge will be made with a query parameter called validationToken.
Respond to the challenge with a 200 OK containing the value of the validationToken query parameter as the response body. When the challenge/response
is successfully completed, the web hook will begin receiving events.
 * @summary Updates the web hook identified by the given ID.
 */
export const webHooksUpdate = <TData = AxiosResponse<WebHook>>(
    id: string,
    webHookUpdate: WebHookUpdate, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.patch(
      `/webhooks/${id}`,
      webHookUpdate,options
    );
  }

/**
 * @summary Deletes the web hook identified by the given ID.
 */
export const webHooksDelete = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/webhooks/${id}`,options
    );
  }

/**
 * The request body of the POST request sent to the registered web hook URL is of the same shape as in the GET request for a specific hook.
The Swagger Schema ID of the model is WebHookV3.
            
The request will contain a X-MicrosoftSpeechServices-Event header with the value ping. If the web hook was registered with
a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with
the secret as HMAC key. The hash is base64 encoded.
 * @summary Sends a ping event to the registered URL.
 */
export const webHooksPing = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/webhooks/${id}:ping`,undefined,options
    );
  }

/**
 * The payload will be generated from the last entity that would have invoked the web hook. If no entity is present for none of the registered event types,
the POST will respond with 204. If a test request can be made, it will respond with 200.
The request will contain a X-MicrosoftSpeechServices-Event header with the respective registered event type.
If the web hook was registered with a secret it will contain a X-MicrosoftSpeechServices-Signature header with an SHA256 hash of the payload with
the secret as HMAC key. The hash is base64 encoded.
 * @summary Sends a request for each registered event type to the registered URL.
 */
export const webHooksTest = <TData = AxiosResponse<void>>(
    id: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/webhooks/${id}:test`,undefined,options
    );
  }

export type DatasetsListSupportedLocalesResult = AxiosResponse<DatasetLocales>
export type DatasetsListResult = AxiosResponse<PaginatedDatasets>
export type DatasetsCreateResult = AxiosResponse<Dataset>
export type DatasetsGetResult = AxiosResponse<Dataset>
export type DatasetsUpdateResult = AxiosResponse<Dataset>
export type DatasetsDeleteResult = AxiosResponse<void>
export type DatasetsGetBlocksResult = AxiosResponse<UploadedBlocks>
export type DatasetsUploadBlockResult = AxiosResponse<void>
export type DatasetsUploadResult = AxiosResponse<Dataset>
export type DatasetsCommitBlocksResult = AxiosResponse<void>
export type DatasetsListFilesResult = AxiosResponse<PaginatedFiles>
export type DatasetsGetFileResult = AxiosResponse<File>
export type EndpointsListSupportedLocalesResult = AxiosResponse<string[]>
export type EndpointsListResult = AxiosResponse<PaginatedEndpoints>
export type EndpointsCreateResult = AxiosResponse<Endpoint>
export type EndpointsGetResult = AxiosResponse<Endpoint>
export type EndpointsDeleteResult = AxiosResponse<void>
export type EndpointsUpdateResult = AxiosResponse<Endpoint>
export type EndpointsListLogsResult = AxiosResponse<PaginatedFiles>
export type EndpointsDeleteLogsResult = AxiosResponse<void>
export type EndpointsGetLogResult = AxiosResponse<File>
export type EndpointsDeleteLogResult = AxiosResponse<void>
export type EndpointsListBaseModelLogsResult = AxiosResponse<PaginatedFiles>
export type EndpointsDeleteBaseModelLogsResult = AxiosResponse<void>
export type EndpointsGetBaseModelLogResult = AxiosResponse<File>
export type EndpointsDeleteBaseModelLogResult = AxiosResponse<void>
export type EvaluationsListSupportedLocalesResult = AxiosResponse<string[]>
export type EvaluationsListResult = AxiosResponse<PaginatedEvaluations>
export type EvaluationsCreateResult = AxiosResponse<Evaluation>
export type EvaluationsListFilesResult = AxiosResponse<PaginatedFiles>
export type EvaluationsGetFileResult = AxiosResponse<File>
export type EvaluationsGetResult = AxiosResponse<Evaluation>
export type EvaluationsUpdateResult = AxiosResponse<Evaluation>
export type EvaluationsDeleteResult = AxiosResponse<void>
export type ModelsListSupportedLocalesResult = AxiosResponse<string[]>
export type ModelsListCustomModelsResult = AxiosResponse<PaginatedCustomModels>
export type ModelsCreateResult = AxiosResponse<CustomModel>
export type ModelsListBaseModelsResult = AxiosResponse<PaginatedBaseModels>
export type ModelsGetCustomModelResult = AxiosResponse<CustomModel>
export type ModelsUpdateResult = AxiosResponse<CustomModel>
export type ModelsDeleteResult = AxiosResponse<void>
export type ModelsGetBaseModelResult = AxiosResponse<BaseModel>
export type ModelsCopyResult = AxiosResponse<Operation>
export type ModelsAuthorizeCopyResult = AxiosResponse<ModelCopyAuthorization>
export type ModelsGetCustomModelManifestResult = AxiosResponse<ModelManifest>
export type ModelsGetBaseModelManifestResult = AxiosResponse<ModelManifest>
export type ModelsListFilesResult = AxiosResponse<PaginatedFiles>
export type ModelsGetFileResult = AxiosResponse<File>
export type OperationsGetModelCopyResult = AxiosResponse<Operation>
export type ProjectsListSupportedLocalesResult = AxiosResponse<string[]>
export type ProjectsListResult = AxiosResponse<PaginatedProjects>
export type ProjectsCreateResult = AxiosResponse<Project>
export type ProjectsGetResult = AxiosResponse<Project>
export type ProjectsUpdateResult = AxiosResponse<Project>
export type ProjectsDeleteResult = AxiosResponse<void>
export type ProjectsListEvaluationsResult = AxiosResponse<PaginatedEvaluations>
export type ProjectsListDatasetsResult = AxiosResponse<PaginatedDatasets>
export type ProjectsListEndpointsResult = AxiosResponse<PaginatedEndpoints>
export type ProjectsListModelsResult = AxiosResponse<PaginatedCustomModels>
export type ProjectsListTranscriptionsResult = AxiosResponse<PaginatedTranscriptions>
export type TranscriptionsListSupportedLocalesResult = AxiosResponse<string[]>
export type TranscriptionsListResult = AxiosResponse<PaginatedTranscriptions>
export type TranscriptionsCreateResult = AxiosResponse<Transcription>
export type TranscriptionsGetResult = AxiosResponse<Transcription>
export type TranscriptionsUpdateResult = AxiosResponse<Transcription>
export type TranscriptionsDeleteResult = AxiosResponse<void>
export type TranscriptionsListFilesResult = AxiosResponse<PaginatedFiles>
export type TranscriptionsGetFileResult = AxiosResponse<File>
export type WebHooksListResult = AxiosResponse<PaginatedWebHooks>
export type WebHooksCreateResult = AxiosResponse<WebHook>
export type WebHooksGetResult = AxiosResponse<WebHook>
export type WebHooksUpdateResult = AxiosResponse<WebHook>
export type WebHooksDeleteResult = AxiosResponse<void>
export type WebHooksPingResult = AxiosResponse<void>
export type WebHooksTestResult = AxiosResponse<void>


export const getDatasetsListSupportedLocalesResponseMock = (): DatasetLocales => ({
        [faker.string.alphanumeric(5)]: faker.helpers.arrayElements(Object.values(DatasetKind))
      })

export const getDatasetsListResponseMock = (overrideResponse: Partial< PaginatedDatasets > = {}): PaginatedDatasets => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getDatasetsCreateResponseMock = (overrideResponse: Partial< Dataset > = {}): Dataset => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getDatasetsGetResponseMock = (overrideResponse: Partial< Dataset > = {}): Dataset => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getDatasetsUpdateResponseMock = (overrideResponse: Partial< Dataset > = {}): Dataset => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getDatasetsGetBlocksResponseMock = (overrideResponse: Partial< UploadedBlocks > = {}): UploadedBlocks => ({committedBlocks: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), uncommittedBlocks: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), ...overrideResponse})

export const getDatasetsUploadResponseMock = (overrideResponse: Partial< Dataset > = {}): Dataset => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getDatasetsListFilesResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getDatasetsGetFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEndpointsListSupportedLocalesResponseMock = (): string[] => (Array.from({length: faker.number.int({min: 1,max: 10})}, () => faker.word.sample()))

export const getEndpointsListResponseMock = (overrideResponse: Partial< PaginatedEndpoints > = {}): PaginatedEndpoints => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{restInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), restConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), restDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), logs: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{loggingEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEndpointsCreateResponseMock = (overrideResponse: Partial< Endpoint > = {}): Endpoint => ({links: faker.helpers.arrayElement([{restInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), restConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), restDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), logs: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{loggingEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getEndpointsGetResponseMock = (overrideResponse: Partial< Endpoint > = {}): Endpoint => ({links: faker.helpers.arrayElement([{restInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), restConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), restDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), logs: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{loggingEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getEndpointsUpdateResponseMock = (overrideResponse: Partial< Endpoint > = {}): Endpoint => ({links: faker.helpers.arrayElement([{restInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), restConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), restDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), logs: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{loggingEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getEndpointsListLogsResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEndpointsGetLogResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEndpointsListBaseModelLogsResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEndpointsGetBaseModelLogResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEvaluationsListSupportedLocalesResponseMock = (): string[] => (Array.from({length: faker.number.int({min: 1,max: 10})}, () => faker.word.sample()))

export const getEvaluationsListResponseMock = (overrideResponse: Partial< PaginatedEvaluations > = {}): PaginatedEvaluations => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({model1: {self: faker.internet.url()}, model2: {self: faker.internet.url()}, transcription1: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), transcription2: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: {self: faker.internet.url()}, links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors1: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), wordErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors2: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEvaluationsCreateResponseMock = (overrideResponse: Partial< Evaluation > = {}): Evaluation => ({model1: {self: faker.internet.url()}, model2: {self: faker.internet.url()}, transcription1: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), transcription2: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: {self: faker.internet.url()}, links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors1: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), wordErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors2: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getEvaluationsListFilesResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEvaluationsGetFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getEvaluationsGetResponseMock = (overrideResponse: Partial< Evaluation > = {}): Evaluation => ({model1: {self: faker.internet.url()}, model2: {self: faker.internet.url()}, transcription1: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), transcription2: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: {self: faker.internet.url()}, links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors1: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), wordErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors2: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getEvaluationsUpdateResponseMock = (overrideResponse: Partial< Evaluation > = {}): Evaluation => ({model1: {self: faker.internet.url()}, model2: {self: faker.internet.url()}, transcription1: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), transcription2: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: {self: faker.internet.url()}, links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors1: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), wordErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors2: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), ...overrideResponse})

export const getModelsListSupportedLocalesResponseMock = (): string[] => (Array.from({length: faker.number.int({min: 1,max: 10})}, () => faker.word.sample()))

export const getModelsListCustomModelsResponseMock = (overrideResponse: Partial< PaginatedCustomModels > = {}): PaginatedCustomModels => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{copy: faker.helpers.arrayElement([faker.internet.url(), undefined]), files: faker.helpers.arrayElement([faker.internet.url(), undefined]), manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{customModelWeightPercent: faker.helpers.arrayElement([faker.number.int({min: 1, max: 100}), undefined]), deprecationDates: faker.helpers.arrayElement([{transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), baseModel: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), datasets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({self: faker.internet.url()})), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getModelsCreateResponseMock = (): CustomModel => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{copy: faker.helpers.arrayElement([faker.internet.url(), undefined]), files: faker.helpers.arrayElement([faker.internet.url(), undefined]), manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{customModelWeightPercent: faker.helpers.arrayElement([faker.number.int({min: 1, max: 100}), undefined]), deprecationDates: faker.helpers.arrayElement([{transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), baseModel: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), datasets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({self: faker.internet.url()})), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})

export const getModelsListBaseModelsResponseMock = (overrideResponse: Partial< PaginatedBaseModels > = {}): PaginatedBaseModels => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{deprecationDates: faker.helpers.arrayElement([{adaptationDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, supportsAdaptationsWith: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(DatasetKind)), undefined])}, undefined]), chargeForAdaptation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getModelsGetCustomModelResponseMock = (): CustomModel => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{copy: faker.helpers.arrayElement([faker.internet.url(), undefined]), files: faker.helpers.arrayElement([faker.internet.url(), undefined]), manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{customModelWeightPercent: faker.helpers.arrayElement([faker.number.int({min: 1, max: 100}), undefined]), deprecationDates: faker.helpers.arrayElement([{transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), baseModel: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), datasets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({self: faker.internet.url()})), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})

export const getModelsUpdateResponseMock = (): CustomModel => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{copy: faker.helpers.arrayElement([faker.internet.url(), undefined]), files: faker.helpers.arrayElement([faker.internet.url(), undefined]), manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{customModelWeightPercent: faker.helpers.arrayElement([faker.number.int({min: 1, max: 100}), undefined]), deprecationDates: faker.helpers.arrayElement([{transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), baseModel: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), datasets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({self: faker.internet.url()})), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})

export const getModelsGetBaseModelResponseMock = (): BaseModel => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{deprecationDates: faker.helpers.arrayElement([{adaptationDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, supportsAdaptationsWith: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(DatasetKind)), undefined])}, undefined]), chargeForAdaptation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, undefined])})

export const getModelsCopyResponseMock = (overrideResponse: Partial< Operation > = {}): Operation => ({id: faker.string.uuid(), result: faker.helpers.arrayElement([{link: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getModelsAuthorizeCopyResponseMock = (overrideResponse: Partial< ModelCopyAuthorization > = {}): ModelCopyAuthorization => ({targetResourceRegion: faker.string.alpha(20), targetResourceId: faker.string.alpha(20), targetResourceEndpoint: faker.string.alpha(20), sourceResourceId: faker.string.alpha(20), expirationDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.alpha(20), ...overrideResponse})

export const getModelsGetCustomModelManifestResponseMock = (overrideResponse: Partial< ModelManifest > = {}): ModelManifest => ({model: {self: faker.internet.url()}, modelFiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), properties: {
        [faker.string.alphanumeric(5)]: {}
      }, ...overrideResponse})

export const getModelsGetBaseModelManifestResponseMock = (overrideResponse: Partial< ModelManifest > = {}): ModelManifest => ({model: {self: faker.internet.url()}, modelFiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), properties: {
        [faker.string.alphanumeric(5)]: {}
      }, ...overrideResponse})

export const getModelsListFilesResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getModelsGetFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getOperationsGetModelCopyResponseMock = (overrideResponse: Partial< Operation > = {}): Operation => ({id: faker.string.uuid(), result: faker.helpers.arrayElement([{link: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getProjectsListSupportedLocalesResponseMock = (): string[] => (Array.from({length: faker.number.int({min: 1,max: 10})}, () => faker.word.sample()))

export const getProjectsListResponseMock = (overrideResponse: Partial< PaginatedProjects > = {}): PaginatedProjects => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{evaluations: faker.helpers.arrayElement([faker.internet.url(), undefined]), datasets: faker.helpers.arrayElement([faker.internet.url(), undefined]), models: faker.helpers.arrayElement([faker.internet.url(), undefined]), endpoints: faker.helpers.arrayElement([faker.internet.url(), undefined]), transcriptions: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{datasetCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), evaluationCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), modelCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), transcriptionCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), endpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getProjectsCreateResponseMock = (overrideResponse: Partial< Project > = {}): Project => ({links: faker.helpers.arrayElement([{evaluations: faker.helpers.arrayElement([faker.internet.url(), undefined]), datasets: faker.helpers.arrayElement([faker.internet.url(), undefined]), models: faker.helpers.arrayElement([faker.internet.url(), undefined]), endpoints: faker.helpers.arrayElement([faker.internet.url(), undefined]), transcriptions: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{datasetCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), evaluationCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), modelCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), transcriptionCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), endpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getProjectsGetResponseMock = (overrideResponse: Partial< Project > = {}): Project => ({links: faker.helpers.arrayElement([{evaluations: faker.helpers.arrayElement([faker.internet.url(), undefined]), datasets: faker.helpers.arrayElement([faker.internet.url(), undefined]), models: faker.helpers.arrayElement([faker.internet.url(), undefined]), endpoints: faker.helpers.arrayElement([faker.internet.url(), undefined]), transcriptions: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{datasetCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), evaluationCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), modelCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), transcriptionCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), endpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getProjectsUpdateResponseMock = (overrideResponse: Partial< Project > = {}): Project => ({links: faker.helpers.arrayElement([{evaluations: faker.helpers.arrayElement([faker.internet.url(), undefined]), datasets: faker.helpers.arrayElement([faker.internet.url(), undefined]), models: faker.helpers.arrayElement([faker.internet.url(), undefined]), endpoints: faker.helpers.arrayElement([faker.internet.url(), undefined]), transcriptions: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{datasetCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), evaluationCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), modelCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), transcriptionCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), endpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getProjectsListEvaluationsResponseMock = (overrideResponse: Partial< PaginatedEvaluations > = {}): PaginatedEvaluations => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({model1: {self: faker.internet.url()}, model2: {self: faker.internet.url()}, transcription1: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), transcription2: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: {self: faker.internet.url()}, links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate1: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount1: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors1: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), wordErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), tokenErrorRate2: faker.helpers.arrayElement([faker.number.float(), undefined]), sentenceCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctWordCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), wordInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correctTokenCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenSubstitutionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenDeletionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenInsertionCount2: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), tokenErrors2: faker.helpers.arrayElement([{punctuation: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), capitalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), inverseTextNormalization: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), lexical: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined]), others: faker.helpers.arrayElement([{numberOfEdits: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), percentageOfAllEdits: faker.helpers.arrayElement([faker.number.float(), undefined])}, undefined])}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getProjectsListDatasetsResponseMock = (overrideResponse: Partial< PaginatedDatasets > = {}): PaginatedDatasets => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined]), commitBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), listBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined]), uploadBlocks: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{textNormalizationKind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(TextNormalizationKind)), undefined]), acceptedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), rejectedLineCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), kind: faker.helpers.arrayElement(Object.values(DatasetKind)), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), locale: faker.string.alpha(20), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getProjectsListEndpointsResponseMock = (overrideResponse: Partial< PaginatedEndpoints > = {}): PaginatedEndpoints => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{restInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), restConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), restDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketInteractive: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketConversation: faker.helpers.arrayElement([faker.internet.url(), undefined]), webSocketDictation: faker.helpers.arrayElement([faker.internet.url(), undefined]), logs: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{loggingEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), locale: faker.string.alpha(20), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getProjectsListModelsResponseMock = (overrideResponse: Partial< PaginatedCustomModels > = {}): PaginatedCustomModels => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{...{self: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])},}, links: faker.helpers.arrayElement([{copy: faker.helpers.arrayElement([faker.internet.url(), undefined]), files: faker.helpers.arrayElement([faker.internet.url(), undefined]), manifest: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{customModelWeightPercent: faker.helpers.arrayElement([faker.number.int({min: 1, max: 100}), undefined]), deprecationDates: faker.helpers.arrayElement([{transcriptionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])}, undefined]), features: faker.helpers.arrayElement([{...{supportsTranscriptions: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsEndpoints: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportsTranscriptionsOnSpeechContainers: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), supportedOutputFormats: faker.helpers.arrayElement([faker.helpers.arrayElements(Object.values(OutputFormatType)), undefined])},}, undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined])}, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), text: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), baseModel: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), datasets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({self: faker.internet.url()})), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getProjectsListTranscriptionsResponseMock = (overrideResponse: Partial< PaginatedTranscriptions > = {}): PaginatedTranscriptions => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), displayFormWordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), channels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.number.int({min: undefined, max: undefined}))), undefined]), destinationContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), punctuationMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(PunctuationMode)), undefined]), profanityFilterMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ProfanityFilterMode)), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), diarizationEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), diarization: faker.helpers.arrayElement([{speakers: {minCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), maxCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}}, undefined]), languageIdentification: faker.helpers.arrayElement([{mode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LanguageIdentificationMode)), undefined]), candidateLocales: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), speechModelMapping: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {self: faker.internet.url()}
      }, undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), contentUrls: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.internet.url())), undefined]), contentContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getTranscriptionsListSupportedLocalesResponseMock = (): string[] => (Array.from({length: faker.number.int({min: 1,max: 10})}, () => faker.word.sample()))

export const getTranscriptionsListResponseMock = (overrideResponse: Partial< PaginatedTranscriptions > = {}): PaginatedTranscriptions => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), displayFormWordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), channels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.number.int({min: undefined, max: undefined}))), undefined]), destinationContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), punctuationMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(PunctuationMode)), undefined]), profanityFilterMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ProfanityFilterMode)), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), diarizationEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), diarization: faker.helpers.arrayElement([{speakers: {minCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), maxCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}}, undefined]), languageIdentification: faker.helpers.arrayElement([{mode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LanguageIdentificationMode)), undefined]), candidateLocales: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), speechModelMapping: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {self: faker.internet.url()}
      }, undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), contentUrls: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.internet.url())), undefined]), contentContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getTranscriptionsCreateResponseMock = (overrideResponse: Partial< Transcription > = {}): Transcription => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), displayFormWordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), channels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.number.int({min: undefined, max: undefined}))), undefined]), destinationContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), punctuationMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(PunctuationMode)), undefined]), profanityFilterMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ProfanityFilterMode)), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), diarizationEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), diarization: faker.helpers.arrayElement([{speakers: {minCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), maxCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}}, undefined]), languageIdentification: faker.helpers.arrayElement([{mode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LanguageIdentificationMode)), undefined]), candidateLocales: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), speechModelMapping: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {self: faker.internet.url()}
      }, undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), contentUrls: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.internet.url())), undefined]), contentContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getTranscriptionsGetResponseMock = (overrideResponse: Partial< Transcription > = {}): Transcription => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), displayFormWordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), channels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.number.int({min: undefined, max: undefined}))), undefined]), destinationContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), punctuationMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(PunctuationMode)), undefined]), profanityFilterMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ProfanityFilterMode)), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), diarizationEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), diarization: faker.helpers.arrayElement([{speakers: {minCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), maxCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}}, undefined]), languageIdentification: faker.helpers.arrayElement([{mode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LanguageIdentificationMode)), undefined]), candidateLocales: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), speechModelMapping: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {self: faker.internet.url()}
      }, undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), contentUrls: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.internet.url())), undefined]), contentContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getTranscriptionsUpdateResponseMock = (overrideResponse: Partial< Transcription > = {}): Transcription => ({links: faker.helpers.arrayElement([{files: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{wordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), displayFormWordLevelTimestampsEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), channels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.number.int({min: undefined, max: undefined}))), undefined]), destinationContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), punctuationMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(PunctuationMode)), undefined]), profanityFilterMode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ProfanityFilterMode)), undefined]), timeToLive: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), email: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), diarizationEnabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), diarization: faker.helpers.arrayElement([{speakers: {minCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), maxCount: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}}, undefined]), languageIdentification: faker.helpers.arrayElement([{mode: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LanguageIdentificationMode)), undefined]), candidateLocales: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), speechModelMapping: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {self: faker.internet.url()}
      }, undefined])}, undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), model: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), dataset: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), contentUrls: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.internet.url())), undefined]), contentContainerUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), locale: faker.string.alpha(20), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), project: faker.helpers.arrayElement([{self: faker.internet.url()}, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getTranscriptionsListFilesResponseMock = (overrideResponse: Partial< PaginatedFiles > = {}): PaginatedFiles => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getTranscriptionsGetFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({kind: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(FileKind)), undefined]), links: faker.helpers.arrayElement([{contentUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), properties: faker.helpers.arrayElement([{size: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), duration: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getWebHooksListResponseMock = (overrideResponse: Partial< PaginatedWebHooks > = {}): PaginatedWebHooks => ({values: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({webUrl: faker.internet.url(), links: faker.helpers.arrayElement([{ping: faker.helpers.arrayElement([faker.internet.url(), undefined]), test: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), apiVersion: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), secret: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), events: {datasetCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ping: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), challenge: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined])})), undefined]), '@nextLink': faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getWebHooksCreateResponseMock = (overrideResponse: Partial< WebHook > = {}): WebHook => ({webUrl: faker.internet.url(), links: faker.helpers.arrayElement([{ping: faker.helpers.arrayElement([faker.internet.url(), undefined]), test: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), apiVersion: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), secret: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), events: {datasetCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ping: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), challenge: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), ...overrideResponse})

export const getWebHooksGetResponseMock = (overrideResponse: Partial< WebHook > = {}): WebHook => ({webUrl: faker.internet.url(), links: faker.helpers.arrayElement([{ping: faker.helpers.arrayElement([faker.internet.url(), undefined]), test: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), apiVersion: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), secret: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), events: {datasetCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ping: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), challenge: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), ...overrideResponse})

export const getWebHooksUpdateResponseMock = (overrideResponse: Partial< WebHook > = {}): WebHook => ({webUrl: faker.internet.url(), links: faker.helpers.arrayElement([{ping: faker.helpers.arrayElement([faker.internet.url(), undefined]), test: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), properties: faker.helpers.arrayElement([{error: faker.helpers.arrayElement([{code: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), message: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), apiVersion: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), secret: faker.helpers.arrayElement([faker.string.alpha(20), undefined])}, undefined]), self: faker.helpers.arrayElement([faker.internet.url(), undefined]), displayName: faker.string.alpha(20), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), events: {datasetCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), datasetDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), modelDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), evaluationDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), transcriptionDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCreation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointProcessing: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointCompletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), endpointDeletion: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ping: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), challenge: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, createdDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), lastActionDateTime: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(Status)), undefined]), customProperties: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.string.alpha(20)
      }, undefined]), ...overrideResponse})


export const getDatasetsListSupportedLocalesMockHandler = (overrideResponse?: DatasetLocales | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DatasetLocales> | DatasetLocales)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsListMockHandler = (overrideResponse?: PaginatedDatasets | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedDatasets> | PaginatedDatasets)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsCreateMockHandler = (overrideResponse?: Dataset | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Dataset> | Dataset)) => {
  return http.post('https://api.cognitive.microsoft.com/datasets', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsGetMockHandler = (overrideResponse?: Dataset | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Dataset> | Dataset)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsUpdateMockHandler = (overrideResponse?: Dataset | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Dataset> | Dataset)) => {
  return http.patch('https://api.cognitive.microsoft.com/datasets/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/datasets/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getDatasetsGetBlocksMockHandler = (overrideResponse?: UploadedBlocks | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UploadedBlocks> | UploadedBlocks)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets/:id/blocks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsGetBlocksResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsUploadBlockMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<void> | void)) => {
  return http.put('https://api.cognitive.microsoft.com/datasets/:id/blocks', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 201,
        
      })
  })
}

export const getDatasetsUploadMockHandler = (overrideResponse?: Dataset | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Dataset> | Dataset)) => {
  return http.post('https://api.cognitive.microsoft.com/datasets/upload', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsUploadResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsCommitBlocksMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('https://api.cognitive.microsoft.com/datasets/:id/blocks:commit', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getDatasetsListFilesMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets/:id/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsListFilesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDatasetsGetFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/datasets/:id/files/:fileId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDatasetsGetFileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsListSupportedLocalesMockHandler = (overrideResponse?: string[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[]> | string[])) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsListMockHandler = (overrideResponse?: PaginatedEndpoints | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedEndpoints> | PaginatedEndpoints)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsCreateMockHandler = (overrideResponse?: Endpoint | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Endpoint> | Endpoint)) => {
  return http.post('https://api.cognitive.microsoft.com/endpoints', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsGetMockHandler = (overrideResponse?: Endpoint | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Endpoint> | Endpoint)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/endpoints/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getEndpointsUpdateMockHandler = (overrideResponse?: Endpoint | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Endpoint> | Endpoint)) => {
  return http.patch('https://api.cognitive.microsoft.com/endpoints/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsListLogsMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/:id/files/logs', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsListLogsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsDeleteLogsMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/endpoints/:id/files/logs', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 202,
        
      })
  })
}

export const getEndpointsGetLogMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/:id/files/logs/:logId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsGetLogResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsDeleteLogMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/endpoints/:id/files/logs/:logId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getEndpointsListBaseModelLogsMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/base/:locale/files/logs', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsListBaseModelLogsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsDeleteBaseModelLogsMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/endpoints/base/:locale/files/logs', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 202,
        
      })
  })
}

export const getEndpointsGetBaseModelLogMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/endpoints/base/:locale/files/logs/:logId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEndpointsGetBaseModelLogResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEndpointsDeleteBaseModelLogMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/endpoints/base/:locale/files/logs/:logId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getEvaluationsListSupportedLocalesMockHandler = (overrideResponse?: string[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[]> | string[])) => {
  return http.get('https://api.cognitive.microsoft.com/evaluations/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsListMockHandler = (overrideResponse?: PaginatedEvaluations | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedEvaluations> | PaginatedEvaluations)) => {
  return http.get('https://api.cognitive.microsoft.com/evaluations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsCreateMockHandler = (overrideResponse?: Evaluation | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Evaluation> | Evaluation)) => {
  return http.post('https://api.cognitive.microsoft.com/evaluations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsListFilesMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/evaluations/:id/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsListFilesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsGetFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/evaluations/:id/files/:fileId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsGetFileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsGetMockHandler = (overrideResponse?: Evaluation | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Evaluation> | Evaluation)) => {
  return http.get('https://api.cognitive.microsoft.com/evaluations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsUpdateMockHandler = (overrideResponse?: Evaluation | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Evaluation> | Evaluation)) => {
  return http.patch('https://api.cognitive.microsoft.com/evaluations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getEvaluationsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getEvaluationsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/evaluations/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getModelsListSupportedLocalesMockHandler = (overrideResponse?: string[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[]> | string[])) => {
  return http.get('https://api.cognitive.microsoft.com/models/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsListCustomModelsMockHandler = (overrideResponse?: PaginatedCustomModels | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCustomModels> | PaginatedCustomModels)) => {
  return http.get('https://api.cognitive.microsoft.com/models', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsListCustomModelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsCreateMockHandler = (overrideResponse?: CustomModel | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CustomModel> | CustomModel)) => {
  return http.post('https://api.cognitive.microsoft.com/models', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsListBaseModelsMockHandler = (overrideResponse?: PaginatedBaseModels | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedBaseModels> | PaginatedBaseModels)) => {
  return http.get('https://api.cognitive.microsoft.com/models/base', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsListBaseModelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsGetCustomModelMockHandler = (overrideResponse?: CustomModel | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CustomModel> | CustomModel)) => {
  return http.get('https://api.cognitive.microsoft.com/models/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsGetCustomModelResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsUpdateMockHandler = (overrideResponse?: CustomModel | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<CustomModel> | CustomModel)) => {
  return http.patch('https://api.cognitive.microsoft.com/models/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/models/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getModelsGetBaseModelMockHandler = (overrideResponse?: BaseModel | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<BaseModel> | BaseModel)) => {
  return http.get('https://api.cognitive.microsoft.com/models/base/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsGetBaseModelResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsCopyMockHandler = (overrideResponse?: Operation | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Operation> | Operation)) => {
  return http.post('https://api.cognitive.microsoft.com/models/:id:copy', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsCopyResponseMock()),
      { status: 202,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsAuthorizeCopyMockHandler = (overrideResponse?: ModelCopyAuthorization | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ModelCopyAuthorization> | ModelCopyAuthorization)) => {
  return http.post('https://api.cognitive.microsoft.com/models:authorizecopy', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsAuthorizeCopyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsGetCustomModelManifestMockHandler = (overrideResponse?: ModelManifest | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ModelManifest> | ModelManifest)) => {
  return http.get('https://api.cognitive.microsoft.com/models/:id/manifest', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsGetCustomModelManifestResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsGetBaseModelManifestMockHandler = (overrideResponse?: ModelManifest | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ModelManifest> | ModelManifest)) => {
  return http.get('https://api.cognitive.microsoft.com/models/base/:id/manifest', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsGetBaseModelManifestResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsListFilesMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/models/:id/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsListFilesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getModelsGetFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/models/:id/files/:fileId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getModelsGetFileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getOperationsGetModelCopyMockHandler = (overrideResponse?: Operation | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Operation> | Operation)) => {
  return http.get('https://api.cognitive.microsoft.com/operations/models/copy/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getOperationsGetModelCopyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListSupportedLocalesMockHandler = (overrideResponse?: string[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[]> | string[])) => {
  return http.get('https://api.cognitive.microsoft.com/projects/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListMockHandler = (overrideResponse?: PaginatedProjects | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedProjects> | PaginatedProjects)) => {
  return http.get('https://api.cognitive.microsoft.com/projects', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsCreateMockHandler = (overrideResponse?: Project | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Project> | Project)) => {
  return http.post('https://api.cognitive.microsoft.com/projects', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsGetMockHandler = (overrideResponse?: Project | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Project> | Project)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsUpdateMockHandler = (overrideResponse?: Project | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Project> | Project)) => {
  return http.patch('https://api.cognitive.microsoft.com/projects/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/projects/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getProjectsListEvaluationsMockHandler = (overrideResponse?: PaginatedEvaluations | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedEvaluations> | PaginatedEvaluations)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id/evaluations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListEvaluationsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListDatasetsMockHandler = (overrideResponse?: PaginatedDatasets | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedDatasets> | PaginatedDatasets)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id/datasets', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListDatasetsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListEndpointsMockHandler = (overrideResponse?: PaginatedEndpoints | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedEndpoints> | PaginatedEndpoints)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id/endpoints', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListEndpointsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListModelsMockHandler = (overrideResponse?: PaginatedCustomModels | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCustomModels> | PaginatedCustomModels)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id/models', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListModelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getProjectsListTranscriptionsMockHandler = (overrideResponse?: PaginatedTranscriptions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedTranscriptions> | PaginatedTranscriptions)) => {
  return http.get('https://api.cognitive.microsoft.com/projects/:id/transcriptions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getProjectsListTranscriptionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsListSupportedLocalesMockHandler = (overrideResponse?: string[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string[]> | string[])) => {
  return http.get('https://api.cognitive.microsoft.com/transcriptions/locales', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsListSupportedLocalesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsListMockHandler = (overrideResponse?: PaginatedTranscriptions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedTranscriptions> | PaginatedTranscriptions)) => {
  return http.get('https://api.cognitive.microsoft.com/transcriptions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsCreateMockHandler = (overrideResponse?: Transcription | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Transcription> | Transcription)) => {
  return http.post('https://api.cognitive.microsoft.com/transcriptions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsGetMockHandler = (overrideResponse?: Transcription | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Transcription> | Transcription)) => {
  return http.get('https://api.cognitive.microsoft.com/transcriptions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsUpdateMockHandler = (overrideResponse?: Transcription | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Transcription> | Transcription)) => {
  return http.patch('https://api.cognitive.microsoft.com/transcriptions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/transcriptions/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getTranscriptionsListFilesMockHandler = (overrideResponse?: PaginatedFiles | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedFiles> | PaginatedFiles)) => {
  return http.get('https://api.cognitive.microsoft.com/transcriptions/:id/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsListFilesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranscriptionsGetFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.cognitive.microsoft.com/transcriptions/:id/files/:fileId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getTranscriptionsGetFileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getWebHooksListMockHandler = (overrideResponse?: PaginatedWebHooks | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedWebHooks> | PaginatedWebHooks)) => {
  return http.get('https://api.cognitive.microsoft.com/webhooks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getWebHooksListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getWebHooksCreateMockHandler = (overrideResponse?: WebHook | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<WebHook> | WebHook)) => {
  return http.post('https://api.cognitive.microsoft.com/webhooks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getWebHooksCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getWebHooksGetMockHandler = (overrideResponse?: WebHook | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WebHook> | WebHook)) => {
  return http.get('https://api.cognitive.microsoft.com/webhooks/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getWebHooksGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getWebHooksUpdateMockHandler = (overrideResponse?: WebHook | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<WebHook> | WebHook)) => {
  return http.patch('https://api.cognitive.microsoft.com/webhooks/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getWebHooksUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getWebHooksDeleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.cognitive.microsoft.com/webhooks/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getWebHooksPingMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('https://api.cognitive.microsoft.com/webhooks/:id:ping', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 202,
        
      })
  })
}

export const getWebHooksTestMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('https://api.cognitive.microsoft.com/webhooks/:id:test', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 202,
        
      })
  })
}
export const getSpeechServicesAPIVersion32Mock = () => [
  getDatasetsListSupportedLocalesMockHandler(),
  getDatasetsListMockHandler(),
  getDatasetsCreateMockHandler(),
  getDatasetsGetMockHandler(),
  getDatasetsUpdateMockHandler(),
  getDatasetsDeleteMockHandler(),
  getDatasetsGetBlocksMockHandler(),
  getDatasetsUploadBlockMockHandler(),
  getDatasetsUploadMockHandler(),
  getDatasetsCommitBlocksMockHandler(),
  getDatasetsListFilesMockHandler(),
  getDatasetsGetFileMockHandler(),
  getEndpointsListSupportedLocalesMockHandler(),
  getEndpointsListMockHandler(),
  getEndpointsCreateMockHandler(),
  getEndpointsGetMockHandler(),
  getEndpointsDeleteMockHandler(),
  getEndpointsUpdateMockHandler(),
  getEndpointsListLogsMockHandler(),
  getEndpointsDeleteLogsMockHandler(),
  getEndpointsGetLogMockHandler(),
  getEndpointsDeleteLogMockHandler(),
  getEndpointsListBaseModelLogsMockHandler(),
  getEndpointsDeleteBaseModelLogsMockHandler(),
  getEndpointsGetBaseModelLogMockHandler(),
  getEndpointsDeleteBaseModelLogMockHandler(),
  getEvaluationsListSupportedLocalesMockHandler(),
  getEvaluationsListMockHandler(),
  getEvaluationsCreateMockHandler(),
  getEvaluationsListFilesMockHandler(),
  getEvaluationsGetFileMockHandler(),
  getEvaluationsGetMockHandler(),
  getEvaluationsUpdateMockHandler(),
  getEvaluationsDeleteMockHandler(),
  getModelsListSupportedLocalesMockHandler(),
  getModelsListCustomModelsMockHandler(),
  getModelsCreateMockHandler(),
  getModelsListBaseModelsMockHandler(),
  getModelsGetCustomModelMockHandler(),
  getModelsUpdateMockHandler(),
  getModelsDeleteMockHandler(),
  getModelsGetBaseModelMockHandler(),
  getModelsCopyMockHandler(),
  getModelsAuthorizeCopyMockHandler(),
  getModelsGetCustomModelManifestMockHandler(),
  getModelsGetBaseModelManifestMockHandler(),
  getModelsListFilesMockHandler(),
  getModelsGetFileMockHandler(),
  getOperationsGetModelCopyMockHandler(),
  getProjectsListSupportedLocalesMockHandler(),
  getProjectsListMockHandler(),
  getProjectsCreateMockHandler(),
  getProjectsGetMockHandler(),
  getProjectsUpdateMockHandler(),
  getProjectsDeleteMockHandler(),
  getProjectsListEvaluationsMockHandler(),
  getProjectsListDatasetsMockHandler(),
  getProjectsListEndpointsMockHandler(),
  getProjectsListModelsMockHandler(),
  getProjectsListTranscriptionsMockHandler(),
  getTranscriptionsListSupportedLocalesMockHandler(),
  getTranscriptionsListMockHandler(),
  getTranscriptionsCreateMockHandler(),
  getTranscriptionsGetMockHandler(),
  getTranscriptionsUpdateMockHandler(),
  getTranscriptionsDeleteMockHandler(),
  getTranscriptionsListFilesMockHandler(),
  getTranscriptionsGetFileMockHandler(),
  getWebHooksListMockHandler(),
  getWebHooksCreateMockHandler(),
  getWebHooksGetMockHandler(),
  getWebHooksUpdateMockHandler(),
  getWebHooksDeleteMockHandler(),
  getWebHooksPingMockHandler(),
  getWebHooksTestMockHandler()]
