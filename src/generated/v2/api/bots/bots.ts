/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Meeting BaaS API
 * API for managing meeting bots, calendar integrations, and webhooks
 * OpenAPI spec version: 2.0.0
 */

import type { AxiosRequestConfig, AxiosResponse } from "axios"
import axios from "axios"

import type {
  BatchCreateBotResponse,
  BatchCreateBotsRequestBodyInput,
  BatchCreateScheduledBotResponse,
  BatchCreateScheduledBotsRequestBodyInput,
  CreateBotRequestBodyInput,
  CreateBotResponse,
  CreateScheduledBotRequestBodyInput,
  CreateScheduledBotResponse,
  DeleteBotDataParams,
  DeleteBotDataResponse,
  DeleteScheduledBotResponse,
  GetBotDetailsResponse,
  GetBotScreenshotsParams,
  GetBotScreenshotsResponse,
  GetBotStatusResponse,
  GetScheduledBotResponse,
  LeaveBotResponse,
  ListBotsParams,
  ListBotsResponse,
  ListScheduledBotsParams,
  ListScheduledBotsResponse,
  ResendFinalWebhookResponse,
  RetryCallbackRequestBodyInput,
  RetryCallbackResponse,
  UpdateScheduledBotRequestBodyInput,
  UpdateScheduledBotResponse
} from "../../schema"

/**
 * Create a bot to join a meeting immediately.
    
    The bot will automatically join the meeting, request recording permissions, and start recording once accepted. You can provide a bot-specific callback URL to receive bot.completed and bot.failed events for this bot (in addition to your account's webhooks). The bot will send webhook events for status changes, completion, and failures.
    
    Returns a `bot_id` (UUID) that you can use to track status, retrieve meeting data, and manage the bot. The bot will be queued immediately and join the meeting as soon as possible (may take up to 2 minutes depending on availability of bot slots).
    
    **Token Reservation:** 0.5 tokens are reserved immediately upon creation. These tokens will be consumed based on the bot's duration and outcome. If the bot fails due to user-responsible errors (`BOT_NOT_ACCEPTED`, `TIMEOUT_WAITING_TO_START`), recording tokens will be charged based on the time spent in the waiting room.
    
    **Deduplication:** By default, multiple bots can join the same meeting URL. Set `allow_multiple_bots: false` to prevent duplicate bots within 5 minutes. The deduplication check expires after 5 minutes, allowing a new bot to join the same meeting URL after that period.
    
    **Rate Limits:** Subject to your API key's rate limits and your team's daily bot cap. The daily bot cap is checked before token reservation. If the cap is reached, the request will fail with a 429 status code.
    
    **Error Scenarios:**
    - `402 Payment Required`: Insufficient tokens available
    - `409 Conflict`: Bot already exists for the same meeting URL (when `allow_multiple_bots` is false)
    - `429 Too Many Requests`: Daily bot cap reached or rate limit exceeded
 * @summary Create a bot
 */
export const createBot = <TData = AxiosResponse<CreateBotResponse>>(
  createBotRequestBodyInput: CreateBotRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post("/v2/bots", createBotRequestBodyInput, options)
}
/**
 * List all bots for your team with pagination support.
    
    Filter by status (queued, joining, in_call_recording, transcribing, completed, failed), meeting platform (zoom, meet, teams), and date range. Results are ordered by creation date (newest first). Use cursor-based pagination for efficient navigation through large result sets.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The response includes a `next_cursor` if more results are available. The `limit` parameter controls how many results are returned per page (default: 20, max: 100).
    
    **Filtering:** 
    - `status`: Filter by bot status (comma-separated for multiple statuses)
    - `platform`: Filter by meeting platform (zoom, meet, teams)
    - `created_after`: ISO 8601 timestamp - only return bots created after this time
    - `created_before`: ISO 8601 timestamp - only return bots created before this time
    
    **Date Range:** The `created_after` and `created_before` filters use ISO 8601 timestamps. Results are limited to bots created within the last 90 days by default.
    
    Returns a paginated list of bots with metadata including bot ID, status, meeting platform, creation time, and basic configuration.
 * @summary List bots
 */
export const listBots = <TData = AxiosResponse<ListBotsResponse>>(
  params: ListBotsParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get("/v2/bots", {
    ...options,
    params: { ...params, ...options?.params }
  })
}
/**
 * Create multiple bots in a single request with partial success support.
    
    Processes each bot creation request sequentially (index 0, 1, 2...). Each item is validated and processed independently. If some bots fail to create, the request still returns 201 with a `data` array containing successful creations and an `errors` array containing failures. Each error includes the `index` of the failed item in the original request array.
    
    **Processing Order:** Items are processed in the order they appear in the request array. Each item goes through the same validation and checks as a single bot creation: platform detection, BYOK transcription check, daily bot cap check, token availability check, and deduplication lock acquisition.
    
    **Partial Success:** The response always has `success: true`, even if all items fail. Check the `errors` array to identify failed items. The `data` array contains successfully created bots with their `bot_id` and preserved `extra` metadata. The `errors` array contains failed items with `index`, `code`, `message`, `details`, and preserved `extra` metadata.
    
    **Daily Bot Cap:** The daily bot cap is checked per item, not per batch. If the cap is reached mid-batch, subsequent items will fail with `DAILY_BOT_CAP_REACHED` error. The cap is based on bots created in the last 24 hours.
    
    **Token Reservation:** Tokens are reserved individually for each successful bot creation (0.5 tokens per bot). If token availability becomes insufficient mid-batch, subsequent items will fail with `INSUFFICIENT_TOKENS`.
    
    **Error Index Mapping:** Each error includes an `index` field (0-based) that corresponds to the item's position in the request array. Use this to correlate errors with your original request. Validation errors include detailed validation issues in the `details` field.
    
    **Error Isolation:** Each bot creation is processed independently. If one bot creation fails, it does not affect other bots in the batch. Failed items are included in the `errors` array while successful items are in the `data` array.
    
    Returns 201 with partial success response. All items may succeed, all may fail, or any combination. Always check both `data` and `errors` arrays.
 * @summary Create multiple bots
 */
export const batchCreateBots = <TData = AxiosResponse<BatchCreateBotResponse>>(
  batchCreateBotsRequestBodyInput: BatchCreateBotsRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post("/v2/bots/batch", batchCreateBotsRequestBodyInput, options)
}
/**
 * Get comprehensive information about a specific bot.
    
    Returns detailed bot information including current status, configuration, meeting metadata, and presigned URLs for all artifacts (video, audio, transcription, diarization). Artifact URLs are valid for 4 hours from the time of request. Returns `null` for artifacts if the bot's data has been deleted.
    
    **Artifact URLs:** All artifact URLs (video, audio, transcription, diarization) are presigned URLs that expire after 4 hours. If the bot's data has been deleted (via the delete-data endpoint or data retention policy), these fields will be `null`. The `artifacts_deleted` field indicates whether the bot's data has been permanently removed.
    
    **Status Information:** The response includes the bot's current status (`status` field) and timestamps for key events (joined_at, exited_at, created_at). If the bot failed, the response includes `error_code` and `error_message` fields with details about what went wrong.
    
    **Meeting Metadata:** Includes meeting platform, meeting URL, participants list, speakers list, and meeting duration (if available). Some metadata may be `null` if the bot failed before joining or if the information is not available.
    
    **Transcription Information:** If transcription was enabled, the response includes transcription provider, transcription IDs (for BYOK providers), and URLs to raw and processed transcription files.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot details
 */
export const getBotDetails = <TData = AxiosResponse<GetBotDetailsResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v2/bots/${botId}`, options)
}
/**
 * Get the current status of a bot, including the latest status code, transcription status, and timestamp.
    
    Useful for polling bot state without fetching the full bot details. Returns lightweight status information including the current status code, transcription status, and when the status was last updated (`updated_at`).
    
    **Response Fields:**
    - `bot_id`: The UUID of the bot
    - `status`: The current bot status (queued, joining, in_call_recording, transcribing, completed, failed)
    - `transcription_status`: The current transcription status (not-applicable, not-started, queued, processing, done, error)
    - `updated_at`: ISO 8601 timestamp when the status was last updated
    
    **Transcription Status:** The transcription status is fetched in real-time from the transcription provider (e.g., Gladia) if transcription is enabled. This allows you to track transcription progress separately from the bot's overall status.
    
    **Polling Considerations:** 
    - **Not Recommended for Active Monitoring:** Due to the nature of meetings running for extended periods (often hours), frequent polling is not recommended. Instead, use `callback_config` when creating bots or configure webhooks at the account level to receive real-time status updates.
    - **Reconciliation Use Case:** This endpoint is better suited for reconciliation purposes (e.g., checking bot status after a webhook delivery failure or verifying final state).
    - **If Polling is Necessary:** If you must poll, use a judicious interval (e.g., every 5-10 minutes) and implement exponential backoff to avoid rate limits. Consider the meeting duration when determining polling frequency.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot status
 */
export const getBotStatus = <TData = AxiosResponse<GetBotStatusResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v2/bots/${botId}/status`, options)
}
/**
 * Retrieve a paginated list of screenshot URLs captured during the meeting.
    
    Screenshots are taken periodically during the meeting and can be used to visualize meeting content. Each screenshot is a presigned URL valid for 4 hours.
    
    **Screenshot Availability:** 
    - Screenshots are only available for Google Meet and Microsoft Teams bots
    - Screenshots are only available for bots with `recording_mode` set to `speaker_view` or `gallery_view`
    - Audio-only recordings do not have screenshots
    - Screenshots are captured at regular intervals during the meeting
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many screenshots are returned per page (default: 50, max: 100).
    
    **URL Expiration:** All screenshot URLs are presigned URLs that expire after 4 hours. If the bot's data has been deleted, this endpoint will return an empty list.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot screenshots
 */
export const getBotScreenshots = <TData = AxiosResponse<GetBotScreenshotsResponse>>(
  botId: string,
  params: GetBotScreenshotsParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v2/bots/${botId}/screenshots`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}
/**
 * Instruct a bot to leave the meeting immediately.
    
    The bot will stop recording and processing, then exit the meeting. Only works if the bot is currently in the meeting (status is `in_call_recording` or `transcribing`). The bot will send a final webhook event when it leaves.
    
    **Status Requirements:** The bot must be in a state that allows leaving. Bots that have already completed, failed, or are not yet in the meeting cannot be left via this endpoint. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Token Consumption:** When a bot is manually left, tokens are consumed based on the duration from when recording started to when the bot left. The bot will transition to `completed` status and send a completion webhook.
    
    **Immediate Effect:** The leave command is sent to the bot process immediately. The bot will stop recording and exit the meeting as soon as it receives the command (usually within a few seconds).
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Leave meeting
 */
export const leaveBot = <TData = AxiosResponse<LeaveBotResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v2/bots/${botId}/leave`, undefined, options)
}
/**
 * Permanently delete all bot data including recordings, transcripts, summaries, and screenshots.
    
    This operation is irreversible. All artifacts (video, audio, transcription, diarization, screenshots) will be permanently deleted. Optionally delete transcription data from the transcription provider as well using the `delete_transcription` query parameter.
    
    **Data Deletion:** 
    - All artifacts (video, audio, transcription, diarization, screenshots) are permanently deleted
    - The `artifacts_deleted` field is set to `true`
    - Artifact URLs will return `null` in subsequent API calls
    - Bot metadata remains accessible but all associated data is removed
    
    **Transcription Provider Deletion:** If `delete_transcription=true` is provided, the transcription data will also be deleted from the transcription provider (e.g., Gladia). This requires the bot to have transcription enabled and a transcription provider configured. If the bot uses BYOK transcription, you must have access to the transcription provider API key.
    
    **Irreversible Operation:** Once data is deleted, it cannot be recovered. Make sure you have downloaded or backed up any data you need before calling this endpoint.
    
    **Status Requirements:** The bot must be in `completed` or `failed` status. Bots that are still in progress (queued, joining, in_call_recording, transcribing) cannot have their data deleted. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Delete bot data
 */
export const deleteBotData = <TData = AxiosResponse<DeleteBotDataResponse>>(
  botId: string,
  params: DeleteBotDataParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.delete(`/v2/bots/${botId}/delete-data`, {
    ...options,
    params: { ...params, ...options?.params }
  })
}
/**
 * Resend the final webhook (completed or failed) for a bot.
    
    Useful if the webhook delivery failed or you need to reprocess the webhook event. The webhook will be sent to all configured webhook endpoints for your account.
    
    **Webhook Delivery:** The webhook will be sent to all configured webhook endpoints for your account. The webhook payload will be identical to the original final webhook (either `bot.completed` or `bot.failed` event).
    
    **Status Requirements:** The bot must be in `completed` or `failed` status. Bots that are still in progress cannot have their final webhook resent. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Use Cases:** 
    - Webhook delivery failed due to network issues
    - Webhook endpoint was temporarily unavailable
    - Need to reprocess a webhook event
    - Testing webhook integration
    
    **Idempotency:** This operation is idempotent. You can call it multiple times, and it will resend the webhook each time. There is no limit on how many times you can resend a webhook.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Resend final webhook
 */
export const resendFinalWebhook = <TData = AxiosResponse<ResendFinalWebhookResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v2/bots/${botId}/resend-webhook`, undefined, options)
}
/**
 * Retry sending the transcription callback for a bot.
    
    You can override the callback configuration (URL, method, secret) if needed. Only works for bots that have completed or failed. The callback will be sent to the provided URL (or the bot's original callback URL if not overridden).
    
    **Callback Configuration:** You can override the callback URL, HTTP method (POST or PUT), and secret in the request body. If not provided, the bot's original callback configuration will be used. The secret will be included in the `x-mb-secret` header for validation.
    
    **Status Requirements:** The bot must be in `completed` or `failed` status and must have had transcription enabled. Bots without transcription or bots that are still in progress cannot have their callback retried. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Callback Payload:** The callback payload will be identical to the original callback (either `bot.completed` or `bot.failed` event with transcription data). The payload format matches the webhook format.
    
    **Use Cases:**
    - Callback delivery failed due to network issues
    - Callback endpoint was temporarily unavailable
    - Need to send callback to a different endpoint
    - Testing callback integration
    
    **Idempotency:** This operation is idempotent. You can call it multiple times with the same or different configurations.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation or if no callback was configured.
 * @summary Retry callback
 */
export const retryCallback = <TData = AxiosResponse<RetryCallbackResponse>>(
  botId: string,
  retryCallbackRequestBodyInput: RetryCallbackRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v2/bots/${botId}/retry-callback`, retryCallbackRequestBodyInput, options)
}
/**
 * Schedule a bot to join a meeting at a specific time in the future.
    
    The bot will automatically join the meeting at the specified `join_at` time (ISO 8601 timestamp). You can provide a callback URL to receive events for this bot. The bot configuration is stored immediately, but token reservation and daily bot cap checks are performed when the bot actually joins the meeting.
    
    **Scheduling:** The `join_at` timestamp must be in the future (at least 1 minute ahead). The bot will automatically attempt to join the meeting at the specified time. There may be a small processing delay (typically less than a minute).
    
    **Token Reservation:** Tokens are NOT reserved at creation time. Token availability and daily bot cap are checked when the bot actually joins the meeting. If tokens are insufficient or the daily cap is reached at join time, the bot will fail with an appropriate error and transition to `failed` status.
    
    **Deduplication:** Deduplication is checked when the bot joins, not at creation time. This means you can schedule multiple bots for the same meeting URL, but only one will successfully join (unless `allow_multiple_bots` is true).
    
    **Status:** The scheduled bot starts in `scheduled` status and transitions to `completed` when the bot instance is created and queued to join. If the bot fails to join, it transitions to `failed` status.
    
    **Updates and Deletions:** Scheduled bots can be updated or deleted as long as they are in `scheduled` status and the join time is at least 4 minutes in the future. This ensures the bot can be modified before it starts processing.
    
    Returns a `bot_id` (UUID) that you can use to track and manage the scheduled bot. This UUID will be reused as the bot's UUID when it actually joins.
 * @summary Create scheduled bot
 */
export const createScheduledBot = <TData = AxiosResponse<CreateScheduledBotResponse>>(
  createScheduledBotRequestBodyInput: CreateScheduledBotRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post("/v2/bots/scheduled", createScheduledBotRequestBodyInput, options)
}
/**
 * Retrieve a paginated list of scheduled bots.
    
    Supports filtering by status (`scheduled`, `completed`, `failed`) and date range. Results are ordered by scheduled join time (earliest first). Use cursor-based pagination for efficient navigation.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many results are returned per page (default: 20, max: 100).
    
    **Filtering:**
    - `status`: Filter by scheduled bot status (comma-separated for multiple statuses)
    - `scheduled_after`: ISO 8601 timestamp - only return bots scheduled to join after this time
    - `scheduled_before`: ISO 8601 timestamp - only return bots scheduled to join before this time
    
    **Status Values:**
    - `scheduled`: Bot is scheduled but has not yet joined
    - `completed`: Bot instance was created and queued to join (bot may still be joining)
    - `failed`: Bot failed to join (token issues, daily cap, etc.)
    
    Returns a paginated list of scheduled bots with metadata including bot ID, scheduled join time, status, and basic configuration.
 * @summary List scheduled bots
 */
export const listScheduledBots = <TData = AxiosResponse<ListScheduledBotsResponse>>(
  params: ListScheduledBotsParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get("/v2/bots/scheduled", {
    ...options,
    params: { ...params, ...options?.params }
  })
}
/**
 * Create multiple scheduled bots in a single request with partial success support.
    
    Processes each scheduled bot creation request sequentially. Each item is validated and processed independently. Token reservation and daily bot cap checks are NOT performed at creation time - they are performed when each bot actually joins the meeting.
    
    **Processing Order:** Items are processed in the order they appear in the request array. Each item goes through validation: platform detection, BYOK transcription check, and join time validation. Unlike immediate bot creation, daily bot cap and token availability are not checked at creation time.
    
    **Partial Success:** The response always has `success: true`, even if all items fail. Check the `errors` array to identify failed items. The `data` array contains successfully scheduled bots with their `bot_id` and preserved `extra` metadata.
    
    **Join Time Validation:** Each scheduled bot's `join_at` time must be in the future (at least 1 minute ahead). If a join time is invalid, that item will fail with a validation error, but other items will continue processing.
    
    **Error Scenarios:** 
    - Validation errors: Invalid join time, invalid meeting URL, invalid configuration
    - Platform detection failures: `INVALID_MEETING_PLATFORM`
    - BYOK not enabled: `BYOK_TRANSCRIPTION_NOT_ENABLED_ON_PLAN`
    - System failures: `BOT_CREATE_FAILED`
    
    **Note:** Daily bot cap and token availability are checked when each bot joins, not at creation time. If these checks fail at join time, the bot will transition to `failed` status and send a failure webhook.
    
    Returns 201 with partial success response. All items may succeed, all may fail, or any combination.
 * @summary Create multiple scheduled bots
 */
export const batchCreateScheduledBots = <TData = AxiosResponse<BatchCreateScheduledBotResponse>>(
  batchCreateScheduledBotsRequestBodyInput: BatchCreateScheduledBotsRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post("/v2/bots/scheduled/batch", batchCreateScheduledBotsRequestBodyInput, options)
}
/**
 * Retrieve detailed information about a specific scheduled bot.
    
    Returns the scheduled bot's configuration, scheduled join time, current status, and associated bot instance (if the bot has already joined). Includes all the same configuration options as immediate bot creation.
    
    **Status Information:** The response includes the scheduled bot's current status (`scheduled`, `completed`, or `failed`) and when the status was last updated. If the bot has joined, the response includes a link to the actual bot instance.
    
    **Scheduled Join Time:** The `join_at` field contains the ISO 8601 timestamp when the bot is scheduled to join the meeting.
    
    **Bot Instance:** If the scheduled bot has transitioned to `completed` status, the bot instance has been created and is queued to join. You can use the `bot_id` (which will be reused as the bot's UUID when it joins) to query the bot's status and retrieve meeting data once it has joined.
    
    **Updates and Deletions:** If the bot is in `scheduled` status and the join time is at least 4 minutes in the future, you can update or delete the scheduled bot. This ensures the bot can be modified before it starts processing.
    
    Returns 404 if the scheduled bot is not found or does not belong to your team.
 * @summary Get scheduled bot details
 */
export const getScheduledBotDetails = <TData = AxiosResponse<GetScheduledBotResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v2/bots/scheduled/${botId}`, options)
}
/**
 * Update a scheduled bot's configuration or scheduled join time.
    
    The bot must be in `scheduled` status and the join time must be at least 4 minutes in the future. This ensures the bot can be updated before it starts processing.
    
    **Updateable Fields:** You can update any configuration field (bot name, image, recording mode, transcription settings, etc.) and the scheduled join time (`join_at`). All fields are optional - only provided fields will be updated.
    
    **Join Time Requirements:** 
    - The new `join_at` time must be in the future
    - The bot must be in `scheduled` status
    - The join time must be at least 4 minutes in the future (lock window)
    - If the join time is too close, the request will fail with 409 Conflict
    
    **Status Requirements:** The bot must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be updated. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Validation:** All updated fields are validated using the same rules as bot creation. Invalid configurations will result in a 400 Bad Request error.
    
    Returns 404 if the scheduled bot is not found, or 409 if the bot's status does not allow update or the join time is too close.
 * @summary Update scheduled bot
 */
export const updateScheduledBot = <TData = AxiosResponse<UpdateScheduledBotResponse>>(
  botId: string,
  updateScheduledBotRequestBodyInput: UpdateScheduledBotRequestBodyInput,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.patch(`/v2/bots/scheduled/${botId}`, updateScheduledBotRequestBodyInput, options)
}
/**
 * Cancel and delete a scheduled bot.
    
    The bot must be in `scheduled` status and the join time must be at least 4 minutes in the future. This ensures the bot can be updated before it starts processing. Once deleted, the scheduled bot cannot be recovered.
    
    **Status Requirements:** The bot must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be deleted via this endpoint. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Join Time Requirements:** The join time must be at least 4 minutes in the future. If the join time is too close, the request will fail with 409 Conflict. This ensures the bot can be cancelled before it starts processing.
    
    **Irreversible Operation:** Once a scheduled bot is deleted, it cannot be recovered. If you need to cancel a bot that is about to join, you should use the leave endpoint on the actual bot instance instead.
    
    **No Token Impact:** Since tokens are not reserved for scheduled bots, deleting a scheduled bot does not affect your token balance.
    
    Returns 404 if the scheduled bot is not found, or 409 if the bot's status does not allow deletion or the join time is too close.
 * @summary Delete scheduled bot
 */
export const deleteScheduledBot = <TData = AxiosResponse<DeleteScheduledBotResponse>>(
  botId: string,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.delete(`/v2/bots/scheduled/${botId}`, options)
}
export type CreateBotResult = AxiosResponse<CreateBotResponse>
export type ListBotsResult = AxiosResponse<ListBotsResponse>
export type BatchCreateBotsResult = AxiosResponse<BatchCreateBotResponse>
export type GetBotDetailsResult = AxiosResponse<GetBotDetailsResponse>
export type GetBotStatusResult = AxiosResponse<GetBotStatusResponse>
export type GetBotScreenshotsResult = AxiosResponse<GetBotScreenshotsResponse>
export type LeaveBotResult = AxiosResponse<LeaveBotResponse>
export type DeleteBotDataResult = AxiosResponse<DeleteBotDataResponse>
export type ResendFinalWebhookResult = AxiosResponse<ResendFinalWebhookResponse>
export type RetryCallbackResult = AxiosResponse<RetryCallbackResponse>
export type CreateScheduledBotResult = AxiosResponse<CreateScheduledBotResponse>
export type ListScheduledBotsResult = AxiosResponse<ListScheduledBotsResponse>
export type BatchCreateScheduledBotsResult = AxiosResponse<BatchCreateScheduledBotResponse>
export type GetScheduledBotDetailsResult = AxiosResponse<GetScheduledBotResponse>
export type UpdateScheduledBotResult = AxiosResponse<UpdateScheduledBotResponse>
export type DeleteScheduledBotResult = AxiosResponse<DeleteScheduledBotResponse>
