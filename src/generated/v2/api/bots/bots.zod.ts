/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Meeting BaaS API
 * API for managing meeting bots, calendar integrations, and webhooks
 * OpenAPI spec version: 2.0.0
 */
import { z as zod } from "zod"

/**
 * Create a bot to join a meeting immediately.
    
    The bot will automatically join the meeting, request recording permissions, and start recording once accepted. You can provide a bot-specific callback URL to receive bot.completed and bot.failed events for this bot (in addition to your account's webhooks). The bot will send webhook events for status changes, completion, and failures.
    
    Returns a `bot_id` (UUID) that you can use to track status, retrieve meeting data, and manage the bot. The bot will be queued immediately and join the meeting as soon as possible (may take up to 2 minutes depending on availability of bot slots).
    
    **Token Reservation:** 0.5 tokens are reserved immediately upon creation. These tokens will be consumed based on the bot's duration and outcome. If the bot fails due to user-responsible errors (`BOT_NOT_ACCEPTED`, `TIMEOUT_WAITING_TO_START`), recording tokens will be charged based on the time spent in the waiting room.
    
    **Deduplication:** By default, multiple bots can join the same meeting URL. Set `allow_multiple_bots: false` to prevent duplicate bots within 5 minutes. The deduplication check expires after 5 minutes, allowing a new bot to join the same meeting URL after that period.
    
    **Rate Limits:** Subject to your API key's rate limits and your team's daily bot cap. The daily bot cap is checked before token reservation. If the cap is reached, the request will fail with a 429 status code.
    
    **Error Scenarios:**
    - `402 Payment Required`: Insufficient tokens available
    - `409 Conflict`: Bot already exists for the same meeting URL (when `allow_multiple_bots` is false)
    - `429 Too Many Requests`: Daily bot cap reached or rate limit exceeded
 * @summary Create a bot
 */
export const createBotBodyBotNameMax = 255
export const createBotBodyBotImageDefault = null
export const createBotBodyAllowMultipleBotsDefault = true
export const createBotBodyRecordingModeDefault = "speaker_view"
export const createBotBodyEntryMessageMaxOne = 500
export const createBotBodyEntryMessageDefault = null
export const createBotBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const createBotBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const createBotBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const createBotBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const createBotBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const createBotBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const createBotBodyTimeoutConfigSilenceTimeoutDefault = 600
export const createBotBodyTimeoutConfigSilenceTimeoutMin = 300

export const createBotBodyTimeoutConfigSilenceTimeoutMax = 1800
export const createBotBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const createBotBodyZoomAccessTokenUrlDefault = null
export const createBotBodyExtraDefault = null
export const createBotBodyStreamingEnabledDefault = false
export const createBotBodyStreamingConfigInputUrlDefault = null
export const createBotBodyStreamingConfigOutputUrlDefault = null
export const createBotBodyStreamingConfigAudioFrequencyDefault = 24000
export const createBotBodyStreamingConfigDefault = null
export const createBotBodyTranscriptionEnabledDefault = false
export const createBotBodyTranscriptionConfigProviderDefault = "gladia"
export const createBotBodyTranscriptionConfigApiKeyDefault = null
export const createBotBodyTranscriptionConfigCustomParamsDefault = null
export const createBotBodyTranscriptionConfigDefault = null
export const createBotBodyCallbackEnabledDefault = false
export const createBotBodyCallbackConfigSecretDefault = null
export const createBotBodyCallbackConfigMethodDefault = "POST"
export const createBotBodyCallbackConfigDefault = null

export const createBotBody = zod.object({
  bot_name: zod
    .string()
    .min(1)
    .max(createBotBodyBotNameMax)
    .describe(
      "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
    ),
  bot_image: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
    ),
  meeting_url: zod
    .string()
    .url()
    .describe(
      'The URL of the meeting to join.\n\nMust be a valid HTTPS URL for a Microsoft Teams, Google Meet, or Zoom meeting.\n\nExample: \"https://zoom.us/j/123456789\" or \"https://meet.google.com/abc-defg-hij\"'
    ),
  allow_multiple_bots: zod
    .boolean()
    .default(createBotBodyAllowMultipleBotsDefault)
    .describe(
      "Whether to allow multiple bots to join the same meeting.\n\nIf set to `false`, only a single bot will be allowed to join using the same meeting URL within the last 5 minutes. This prevents duplicate bots from joining the same meeting.\n\nIf set to `true` (default), multiple bots can join the same meeting URL.\n\nDefault: `true`"
    ),
  recording_mode: zod
    .enum(["audio_only", "speaker_view", "gallery_view"])
    .default(createBotBodyRecordingModeDefault)
    .describe(
      "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
    ),
  entry_message: zod
    .string()
    .max(createBotBodyEntryMessageMaxOne)
    .or(zod.null())
    .optional()
    .describe(
      "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
    ),
  timeout_config: zod
    .object({
      waiting_room_timeout: zod
        .number()
        .min(createBotBodyTimeoutConfigWaitingRoomTimeoutMin)
        .max(createBotBodyTimeoutConfigWaitingRoomTimeoutMax)
        .default(createBotBodyTimeoutConfigWaitingRoomTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      no_one_joined_timeout: zod
        .number()
        .min(createBotBodyTimeoutConfigNoOneJoinedTimeoutMin)
        .max(createBotBodyTimeoutConfigNoOneJoinedTimeoutMax)
        .default(createBotBodyTimeoutConfigNoOneJoinedTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      silence_timeout: zod
        .number()
        .min(createBotBodyTimeoutConfigSilenceTimeoutMin)
        .max(createBotBodyTimeoutConfigSilenceTimeoutMax)
        .default(createBotBodyTimeoutConfigSilenceTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
        )
    })
    .default(createBotBodyTimeoutConfigDefault)
    .describe(
      "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
    ),
  zoom_access_token_url: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
    ),
  extra: zod
    .record(zod.string(), zod.any())
    .or(zod.null())
    .optional()
    .describe(
      "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
    ),
  streaming_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
    ),
  streaming_config: zod
    .object({
      input_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
        ),
      output_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
        ),
      audio_frequency: zod
        .number()
        .or(zod.number())
        .or(zod.number())
        .or(zod.number())
        .describe(
          "Audio frequency in Hz. Supported values: 16000, 24000 (default), 32000, 48000 Hz."
        )
        .or(zod.null())
        .default(createBotBodyStreamingConfigAudioFrequencyDefault)
        .describe("The audio frequency in Hz. Supported values: 24000 (default), 32000, 48000 Hz.")
    })
    .or(zod.null())
    .optional(),
  transcription_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
    ),
  transcription_config: zod
    .object({
      provider: zod
        .enum(["gladia"])
        .default(createBotBodyTranscriptionConfigProviderDefault)
        .describe(
          "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
        ),
      api_key: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
        ),
      custom_params: zod
        .record(zod.string(), zod.any())
        .or(zod.null())
        .optional()
        .describe(
          "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
        )
    })
    .or(zod.null())
    .optional(),
  callback_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
    ),
  callback_config: zod
    .object({
      url: zod
        .string()
        .url()
        .describe("The URL to be called upon the completion or failure of the bot."),
      secret: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
        ),
      method: zod
        .enum(["POST", "PUT"])
        .default(createBotBodyCallbackConfigMethodDefault)
        .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
    })
    .or(zod.null())
    .optional()
})

/**
 * List all bots for your team with pagination support.
    
    Filter by status (queued, joining, in_call_recording, transcribing, completed, failed), meeting platform (zoom, meet, teams), and date range. Results are ordered by creation date (newest first). Use cursor-based pagination for efficient navigation through large result sets.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The response includes a `next_cursor` if more results are available. The `limit` parameter controls how many results are returned per page (default: 50, max: 250).
    
    **Filtering:** 
    - `status`: Filter by bot status (comma-separated for multiple statuses)
    - `platform`: Filter by meeting platform (zoom, meet, teams)
    - `created_after`: ISO 8601 timestamp - only return bots created after this time
    - `created_before`: ISO 8601 timestamp - only return bots created before this time
    
    **Date Range:** The `created_after` and `created_before` filters use ISO 8601 timestamps. Results are limited to bots created within the last 90 days by default.
    
    Returns a paginated list of bots with metadata including bot ID, status, meeting platform, creation time, and basic configuration.
 * @summary List bots
 */
export const listBotsQueryBotNameDefault = null
export const listBotsQueryBotIdDefault = null
export const listBotsQueryCreatedBeforeRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsQueryCreatedBeforeDefault = null
export const listBotsQueryCreatedAfterRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsQueryCreatedAfterDefault = null
export const listBotsQueryLimitDefault = 50
export const listBotsQueryLimitMax = 250
export const listBotsQueryCursorDefault = null
export const listBotsQueryEndedAfterRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsQueryEndedAfterDefault = null
export const listBotsQueryExtraDefault = null
export const listBotsQueryMeetingUrlDefault = null

export const listBotsQueryParams = zod.object({
  bot_name: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by name containing this string.\n\nPerforms a case-insensitive partial match on the bot\'s name. Useful for finding bots with specific naming conventions or to locate a particular bot when you don\'t have its ID.\n\nExample: \"Sales\" would match \"Sales Meeting\", \"Quarterly Sales\", etc.'
    ),
  bot_id: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by ID containing this string.\n\nPerforms a case-insensitive partial match on the bot\'s ID. Useful for finding bots with specific IDs or to locate a particular bot when you don\'t have its ID.\n\nExample: \"1234567890\" would match \"1234567890-1234-1234-1234-123456789012\"'
    ),
  created_before: zod
    .string()
    .datetime({})
    .regex(listBotsQueryCreatedBeforeRegExpOne)
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots created before this date.\n\nISO8601 format (e.g., \"2025-01-15T10:30:00Z\").\n\nCannot be more than 90 days before today and cannot be in the future.\n\nUse this in combination with `created_after` to filter bots within a specific date range.\n\nExample: \"2025-01-15T23:59:59Z\"'
    ),
  created_after: zod
    .string()
    .datetime({})
    .regex(listBotsQueryCreatedAfterRegExpOne)
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots created after this date.\n\nISO8601 format (e.g., \"2025-01-01T00:00:00Z\").\n\nCannot be more than 90 days before today and cannot be in the future.\n\nUse this in combination with `created_before` to filter bots within a specific date range.\n\nExample: \"2025-01-01T00:00:00Z\"'
    ),
  limit: zod
    .number()
    .max(listBotsQueryLimitMax)
    .describe(
      "Maximum number of bots to return in a single request.\n\nLimits the number of results returned in a single API call.\n\nDefault: 50 Minimum: 1 Maximum: 250"
    ),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing `<isoDate>::<id>`. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MjAyNS0wMS0xNVQxMDozMDowMFo6OjEyMzQ1\" or \"LU1qQXlOM1UxTmpVME5qVXhNakUwTkRrPQ==\" (for backward pagination)'
    ),
  ended_after: zod
    .string()
    .datetime({})
    .regex(listBotsQueryEndedAfterRegExpOne)
    .or(zod.null())
    .optional()
    .describe("The date to filter bots ended after. ISO 8601 format."),
  extra: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by matching values in the extra JSON payload.\n\nThis parameter performs in-memory filtering on the `extra` JSON field, similar to a SQL WHERE clause. It reduces the result set to only include bots that match all specified conditions.\n\nFormat specifications: - Single condition: \"field:value\" - Multiple conditions: \"field1:value1,field2:value2\"\n\nExamples: - \"customer_id:12345\" - Only bots with this customer ID - \"status:active,project:sales\" - Only active bots from sales projects\n\nNotes: - All conditions must match for a bot to be included - Values are matched exactly (case-sensitive) - Bots without the specified field are excluded'
    ),
  meeting_url: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by meeting URL containing this string.\n\nPerforms a case-insensitive partial match on the bot\'s meeting URL. Useful for finding bots associated with specific meeting platforms or particular meeting IDs.\n\nExample: \"zoom.us\" would match all Zoom meetings'
    ),
  meeting_platform: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by meeting platform.\n\nThis parameter filters bots by the platform they are associated with. It can be used to find bots that are associated with a specific meeting platform. Valid values are: \"zoom\", \"meet\", \"teams\".\n\nExample: \"zoom\" would match all bots associated with Zoom meetings.\n\nTo filter multiple platforms, use a comma-separated list of values. For example, \"zoom,meet\" would match all bots associated with Zoom or Meet meetings.'
    ),
  status: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by bot statuses.\n\nThis parameter filters bots by their status. It can be used to find bots that have any of the specified statuses. Valid values are one or more of: queued, transcribing, completed, failed, joining_call, in_waiting_room, in_waiting_for_host, in_call_not_recording, in_call_recording, recording_paused, recording_resumed, call_ended, recording_succeeded, recording_failed, api_request_stop, bot_rejected, bot_removed, bot_removed_too_early, waiting_room_timeout, invalid_meeting_url, meeting_error.\n\nExample: \"queued,joining_call\" would match all bots that are queued or joining the call'
    )
})

export const listBotsResponseDataItemBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listBotsResponseDataItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsResponseDataItemEndedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsResponseDataItemJoinedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listBotsResponseDataItemExitedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const listBotsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      bot_id: zod
        .string()
        .uuid()
        .regex(listBotsResponseDataItemBotIdRegExp)
        .describe("The UUID of the bot"),
      bot_name: zod.string().describe("The name of the bot"),
      meeting_url: zod.string().url().describe("The URL of the meeting"),
      meeting_platform: zod
        .enum(["zoom", "meet", "teams"])
        .describe("The platform of the meeting (zoom, meet, or teams)"),
      extra: zod
        .record(zod.string(), zod.any())
        .or(zod.null())
        .describe("Custom metadata associated with the bot"),
      duration: zod
        .number()
        .or(zod.null())
        .describe("Duration of the meeting in seconds (null if meeting hasn't ended)"),
      created_at: zod
        .string()
        .datetime({})
        .regex(listBotsResponseDataItemCreatedAtRegExp)
        .describe("ISO 8601 timestamp when the bot was created"),
      ended_at: zod
        .string()
        .datetime({})
        .regex(listBotsResponseDataItemEndedAtRegExpOne)
        .or(zod.null())
        .describe("ISO 8601 timestamp when the bot ended (null if still active)"),
      joined_at: zod
        .string()
        .datetime({})
        .regex(listBotsResponseDataItemJoinedAtRegExpOne)
        .or(zod.null())
        .describe("ISO 8601 timestamp when the bot joined the meeting (null if not joined yet)"),
      exited_at: zod
        .string()
        .datetime({})
        .regex(listBotsResponseDataItemExitedAtRegExpOne)
        .or(zod.null())
        .describe("ISO 8601 timestamp when the bot exited the meeting (null if not exited yet)"),
      status: zod
        .enum([
          "queued",
          "transcribing",
          "completed",
          "failed",
          "joining_call",
          "in_waiting_room",
          "in_waiting_for_host",
          "in_call_not_recording",
          "in_call_recording",
          "recording_paused",
          "recording_resumed",
          "call_ended",
          "recording_succeeded",
          "recording_failed",
          "api_request_stop",
          "bot_rejected",
          "bot_removed",
          "bot_removed_too_early",
          "waiting_room_timeout",
          "invalid_meeting_url",
          "meeting_error"
        ])
        .describe("The current status of the bot"),
      error_code: zod
        .string()
        .or(zod.null())
        .describe("Error code if the bot failed (null if no error)"),
      error_message: zod
        .string()
        .or(zod.null())
        .describe("Human-readable error message if the bot failed (null if no error)")
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Create multiple bots in a single request with partial success support.
    
    Processes each bot creation request sequentially (index 0, 1, 2...). Each item is validated and processed independently. If some bots fail to create, the request still returns 201 with a `data` array containing successful creations and an `errors` array containing failures. Each error includes the `index` of the failed item in the original request array.
    
    **Processing Order:** Items are processed in the order they appear in the request array. Each item goes through the same validation and checks as a single bot creation: platform detection, BYOK transcription check, daily bot cap check, token availability check, and deduplication lock acquisition.
    
    **Partial Success:** The response always has `success: true`, even if all items fail. Check the `errors` array to identify failed items. The `data` array contains successfully created bots with their `bot_id` and preserved `extra` metadata. The `errors` array contains failed items with `index`, `code`, `message`, `details`, and preserved `extra` metadata.
    
    **Daily Bot Cap:** The daily bot cap is checked per item, not per batch. If the cap is reached mid-batch, subsequent items will fail with `DAILY_BOT_CAP_REACHED` error. The cap is based on bots created in the last 24 hours.
    
    **Token Reservation:** Tokens are reserved individually for each successful bot creation (0.5 tokens per bot). If token availability becomes insufficient mid-batch, subsequent items will fail with `INSUFFICIENT_TOKENS`.
    
    **Error Index Mapping:** Each error includes an `index` field (0-based) that corresponds to the item's position in the request array. Use this to correlate errors with your original request. Validation errors include detailed validation issues in the `details` field.
    
    **Error Isolation:** Each bot creation is processed independently. If one bot creation fails, it does not affect other bots in the batch. Failed items are included in the `errors` array while successful items are in the `data` array.
    
    Returns 201 with partial success response. All items may succeed, all may fail, or any combination. Always check both `data` and `errors` arrays.
 * @summary Create multiple bots
 */
export const batchCreateBotsBodyBotNameMax = 255
export const batchCreateBotsBodyBotImageDefault = null
export const batchCreateBotsBodyAllowMultipleBotsDefault = true
export const batchCreateBotsBodyRecordingModeDefault = "speaker_view"
export const batchCreateBotsBodyEntryMessageMaxOne = 500
export const batchCreateBotsBodyEntryMessageDefault = null
export const batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const batchCreateBotsBodyTimeoutConfigSilenceTimeoutDefault = 600
export const batchCreateBotsBodyTimeoutConfigSilenceTimeoutMin = 300

export const batchCreateBotsBodyTimeoutConfigSilenceTimeoutMax = 1800
export const batchCreateBotsBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const batchCreateBotsBodyZoomAccessTokenUrlDefault = null
export const batchCreateBotsBodyExtraDefault = null
export const batchCreateBotsBodyStreamingEnabledDefault = false
export const batchCreateBotsBodyStreamingConfigInputUrlDefault = null
export const batchCreateBotsBodyStreamingConfigOutputUrlDefault = null
export const batchCreateBotsBodyStreamingConfigAudioFrequencyDefault = 24000
export const batchCreateBotsBodyStreamingConfigDefault = null
export const batchCreateBotsBodyTranscriptionEnabledDefault = false
export const batchCreateBotsBodyTranscriptionConfigProviderDefault = "gladia"
export const batchCreateBotsBodyTranscriptionConfigApiKeyDefault = null
export const batchCreateBotsBodyTranscriptionConfigCustomParamsDefault = null
export const batchCreateBotsBodyTranscriptionConfigDefault = null
export const batchCreateBotsBodyCallbackEnabledDefault = false
export const batchCreateBotsBodyCallbackConfigSecretDefault = null
export const batchCreateBotsBodyCallbackConfigMethodDefault = "POST"
export const batchCreateBotsBodyCallbackConfigDefault = null

export const batchCreateBotsBodyItem = zod.object({
  bot_name: zod
    .string()
    .min(1)
    .max(batchCreateBotsBodyBotNameMax)
    .describe(
      "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
    ),
  bot_image: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
    ),
  meeting_url: zod
    .string()
    .url()
    .describe(
      'The URL of the meeting to join.\n\nMust be a valid HTTPS URL for a Microsoft Teams, Google Meet, or Zoom meeting.\n\nExample: \"https://zoom.us/j/123456789\" or \"https://meet.google.com/abc-defg-hij\"'
    ),
  allow_multiple_bots: zod
    .boolean()
    .default(batchCreateBotsBodyAllowMultipleBotsDefault)
    .describe(
      "Whether to allow multiple bots to join the same meeting.\n\nIf set to `false`, only a single bot will be allowed to join using the same meeting URL within the last 5 minutes. This prevents duplicate bots from joining the same meeting.\n\nIf set to `true` (default), multiple bots can join the same meeting URL.\n\nDefault: `true`"
    ),
  recording_mode: zod
    .enum(["audio_only", "speaker_view", "gallery_view"])
    .default(batchCreateBotsBodyRecordingModeDefault)
    .describe(
      "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
    ),
  entry_message: zod
    .string()
    .max(batchCreateBotsBodyEntryMessageMaxOne)
    .or(zod.null())
    .optional()
    .describe(
      "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
    ),
  timeout_config: zod
    .object({
      waiting_room_timeout: zod
        .number()
        .min(batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutMin)
        .max(batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutMax)
        .default(batchCreateBotsBodyTimeoutConfigWaitingRoomTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      no_one_joined_timeout: zod
        .number()
        .min(batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutMin)
        .max(batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutMax)
        .default(batchCreateBotsBodyTimeoutConfigNoOneJoinedTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      silence_timeout: zod
        .number()
        .min(batchCreateBotsBodyTimeoutConfigSilenceTimeoutMin)
        .max(batchCreateBotsBodyTimeoutConfigSilenceTimeoutMax)
        .default(batchCreateBotsBodyTimeoutConfigSilenceTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
        )
    })
    .default(batchCreateBotsBodyTimeoutConfigDefault)
    .describe(
      "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
    ),
  zoom_access_token_url: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
    ),
  extra: zod
    .record(zod.string(), zod.any())
    .or(zod.null())
    .optional()
    .describe(
      "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
    ),
  streaming_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
    ),
  streaming_config: zod
    .object({
      input_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
        ),
      output_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
        ),
      audio_frequency: zod
        .number()
        .or(zod.number())
        .or(zod.number())
        .or(zod.number())
        .describe(
          "Audio frequency in Hz. Supported values: 16000, 24000 (default), 32000, 48000 Hz."
        )
        .or(zod.null())
        .default(batchCreateBotsBodyStreamingConfigAudioFrequencyDefault)
        .describe("The audio frequency in Hz. Supported values: 24000 (default), 32000, 48000 Hz.")
    })
    .or(zod.null())
    .optional(),
  transcription_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
    ),
  transcription_config: zod
    .object({
      provider: zod
        .enum(["gladia"])
        .default(batchCreateBotsBodyTranscriptionConfigProviderDefault)
        .describe(
          "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
        ),
      api_key: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
        ),
      custom_params: zod
        .record(zod.string(), zod.any())
        .or(zod.null())
        .optional()
        .describe(
          "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
        )
    })
    .or(zod.null())
    .optional(),
  callback_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
    ),
  callback_config: zod
    .object({
      url: zod
        .string()
        .url()
        .describe("The URL to be called upon the completion or failure of the bot."),
      secret: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
        ),
      method: zod
        .enum(["POST", "PUT"])
        .default(batchCreateBotsBodyCallbackConfigMethodDefault)
        .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
    })
    .or(zod.null())
    .optional()
})
export const batchCreateBotsBody = zod.array(batchCreateBotsBodyItem).min(1).max(100)

/**
 * Get comprehensive information about a specific bot.
    
    Returns detailed bot information including current status, configuration, meeting metadata, and presigned URLs for all artifacts (video, audio, transcription, diarization). Artifact URLs are valid for 4 hours from the time of request. Returns `null` for artifacts if the bot's data has been deleted.
    
    **Artifact URLs:** All artifact URLs (video, audio, transcription, diarization) are presigned URLs that expire after 4 hours. If the bot's data has been deleted (via the delete-data endpoint or data retention policy), these fields will be `null`. The `artifacts_deleted` field indicates whether the bot's data has been permanently removed.
    
    **Status Information:** The response includes the bot's current status (`status` field) and timestamps for key events (joined_at, exited_at, created_at). If the bot failed, the response includes `error_code` and `error_message` fields with details about what went wrong.
    
    **Meeting Metadata:** Includes meeting platform, meeting URL, participants list, speakers list, and meeting duration (if available). Some metadata may be `null` if the bot failed before joining or if the information is not available.
    
    **Transcription Information:** If transcription was enabled, the response includes transcription provider, transcription IDs (for BYOK providers), and URLs to raw and processed transcription files.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot details
 */
export const getBotDetailsPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getBotDetailsParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(getBotDetailsPathBotIdRegExp)
    .describe("The UUID of the bot to get details for.")
})

export const getBotDetailsResponseDataBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getBotDetailsResponseDataCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getBotDetailsResponseDataJoinedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getBotDetailsResponseDataExitedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getBotDetailsResponseDataParticipantsItemIdMinOne = -9007199254740991
export const getBotDetailsResponseDataParticipantsItemIdMaxOne = 9007199254740991
export const getBotDetailsResponseDataSpeakersItemIdMinOne = -9007199254740991
export const getBotDetailsResponseDataSpeakersItemIdMaxOne = 9007199254740991

export const getBotDetailsResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    bot_id: zod
      .string()
      .uuid()
      .regex(getBotDetailsResponseDataBotIdRegExp)
      .describe("The UUID of the bot"),
    bot_name: zod.string().describe("The name of the bot"),
    meeting_url: zod.string().url().describe("The URL of the meeting"),
    meeting_platform: zod.enum(["zoom", "meet", "teams"]).describe("The platform of the meeting"),
    recording_mode: zod
      .enum(["audio_only", "speaker_view", "gallery_view"])
      .describe("The recording mode used by the bot"),
    status: zod
      .enum([
        "queued",
        "transcribing",
        "completed",
        "failed",
        "joining_call",
        "in_waiting_room",
        "in_waiting_for_host",
        "in_call_not_recording",
        "in_call_recording",
        "recording_paused",
        "recording_resumed",
        "call_ended",
        "recording_succeeded",
        "recording_failed",
        "api_request_stop",
        "bot_rejected",
        "bot_removed",
        "bot_removed_too_early",
        "waiting_room_timeout",
        "invalid_meeting_url",
        "meeting_error"
      ])
      .describe("The current status of the bot"),
    created_at: zod
      .string()
      .datetime({})
      .regex(getBotDetailsResponseDataCreatedAtRegExp)
      .describe("ISO 8601 timestamp when the bot was created"),
    joined_at: zod
      .string()
      .datetime({})
      .regex(getBotDetailsResponseDataJoinedAtRegExpOne)
      .or(zod.null())
      .describe("ISO 8601 timestamp when the bot joined the meeting (null if not joined yet)"),
    exited_at: zod
      .string()
      .datetime({})
      .regex(getBotDetailsResponseDataExitedAtRegExpOne)
      .or(zod.null())
      .describe("ISO 8601 timestamp when the bot exited the meeting (null if not exited yet)"),
    duration_seconds: zod
      .number()
      .or(zod.null())
      .describe("Duration of the meeting in seconds (null if meeting hasn't ended)"),
    participants: zod
      .array(
        zod.object({
          name: zod.string().describe("Participant's name (full name or display name)"),
          id: zod
            .number()
            .min(getBotDetailsResponseDataParticipantsItemIdMinOne)
            .max(getBotDetailsResponseDataParticipantsItemIdMaxOne)
            .or(zod.null())
            .describe("Sequential participant ID (1, 2, 3...). Null if not available"),
          display_name: zod
            .string()
            .optional()
            .describe("Display name shown in UI (if different from name)"),
          profile_picture: zod
            .string()
            .url()
            .optional()
            .describe("Profile picture URL (if available)")
        })
      )
      .describe("List of participants who joined the meeting with their names and metadata"),
    speakers: zod
      .array(
        zod.object({
          name: zod.string().describe("Participant's name (full name or display name)"),
          id: zod
            .number()
            .min(getBotDetailsResponseDataSpeakersItemIdMinOne)
            .max(getBotDetailsResponseDataSpeakersItemIdMaxOne)
            .or(zod.null())
            .describe("Sequential participant ID (1, 2, 3...). Null if not available"),
          display_name: zod
            .string()
            .optional()
            .describe("Display name shown in UI (if different from name)"),
          profile_picture: zod
            .string()
            .url()
            .optional()
            .describe("Profile picture URL (if available)")
        })
      )
      .describe("List of speakers identified in the meeting with their names and metadata"),
    artifacts_deleted: zod.boolean().describe("Whether the artifacts have been deleted"),
    video: zod
      .string()
      .url()
      .or(zod.null())
      .describe("Signed URL to the video recording (valid for 4 hours, null if not available)"),
    audio: zod
      .string()
      .url()
      .or(zod.null())
      .describe("Signed URL to the audio recording (valid for 4 hours, null if not available)"),
    diarization: zod
      .string()
      .url()
      .or(zod.null())
      .describe("Signed URL to the diarization file (valid for 4 hours, null if not available)"),
    raw_transcription: zod
      .string()
      .url()
      .or(zod.null())
      .describe(
        "Signed URL to the raw transcription file (valid for 4 hours, null if not available)"
      ),
    transcription: zod
      .string()
      .url()
      .or(zod.null())
      .describe("Signed URL to the transcription file (valid for 4 hours, null if not available)"),
    transcription_ids: zod
      .array(zod.string())
      .or(zod.null())
      .describe("Array of transcription job IDs from the transcription provider"),
    transcription_provider: zod
      .enum(["gladia"])
      .or(zod.null())
      .describe(
        "The transcription provider used (null if transcription is disabled or provider is 'none')"
      ),
    error_code: zod
      .string()
      .or(zod.null())
      .describe("Error code if the bot failed (null if no error)"),
    error_message: zod
      .string()
      .or(zod.null())
      .describe("Human-readable error message if the bot failed (null if no error)"),
    extra: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .describe("Custom metadata associated with the bot")
  })
})

/**
 * Get the current status of a bot, including the latest status code, transcription status, and timestamp.
    
    Useful for polling bot state without fetching the full bot details. Returns lightweight status information including the current status code, transcription status, and when the status was last updated (`updated_at`).
    
    **Response Fields:**
    - `bot_id`: The UUID of the bot
    - `status`: The current bot status (queued, joining, in_call_recording, transcribing, completed, failed)
    - `transcription_status`: The current transcription status (not-applicable, not-started, queued, processing, done, error)
    - `updated_at`: ISO 8601 timestamp when the status was last updated
    
    **Transcription Status:** The transcription status is fetched in real-time from the transcription provider (e.g., Gladia) if transcription is enabled. This allows you to track transcription progress separately from the bot's overall status.
    
    **Polling Considerations:** 
    - **Not Recommended for Active Monitoring:** Due to the nature of meetings running for extended periods (often hours), frequent polling is not recommended. Instead, use `callback_config` when creating bots or configure webhooks at the account level to receive real-time status updates.
    - **Reconciliation Use Case:** This endpoint is better suited for reconciliation purposes (e.g., checking bot status after a webhook delivery failure or verifying final state).
    - **If Polling is Necessary:** If you must poll, use a judicious interval (e.g., every 5-10 minutes) and implement exponential backoff to avoid rate limits. Consider the meeting duration when determining polling frequency.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot status
 */
export const getBotStatusPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getBotStatusParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(getBotStatusPathBotIdRegExp)
    .describe("The UUID of the bot to get status for.")
})

export const getBotStatusResponseDataBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getBotStatusResponseDataUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const getBotStatusResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    bot_id: zod
      .string()
      .uuid()
      .regex(getBotStatusResponseDataBotIdRegExp)
      .describe("The UUID of the bot"),
    status: zod
      .enum([
        "queued",
        "transcribing",
        "completed",
        "failed",
        "joining_call",
        "in_waiting_room",
        "in_waiting_for_host",
        "in_call_not_recording",
        "in_call_recording",
        "recording_paused",
        "recording_resumed",
        "call_ended",
        "recording_succeeded",
        "recording_failed",
        "api_request_stop",
        "bot_rejected",
        "bot_removed",
        "bot_removed_too_early",
        "waiting_room_timeout",
        "invalid_meeting_url",
        "meeting_error"
      ])
      .describe("The current status of the bot"),
    transcription_status: zod
      .enum(["queued", "processing", "done", "error", "not-applicable", "not-started"])
      .describe("The current transcription status"),
    updated_at: zod
      .string()
      .datetime({})
      .regex(getBotStatusResponseDataUpdatedAtRegExp)
      .describe("ISO 8601 timestamp when the status was last updated")
  })
})

/**
 * Retrieve a paginated list of screenshot URLs captured during the meeting.
    
    Screenshots are taken periodically during the meeting and can be used to visualize meeting content. Each screenshot is a presigned URL valid for 4 hours.
    
    **Screenshot Availability:** 
    - Screenshots are only available for Google Meet and Microsoft Teams bots
    - Screenshots are only available for bots with `recording_mode` set to `speaker_view` or `gallery_view`
    - Audio-only recordings do not have screenshots
    - Screenshots are captured at regular intervals during the meeting
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many screenshots are returned per page (default: 50, max: 100).
    
    **URL Expiration:** All screenshot URLs are presigned URLs that expire after 4 hours. If the bot's data has been deleted, this endpoint will return an empty list.
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Get bot screenshots
 */
export const getBotScreenshotsPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getBotScreenshotsParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(getBotScreenshotsPathBotIdRegExp)
    .describe("The UUID of the bot to get screenshots for.")
})

export const getBotScreenshotsQueryLimitDefault = 50
export const getBotScreenshotsQueryLimitMax = 250
export const getBotScreenshotsQueryCursorDefault = null

export const getBotScreenshotsQueryParams = zod.object({
  limit: zod
    .number()
    .max(getBotScreenshotsQueryLimitMax)
    .describe("Maximum number of screenshots to return (default: 50, max: 250)."),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing the screenshot index. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MQ==\" (for index 1) or \"-MTA=\" (for backward pagination from index 10)'
    )
})

export const getBotScreenshotsResponseDataItemScreenshotIdMax = 9007199254740991

export const getBotScreenshotsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      screenshot_id: zod
        .number()
        .max(getBotScreenshotsResponseDataItemScreenshotIdMax)
        .describe("The index of the screenshot (1-based)"),
      url: zod.string().url().describe("Signed URL to the screenshot (valid for 4 hours)")
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Instruct a bot to leave the meeting immediately.
    
    The bot will stop recording and processing, then exit the meeting. Only works if the bot is currently in the meeting (status is `joining_call`, `in_waiting_room`, `in_call_not_recording`, `in_call_recording`, `recording_paused`, or `recording_resumed`). The bot will send a final webhook event when it leaves.
    
    **Status Requirements:** The bot must be in a state that allows leaving. Bots that have already completed, failed, or are not yet in the meeting cannot be left via this endpoint. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Token Consumption:** When a bot is manually left, tokens are consumed based on the duration from when recording started to when the bot left. The bot will transition to `completed` status and send a completion webhook.
    
    **Immediate Effect:** The leave command is sent to the bot process immediately. The bot will stop recording and exit the meeting as soon as it receives the command (usually within a few seconds).
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Leave meeting
 */
export const leaveBotPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const leaveBotParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(leaveBotPathBotIdRegExp)
    .describe("The UUID of the bot to leave the meeting.")
})

export const leaveBotResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Permanently delete all bot data including recordings, transcripts, summaries, and screenshots.
    
    This operation is irreversible. All artifacts (video, audio, transcription, diarization, screenshots) will be permanently deleted. Optionally delete transcription data from the transcription provider as well using the `delete_transcription` query parameter.
    
    **Data Deletion:** 
    - All artifacts (video, audio, transcription, diarization, screenshots) are permanently deleted
    - The `artifacts_deleted` field is set to `true`
    - Artifact URLs will return `null` in subsequent API calls
    - Bot metadata remains accessible but all associated data is removed
    
    **Transcription Provider Deletion:** If `delete_transcription=true` is provided, the transcription data will also be deleted from the transcription provider (e.g., Gladia). This requires the bot to have transcription enabled and a transcription provider configured. If the bot uses BYOK transcription, you must have access to the transcription provider API key.
    
    **Irreversible Operation:** Once data is deleted, it cannot be recovered. Make sure you have downloaded or backed up any data you need before calling this endpoint.
    
    **Status Requirements:** The bot must be in `completed` or `failed` status. Bots that are still in progress (queued, joining, in_call_recording, transcribing) cannot have their data deleted. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Delete bot data
 */
export const deleteBotDataPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteBotDataParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(deleteBotDataPathBotIdRegExp)
    .describe("The UUID of the bot whose data should be deleted.")
})

export const deleteBotDataQueryDeleteFromProviderDefault = true

export const deleteBotDataQueryParams = zod.object({
  delete_from_provider: zod
    .boolean()
    .describe(
      "Whether to delete transcription data from the transcription provider.\n\nIf `true` (default), the transcription data will be deleted from the transcription provider's servers in addition to deleting artifacts from S3. This ensures complete data deletion.\n\nIf `false`, only S3 artifacts will be deleted, and transcription data will remain on the transcription provider's servers.\n\nNote: If the bot was created with a BYOK (Bring Your Own Key) transcription API key, the deletion will use that key to authenticate with the transcription provider.\n\nDefault: `true`"
    )
})

export const deleteBotDataResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Resend the final webhook (completed or failed) for a bot.
    
    Useful if the webhook delivery failed or you need to reprocess the webhook event. The webhook will be sent to all configured webhook endpoints for your account.
    
    **Webhook Delivery:** The webhook will be sent to all configured webhook endpoints for your account. The webhook payload will be identical to the original final webhook (either `bot.completed` or `bot.failed` event).
    
    **Status Requirements:** The bot must be in `completed` or `failed` status. Bots that are still in progress cannot have their final webhook resent. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Use Cases:** 
    - Webhook delivery failed due to network issues
    - Webhook endpoint was temporarily unavailable
    - Need to reprocess a webhook event
    - Testing webhook integration
    
    **Idempotency:** This operation is idempotent. You can call it multiple times, and it will resend the webhook each time. There is no limit on how many times you can resend a webhook.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation.
 * @summary Resend final webhook
 */
export const resendFinalWebhookPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const resendFinalWebhookParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(resendFinalWebhookPathBotIdRegExp)
    .describe(
      "The UUID of the bot to resend the final webhook for.\n\nThis will recreate and resend the `bot.completed` or `bot.failed` webhook to all configured webhook endpoints."
    )
})

export const resendFinalWebhookResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Retry sending the transcription callback for a bot.
    
    You can override the callback configuration (URL, method, secret) if needed. Only works for bots that have completed or failed. The callback will be sent to the provided URL (or the bot's original callback URL if not overridden).
    
    **Callback Configuration:** You can override the callback URL, HTTP method (POST or PUT), and secret in the request body. If not provided, the bot's original callback configuration will be used. The secret will be included in the `x-mb-secret` header for validation.
    
    **Status Requirements:** The bot must be in `completed` or `failed` status and must have had transcription enabled. Bots without transcription or bots that are still in progress cannot have their callback retried. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Callback Payload:** The callback payload will be identical to the original callback (either `bot.completed` or `bot.failed` event with transcription data). The payload format matches the webhook format.
    
    **Use Cases:**
    - Callback delivery failed due to network issues
    - Callback endpoint was temporarily unavailable
    - Need to send callback to a different endpoint
    - Testing callback integration
    
    **Idempotency:** This operation is idempotent. You can call it multiple times with the same or different configurations.
    
    Returns 404 if the bot is not found, or 409 if the bot's status does not allow this operation or if no callback was configured.
 * @summary Retry callback
 */
export const retryCallbackPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const retryCallbackParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(retryCallbackPathBotIdRegExp)
    .describe(
      "The UUID of the bot to retry the callback for.\n\nThis will recreate and resend the callback payload to the configured callback URL (or a custom URL if provided in the request body)."
    )
})

export const retryCallbackBodyDefault = null
export const retryCallbackBodySecretDefault = null
export const retryCallbackBodyMethodDefault = "POST"

export const retryCallbackBody = zod
  .object({
    url: zod
      .string()
      .url()
      .describe("The URL to be called upon the completion or failure of the bot."),
    secret: zod
      .string()
      .or(zod.null())
      .optional()
      .describe(
        "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
      ),
    method: zod
      .enum(["POST", "PUT"])
      .default(retryCallbackBodyMethodDefault)
      .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
  })
  .or(zod.null())
  .describe(
    "Optional callback configuration to override the bot's configured callback.\n\nIf provided, all fields must be included and these values will be used instead of the bot's original callback configuration. If omitted (null), the bot's original callback configuration will be used.\n\n- `url`: Custom callback URL (overrides configured URL)\n- `method`: HTTP method (`POST` or `PUT`, default: `POST`)\n- `secret`: Custom HMAC secret (overrides configured secret, sent in `x-mb-secret` header)"
  )

export const retryCallbackResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Update bot configuration (currently only supports updating the extra parameter).
    
    Allows updating the `extra` metadata even while the bot is running. The updated extra will be reflected in subsequent webhooks and API responses. This is useful when your system evolves and you need to attach additional tracking information to a bot after it has started.
    
    **Merge Behavior:** The `extra` parameter performs a shallow merge with the existing extra object:
    - New keys are added to the existing extra object
    - Existing keys are overwritten with new values
    - Keys not included in the update request remain unchanged
    - Pass `null` to clear all extra data
    
    **Example Merge:**
    - Current extra: `{ "customer_id": "123", "session_id": "abc" }`
    - Update with: `{ "session_id": "xyz", "order_id": "456" }`
    - Result: `{ "customer_id": "123", "session_id": "xyz", "order_id": "456" }`
    
    **Webhook Behavior:** After updating extra, all future webhooks (including status updates) will use the new value from the database. The updated extra is fetched in real-time for each webhook, ensuring consistency.
    
    **Works for Any Bot Status:** You can update extra for bots in any status (queued, recording, completed, failed). This allows you to add correlation metadata even after a bot has finished.
    
    **Use Cases:**
    - Add tracking IDs after bot creation
    - Update correlation metadata when your system state changes
    - Fix incorrect tracking information
    - Add additional context for completed bots
    
    Returns 404 if the bot is not found or does not belong to your team.
 * @summary Update bot configuration
 */
export const updateBotConfigPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const updateBotConfigParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(updateBotConfigPathBotIdRegExp)
    .describe("The UUID of the bot to update configuration for.")
})

export const updateBotConfigBody = zod.object({
  extra: zod
    .record(zod.string(), zod.any())
    .or(zod.null())
    .describe("Custom metadata to merge with existing extra data (shallow merge)")
})

export const updateBotConfigResponse = zod.object({
  success: zod.literal(true),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Schedule a bot to join a meeting at a specific time in the future.
    
    The bot will automatically join the meeting at the specified `join_at` time (ISO 8601 timestamp). You can provide a callback URL to receive events for this bot. The bot configuration is stored immediately, but token reservation and daily bot cap checks are performed when the bot actually joins the meeting.
    
    **Scheduling:** The `join_at` timestamp must be in the future (at least 1 minute ahead). The bot will automatically attempt to join the meeting at the specified time. There may be a small processing delay (typically less than a minute).
    
    **Token Reservation:** Tokens are NOT reserved at creation time. Token availability and daily bot cap are checked when the bot actually joins the meeting. If tokens are insufficient or the daily cap is reached at join time, the bot will fail with an appropriate error and transition to `failed` status.
    
    **Deduplication:** Deduplication is checked when the bot joins, not at creation time. This means you can schedule multiple bots for the same meeting URL, but only one will successfully join (unless `allow_multiple_bots` is true).
    
    **Status:** The scheduled bot starts in `scheduled` status and transitions to `completed` when the bot instance is created and queued to join. If the bot fails to join, it transitions to `failed` status.
    
    **Updates and Deletions:** Scheduled bots can be updated or deleted as long as they are in `scheduled` status and the join time is at least 4 minutes in the future. This ensures the bot can be modified before it starts processing.
    
    Returns a `bot_id` (UUID) that you can use to track and manage the scheduled bot. This UUID will be reused as the bot's UUID when it actually joins.
 * @summary Create scheduled bot
 */
export const createScheduledBotBodyBotNameMax = 255
export const createScheduledBotBodyBotImageDefault = null
export const createScheduledBotBodyAllowMultipleBotsDefault = true
export const createScheduledBotBodyRecordingModeDefault = "speaker_view"
export const createScheduledBotBodyEntryMessageMaxOne = 500
export const createScheduledBotBodyEntryMessageDefault = null
export const createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const createScheduledBotBodyTimeoutConfigSilenceTimeoutDefault = 600
export const createScheduledBotBodyTimeoutConfigSilenceTimeoutMin = 300

export const createScheduledBotBodyTimeoutConfigSilenceTimeoutMax = 1800
export const createScheduledBotBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const createScheduledBotBodyZoomAccessTokenUrlDefault = null
export const createScheduledBotBodyExtraDefault = null
export const createScheduledBotBodyStreamingEnabledDefault = false
export const createScheduledBotBodyStreamingConfigInputUrlDefault = null
export const createScheduledBotBodyStreamingConfigOutputUrlDefault = null
export const createScheduledBotBodyStreamingConfigAudioFrequencyDefault = 24000
export const createScheduledBotBodyStreamingConfigDefault = null
export const createScheduledBotBodyTranscriptionEnabledDefault = false
export const createScheduledBotBodyTranscriptionConfigProviderDefault = "gladia"
export const createScheduledBotBodyTranscriptionConfigApiKeyDefault = null
export const createScheduledBotBodyTranscriptionConfigCustomParamsDefault = null
export const createScheduledBotBodyTranscriptionConfigDefault = null
export const createScheduledBotBodyCallbackEnabledDefault = false
export const createScheduledBotBodyCallbackConfigSecretDefault = null
export const createScheduledBotBodyCallbackConfigMethodDefault = "POST"
export const createScheduledBotBodyCallbackConfigDefault = null
export const createScheduledBotBodyJoinAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const createScheduledBotBody = zod
  .object({
    bot_name: zod
      .string()
      .min(1)
      .max(createScheduledBotBodyBotNameMax)
      .describe(
        "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
      ),
    bot_image: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
      ),
    meeting_url: zod
      .string()
      .url()
      .describe(
        'The URL of the meeting to join.\n\nMust be a valid HTTPS URL for a Microsoft Teams, Google Meet, or Zoom meeting.\n\nExample: \"https://zoom.us/j/123456789\" or \"https://meet.google.com/abc-defg-hij\"'
      ),
    allow_multiple_bots: zod
      .boolean()
      .default(createScheduledBotBodyAllowMultipleBotsDefault)
      .describe(
        "Whether to allow multiple bots to join the same meeting.\n\nIf set to `false`, only a single bot will be allowed to join using the same meeting URL within the last 5 minutes. This prevents duplicate bots from joining the same meeting.\n\nIf set to `true` (default), multiple bots can join the same meeting URL.\n\nDefault: `true`"
      ),
    recording_mode: zod
      .enum(["audio_only", "speaker_view", "gallery_view"])
      .default(createScheduledBotBodyRecordingModeDefault)
      .describe(
        "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
      ),
    entry_message: zod
      .string()
      .max(createScheduledBotBodyEntryMessageMaxOne)
      .or(zod.null())
      .optional()
      .describe(
        "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
      ),
    timeout_config: zod
      .object({
        waiting_room_timeout: zod
          .number()
          .min(createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMin)
          .max(createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMax)
          .default(createScheduledBotBodyTimeoutConfigWaitingRoomTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        no_one_joined_timeout: zod
          .number()
          .min(createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMin)
          .max(createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMax)
          .default(createScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        silence_timeout: zod
          .number()
          .min(createScheduledBotBodyTimeoutConfigSilenceTimeoutMin)
          .max(createScheduledBotBodyTimeoutConfigSilenceTimeoutMax)
          .default(createScheduledBotBodyTimeoutConfigSilenceTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
          )
      })
      .default(createScheduledBotBodyTimeoutConfigDefault)
      .describe(
        "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
      ),
    zoom_access_token_url: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
      ),
    extra: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .optional()
      .describe(
        "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
      ),
    streaming_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
      ),
    streaming_config: zod
      .object({
        input_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
          ),
        output_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
          ),
        audio_frequency: zod
          .number()
          .or(zod.number())
          .or(zod.number())
          .or(zod.number())
          .describe(
            "Audio frequency in Hz. Supported values: 16000, 24000 (default), 32000, 48000 Hz."
          )
          .or(zod.null())
          .default(createScheduledBotBodyStreamingConfigAudioFrequencyDefault)
          .describe(
            "The audio frequency in Hz. Supported values: 24000 (default), 32000, 48000 Hz."
          )
      })
      .or(zod.null())
      .optional(),
    transcription_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
      ),
    transcription_config: zod
      .object({
        provider: zod
          .enum(["gladia"])
          .default(createScheduledBotBodyTranscriptionConfigProviderDefault)
          .describe(
            "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
          ),
        api_key: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
          ),
        custom_params: zod
          .record(zod.string(), zod.any())
          .or(zod.null())
          .optional()
          .describe(
            "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
          )
      })
      .or(zod.null())
      .optional(),
    callback_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
      ),
    callback_config: zod
      .object({
        url: zod
          .string()
          .url()
          .describe("The URL to be called upon the completion or failure of the bot."),
        secret: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
          ),
        method: zod
          .enum(["POST", "PUT"])
          .default(createScheduledBotBodyCallbackConfigMethodDefault)
          .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
      })
      .or(zod.null())
      .optional()
  })
  .and(
    zod.object({
      join_at: zod
        .string()
        .datetime({})
        .regex(createScheduledBotBodyJoinAtRegExp)
        .describe(
          'ISO8601 timestamp when the bot should join the meeting.\n\nCannot be in the past (with 1 minute leeway) and cannot be more than 90 days in the future.\n\nExample: \"2025-12-25T10:00:00Z\"'
        )
    })
  )

/**
 * Retrieve a paginated list of scheduled bots.
    
    Supports filtering by status (`scheduled`, `completed`, `failed`) and date range. Results are ordered by scheduled join time (earliest first). Use cursor-based pagination for efficient navigation.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many results are returned per page (default: 20, max: 100).
    
    **Filtering:**
    - `status`: Filter by scheduled bot status (comma-separated for multiple statuses)
    - `scheduled_after`: ISO 8601 timestamp - only return bots scheduled to join after this time
    - `scheduled_before`: ISO 8601 timestamp - only return bots scheduled to join before this time
    
    **Status Values:**
    - `scheduled`: Bot is scheduled but has not yet joined
    - `completed`: Bot instance was created and queued to join (bot may still be joining)
    - `failed`: Bot failed to join (token issues, daily cap, etc.)
    
    Returns a paginated list of scheduled bots with metadata including bot ID, scheduled join time, status, and basic configuration.
 * @summary List scheduled bots
 */
export const listScheduledBotsQueryLimitDefault = 50
export const listScheduledBotsQueryLimitMax = 100
export const listScheduledBotsQueryCursorDefault = null
export const listScheduledBotsQueryBotIdDefault = null
export const listScheduledBotsQueryScheduledBeforeRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listScheduledBotsQueryScheduledBeforeDefault = null
export const listScheduledBotsQueryScheduledAfterRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listScheduledBotsQueryScheduledAfterDefault = null
export const listScheduledBotsQueryBotNameDefault = null
export const listScheduledBotsQueryMeetingUrlDefault = null

export const listScheduledBotsQueryParams = zod.object({
  limit: zod
    .number()
    .max(listScheduledBotsQueryLimitMax)
    .describe(
      "Maximum number of scheduled bots to return in a single request.\n\nLimits the number of results returned in a single API call.\n\nDefault: 50 Minimum: 1 Maximum: 100"
    ),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing `<isoDate>::<id>`. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MjAyNS0wMS0xNVQxMDozMDowMFo6OjEyMzQ1\" or \"LU1qQXlOM1UxTmpVME5qVXhNakUwTkRrPQ==\" (for backward pagination)'
    ),
  bot_id: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      "Filter scheduled bots by UUID (partial match, case-insensitive).\n\nUse this to find a scheduled bot when you only know part of the identifier."
    ),
  scheduled_before: zod
    .string()
    .datetime({})
    .regex(listScheduledBotsQueryScheduledBeforeRegExpOne)
    .or(zod.null())
    .optional()
    .describe(
      'Filter scheduled bots with join_at before this timestamp.\n\nReturns only scheduled bots that are scheduled to join before the specified date.\n\nISO 8601 format. Must be within ¬±90 days from today.\n\nExample: \"2025-12-25T10:00:00Z\"'
    ),
  scheduled_after: zod
    .string()
    .datetime({})
    .regex(listScheduledBotsQueryScheduledAfterRegExpOne)
    .or(zod.null())
    .optional()
    .describe(
      'Filter scheduled bots with join_at after this timestamp.\n\nReturns only scheduled bots that are scheduled to join after the specified date.\n\nISO 8601 format. Must be within ¬±90 days from today.\n\nExample: \"2025-12-25T10:00:00Z\"'
    ),
  status: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter by scheduled bot status.\n\nReturns only scheduled bots with the specified status(es).\n\nAvailable statuses:\n- scheduled: Bot is scheduled to join at a future time\n- cancelled: Bot schedule was cancelled\n- completed: Bot has completed its scheduled task\n- failed: Bot failed to execute its scheduled task\n\nTo filter multiple statuses, use a comma-separated list of values. For example, \"scheduled,completed\" would match all bots that are scheduled or completed.'
    ),
  bot_name: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by name containing this string.\n\nPerforms a case-insensitive partial match on the bot\'s name. Useful for finding bots with specific naming conventions or to locate a particular bot when you don\'t have its ID.\n\nExample: \"Sales\" would match \"Sales Meeting\", \"Quarterly Sales\", etc.'
    ),
  meeting_url: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter bots by meeting URL containing this string.\n\nPerforms a case-insensitive partial match on the bot\'s meeting URL. Useful for finding bots associated with specific meeting platforms or particular meeting IDs.\n\nExample: \"zoom.us\" would match all Zoom meetings'
    ),
  meeting_platform: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter by meeting platform.\n\nThis parameter filters scheduled bots by the platform they are associated with. It can be used to find bots that are associated with a specific meeting platform. Valid values are: \"zoom\", \"meet\", \"teams\".\n\nExample: \"zoom\" would match all bots associated with Zoom meetings.\n\nTo filter multiple platforms, use a comma-separated list of values. For example, \"zoom,meet\" would match all bots associated with Zoom or Meet meetings.'
    )
})

export const listScheduledBotsResponseDataItemBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listScheduledBotsResponseDataItemJoinAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listScheduledBotsResponseDataItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listScheduledBotsResponseDataItemUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const listScheduledBotsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      bot_id: zod
        .string()
        .uuid()
        .regex(listScheduledBotsResponseDataItemBotIdRegExp)
        .describe("The UUID of the scheduled bot"),
      bot_name: zod.string().describe("The name of the scheduled bot"),
      meeting_url: zod.string().describe("The URL of the meeting"),
      meeting_platform: zod.enum(["zoom", "meet", "teams"]).describe("The platform of the meeting"),
      join_at: zod
        .string()
        .datetime({})
        .regex(listScheduledBotsResponseDataItemJoinAtRegExp)
        .describe("ISO 8601 timestamp when the bot should join the meeting"),
      status: zod
        .enum(["scheduled", "cancelled", "completed", "failed"])
        .describe("The current status of the scheduled bot"),
      extra: zod
        .record(zod.string(), zod.any())
        .or(zod.null())
        .describe("Custom metadata associated with the scheduled bot"),
      created_at: zod
        .string()
        .datetime({})
        .regex(listScheduledBotsResponseDataItemCreatedAtRegExp)
        .describe("ISO 8601 timestamp when the scheduled bot was created"),
      updated_at: zod
        .string()
        .datetime({})
        .regex(listScheduledBotsResponseDataItemUpdatedAtRegExp)
        .describe("ISO 8601 timestamp when the scheduled bot was last updated")
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Create multiple scheduled bots in a single request with partial success support.
    
    Processes each scheduled bot creation request sequentially. Each item is validated and processed independently. Token reservation and daily bot cap checks are NOT performed at creation time - they are performed when each bot actually joins the meeting.
    
    **Processing Order:** Items are processed in the order they appear in the request array. Each item goes through validation: platform detection, BYOK transcription check, and join time validation. Unlike immediate bot creation, daily bot cap and token availability are not checked at creation time.
    
    **Partial Success:** The response always has `success: true`, even if all items fail. Check the `errors` array to identify failed items. The `data` array contains successfully scheduled bots with their `bot_id` and preserved `extra` metadata.
    
    **Join Time Validation:** Each scheduled bot's `join_at` time must be in the future (at least 1 minute ahead). If a join time is invalid, that item will fail with a validation error, but other items will continue processing.
    
    **Error Scenarios:** 
    - Validation errors: Invalid join time, invalid meeting URL, invalid configuration
    - Platform detection failures: `INVALID_MEETING_PLATFORM`
    - BYOK not enabled: `BYOK_TRANSCRIPTION_NOT_ENABLED_ON_PLAN`
    - System failures: `BOT_CREATE_FAILED`
    
    **Note:** Daily bot cap and token availability are checked when each bot joins, not at creation time. If these checks fail at join time, the bot will transition to `failed` status and send a failure webhook.
    
    Returns 201 with partial success response. All items may succeed, all may fail, or any combination.
 * @summary Create multiple scheduled bots
 */
export const batchCreateScheduledBotsBodyBotNameMax = 255
export const batchCreateScheduledBotsBodyBotImageDefault = null
export const batchCreateScheduledBotsBodyAllowMultipleBotsDefault = true
export const batchCreateScheduledBotsBodyRecordingModeDefault = "speaker_view"
export const batchCreateScheduledBotsBodyEntryMessageMaxOne = 500
export const batchCreateScheduledBotsBodyEntryMessageDefault = null
export const batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutDefault = 600
export const batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutMin = 300

export const batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutMax = 1800
export const batchCreateScheduledBotsBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const batchCreateScheduledBotsBodyZoomAccessTokenUrlDefault = null
export const batchCreateScheduledBotsBodyExtraDefault = null
export const batchCreateScheduledBotsBodyStreamingEnabledDefault = false
export const batchCreateScheduledBotsBodyStreamingConfigInputUrlDefault = null
export const batchCreateScheduledBotsBodyStreamingConfigOutputUrlDefault = null
export const batchCreateScheduledBotsBodyStreamingConfigAudioFrequencyDefault = 24000
export const batchCreateScheduledBotsBodyStreamingConfigDefault = null
export const batchCreateScheduledBotsBodyTranscriptionEnabledDefault = false
export const batchCreateScheduledBotsBodyTranscriptionConfigProviderDefault = "gladia"
export const batchCreateScheduledBotsBodyTranscriptionConfigApiKeyDefault = null
export const batchCreateScheduledBotsBodyTranscriptionConfigCustomParamsDefault = null
export const batchCreateScheduledBotsBodyTranscriptionConfigDefault = null
export const batchCreateScheduledBotsBodyCallbackEnabledDefault = false
export const batchCreateScheduledBotsBodyCallbackConfigSecretDefault = null
export const batchCreateScheduledBotsBodyCallbackConfigMethodDefault = "POST"
export const batchCreateScheduledBotsBodyCallbackConfigDefault = null
export const batchCreateScheduledBotsBodyJoinAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const batchCreateScheduledBotsBodyItem = zod
  .object({
    bot_name: zod
      .string()
      .min(1)
      .max(batchCreateScheduledBotsBodyBotNameMax)
      .describe(
        "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
      ),
    bot_image: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
      ),
    meeting_url: zod
      .string()
      .url()
      .describe(
        'The URL of the meeting to join.\n\nMust be a valid HTTPS URL for a Microsoft Teams, Google Meet, or Zoom meeting.\n\nExample: \"https://zoom.us/j/123456789\" or \"https://meet.google.com/abc-defg-hij\"'
      ),
    allow_multiple_bots: zod
      .boolean()
      .default(batchCreateScheduledBotsBodyAllowMultipleBotsDefault)
      .describe(
        "Whether to allow multiple bots to join the same meeting.\n\nIf set to `false`, only a single bot will be allowed to join using the same meeting URL within the last 5 minutes. This prevents duplicate bots from joining the same meeting.\n\nIf set to `true` (default), multiple bots can join the same meeting URL.\n\nDefault: `true`"
      ),
    recording_mode: zod
      .enum(["audio_only", "speaker_view", "gallery_view"])
      .default(batchCreateScheduledBotsBodyRecordingModeDefault)
      .describe(
        "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
      ),
    entry_message: zod
      .string()
      .max(batchCreateScheduledBotsBodyEntryMessageMaxOne)
      .or(zod.null())
      .optional()
      .describe(
        "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
      ),
    timeout_config: zod
      .object({
        waiting_room_timeout: zod
          .number()
          .min(batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutMin)
          .max(batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutMax)
          .default(batchCreateScheduledBotsBodyTimeoutConfigWaitingRoomTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        no_one_joined_timeout: zod
          .number()
          .min(batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutMin)
          .max(batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutMax)
          .default(batchCreateScheduledBotsBodyTimeoutConfigNoOneJoinedTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        silence_timeout: zod
          .number()
          .min(batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutMin)
          .max(batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutMax)
          .default(batchCreateScheduledBotsBodyTimeoutConfigSilenceTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
          )
      })
      .default(batchCreateScheduledBotsBodyTimeoutConfigDefault)
      .describe(
        "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
      ),
    zoom_access_token_url: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
      ),
    extra: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .optional()
      .describe(
        "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
      ),
    streaming_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
      ),
    streaming_config: zod
      .object({
        input_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
          ),
        output_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
          ),
        audio_frequency: zod
          .number()
          .or(zod.number())
          .or(zod.number())
          .or(zod.number())
          .describe(
            "Audio frequency in Hz. Supported values: 16000, 24000 (default), 32000, 48000 Hz."
          )
          .or(zod.null())
          .default(batchCreateScheduledBotsBodyStreamingConfigAudioFrequencyDefault)
          .describe(
            "The audio frequency in Hz. Supported values: 24000 (default), 32000, 48000 Hz."
          )
      })
      .or(zod.null())
      .optional(),
    transcription_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
      ),
    transcription_config: zod
      .object({
        provider: zod
          .enum(["gladia"])
          .default(batchCreateScheduledBotsBodyTranscriptionConfigProviderDefault)
          .describe(
            "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
          ),
        api_key: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
          ),
        custom_params: zod
          .record(zod.string(), zod.any())
          .or(zod.null())
          .optional()
          .describe(
            "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
          )
      })
      .or(zod.null())
      .optional(),
    callback_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
      ),
    callback_config: zod
      .object({
        url: zod
          .string()
          .url()
          .describe("The URL to be called upon the completion or failure of the bot."),
        secret: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
          ),
        method: zod
          .enum(["POST", "PUT"])
          .default(batchCreateScheduledBotsBodyCallbackConfigMethodDefault)
          .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
      })
      .or(zod.null())
      .optional()
  })
  .and(
    zod.object({
      join_at: zod
        .string()
        .datetime({})
        .regex(batchCreateScheduledBotsBodyJoinAtRegExp)
        .describe(
          'ISO8601 timestamp when the bot should join the meeting.\n\nCannot be in the past (with 1 minute leeway) and cannot be more than 90 days in the future.\n\nExample: \"2025-12-25T10:00:00Z\"'
        )
    })
  )
export const batchCreateScheduledBotsBody = zod
  .array(batchCreateScheduledBotsBodyItem)
  .min(1)
  .max(100)

/**
 * Retrieve detailed information about a specific scheduled bot.
    
    Returns the scheduled bot's configuration, scheduled join time, current status, and associated bot instance (if the bot has already joined). Includes all the same configuration options as immediate bot creation.
    
    **Status Information:** The response includes the scheduled bot's current status (`scheduled`, `completed`, or `failed`) and when the status was last updated. If the bot has joined, the response includes a link to the actual bot instance.
    
    **Scheduled Join Time:** The `join_at` field contains the ISO 8601 timestamp when the bot is scheduled to join the meeting.
    
    **Bot Instance:** If the scheduled bot has transitioned to `completed` status, the bot instance has been created and is queued to join. You can use the `bot_id` (which will be reused as the bot's UUID when it joins) to query the bot's status and retrieve meeting data once it has joined.
    
    **Updates and Deletions:** If the bot is in `scheduled` status and the join time is at least 4 minutes in the future, you can update or delete the scheduled bot. This ensures the bot can be modified before it starts processing.
    
    Returns 404 if the scheduled bot is not found or does not belong to your team.
 * @summary Get scheduled bot details
 */
export const getScheduledBotDetailsPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getScheduledBotDetailsParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(getScheduledBotDetailsPathBotIdRegExp)
    .describe("The UUID of the scheduled bot to get details for.")
})

export const getScheduledBotDetailsResponseDataBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getScheduledBotDetailsResponseDataJoinAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getScheduledBotDetailsResponseDataCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getScheduledBotDetailsResponseDataUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getScheduledBotDetailsResponseDataCancelledAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getScheduledBotDetailsResponseDataTimeoutConfigWaitingRoomTimeoutMinOne =
  -9007199254740991
export const getScheduledBotDetailsResponseDataTimeoutConfigWaitingRoomTimeoutMaxOne = 9007199254740991
export const getScheduledBotDetailsResponseDataTimeoutConfigNoOneJoinedTimeoutMinOne =
  -9007199254740991
export const getScheduledBotDetailsResponseDataTimeoutConfigNoOneJoinedTimeoutMaxOne = 9007199254740991
export const getScheduledBotDetailsResponseDataStreamingConfigAudioFrequencyMinOne =
  -9007199254740991
export const getScheduledBotDetailsResponseDataStreamingConfigAudioFrequencyMaxOne = 9007199254740991

export const getScheduledBotDetailsResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    bot_id: zod
      .string()
      .uuid()
      .regex(getScheduledBotDetailsResponseDataBotIdRegExp)
      .describe("The UUID of the scheduled bot"),
    bot_name: zod.string().describe("The name of the scheduled bot"),
    bot_image: zod.string().or(zod.null()).describe("The image URL for the bot (null if not set)"),
    meeting_url: zod.string().describe("The URL of the meeting"),
    meeting_platform: zod.enum(["zoom", "meet", "teams"]).describe("The platform of the meeting"),
    recording_mode: zod
      .enum(["audio_only", "speaker_view", "gallery_view"])
      .describe("The recording mode for the bot"),
    join_at: zod
      .string()
      .datetime({})
      .regex(getScheduledBotDetailsResponseDataJoinAtRegExp)
      .describe("ISO 8601 timestamp when the bot should join the meeting"),
    status: zod
      .enum(["scheduled", "cancelled", "completed", "failed"])
      .describe("The current status of the scheduled bot"),
    created_at: zod
      .string()
      .datetime({})
      .regex(getScheduledBotDetailsResponseDataCreatedAtRegExp)
      .describe("ISO 8601 timestamp when the scheduled bot was created"),
    updated_at: zod
      .string()
      .datetime({})
      .regex(getScheduledBotDetailsResponseDataUpdatedAtRegExp)
      .describe("ISO 8601 timestamp when the scheduled bot was last updated"),
    cancelled_at: zod
      .string()
      .datetime({})
      .regex(getScheduledBotDetailsResponseDataCancelledAtRegExpOne)
      .or(zod.null())
      .describe("ISO 8601 timestamp when the scheduled bot was cancelled (null if not cancelled)"),
    allow_multiple_bots: zod.boolean().describe("Whether multiple bots are allowed in the meeting"),
    entry_message: zod
      .string()
      .or(zod.null())
      .describe("Custom message to send when bot joins (null if not set)"),
    timeout_config: zod.object({
      waiting_room_timeout: zod
        .number()
        .min(getScheduledBotDetailsResponseDataTimeoutConfigWaitingRoomTimeoutMinOne)
        .max(getScheduledBotDetailsResponseDataTimeoutConfigWaitingRoomTimeoutMaxOne)
        .or(zod.null())
        .describe("Timeout in seconds for waiting room (null if not set)"),
      no_one_joined_timeout: zod
        .number()
        .min(getScheduledBotDetailsResponseDataTimeoutConfigNoOneJoinedTimeoutMinOne)
        .max(getScheduledBotDetailsResponseDataTimeoutConfigNoOneJoinedTimeoutMaxOne)
        .or(zod.null())
        .describe("Timeout in seconds if no one joins (null if not set)")
    }),
    transcription_config: zod
      .object({
        enabled: zod.boolean(),
        provider: zod.enum(["gladia"]),
        custom_params: zod
          .record(zod.string(), zod.any())
          .or(zod.null())
          .describe("Custom parameters for transcription (null if not set)")
      })
      .or(zod.null())
      .describe("Transcription configuration (null if transcription is disabled)"),
    streaming_config: zod
      .object({
        enabled: zod.boolean(),
        input_url: zod
          .string()
          .or(zod.null())
          .describe("Websocket URL for receiving audio (null if not set)"),
        output_url: zod
          .string()
          .or(zod.null())
          .describe("Websocket URL for sending audio (null if not set)"),
        audio_frequency: zod
          .number()
          .min(getScheduledBotDetailsResponseDataStreamingConfigAudioFrequencyMinOne)
          .max(getScheduledBotDetailsResponseDataStreamingConfigAudioFrequencyMaxOne)
          .or(zod.null())
          .describe(
            "Audio frequency in Hz (null if not set). Supported values: 16000, 24000 (default), 32000, 48000 Hz."
          )
      })
      .or(zod.null())
      .describe("Streaming configuration (null if streaming is disabled)"),
    callback_config: zod
      .object({
        enabled: zod.boolean(),
        url: zod.string().describe("Callback URL"),
        secret: zod
          .string()
          .or(zod.null())
          .describe("Secret for validating callbacks (null if not set)"),
        method: zod.enum(["POST", "PUT"]).describe("HTTP method for callback")
      })
      .or(zod.null())
      .describe("Callback configuration (null if callback is disabled)"),
    extra: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .describe("Custom metadata associated with the scheduled bot")
  })
})

/**
 * Update a scheduled bot's configuration or scheduled join time.
    
    The bot must be in `scheduled` status and the join time must be at least 4 minutes in the future. This ensures the bot can be updated before it starts processing.
    
    **Updateable Fields:** You can update any configuration field (bot name, image, recording mode, transcription settings, etc.) and the scheduled join time (`join_at`). All fields are optional - only provided fields will be updated.
    
    **Join Time Requirements:** 
    - The new `join_at` time must be in the future
    - The bot must be in `scheduled` status
    - The join time must be at least 4 minutes in the future (lock window)
    - If the join time is too close, the request will fail with 409 Conflict
    
    **Status Requirements:** The bot must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be updated. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Validation:** All updated fields are validated using the same rules as bot creation. Invalid configurations will result in a 400 Bad Request error.
    
    Returns 404 if the scheduled bot is not found, or 409 if the bot's status does not allow update or the join time is too close.
 * @summary Update scheduled bot
 */
export const updateScheduledBotPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const updateScheduledBotParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(updateScheduledBotPathBotIdRegExp)
    .describe(
      'The UUID of the scheduled bot to update.\n\nThis is the unique identifier returned when creating a scheduled bot.\n\nExample: \"123e4567-e89b-12d3-a456-426614174000\"'
    )
})

export const updateScheduledBotBodyBotNameMax = 255
export const updateScheduledBotBodyBotImageDefault = null
export const updateScheduledBotBodyAllowMultipleBotsDefault = true
export const updateScheduledBotBodyRecordingModeDefault = "speaker_view"
export const updateScheduledBotBodyEntryMessageMaxOne = 500
export const updateScheduledBotBodyEntryMessageDefault = null
export const updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const updateScheduledBotBodyTimeoutConfigSilenceTimeoutDefault = 600
export const updateScheduledBotBodyTimeoutConfigSilenceTimeoutMin = 300

export const updateScheduledBotBodyTimeoutConfigSilenceTimeoutMax = 1800
export const updateScheduledBotBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const updateScheduledBotBodyZoomAccessTokenUrlDefault = null
export const updateScheduledBotBodyExtraDefault = null
export const updateScheduledBotBodyStreamingEnabledDefault = false
export const updateScheduledBotBodyStreamingConfigInputUrlDefault = null
export const updateScheduledBotBodyStreamingConfigOutputUrlDefault = null
export const updateScheduledBotBodyStreamingConfigAudioFrequencyDefault = 24000
export const updateScheduledBotBodyStreamingConfigDefault = null
export const updateScheduledBotBodyTranscriptionEnabledDefault = false
export const updateScheduledBotBodyTranscriptionConfigProviderDefault = "gladia"
export const updateScheduledBotBodyTranscriptionConfigApiKeyDefault = null
export const updateScheduledBotBodyTranscriptionConfigCustomParamsDefault = null
export const updateScheduledBotBodyTranscriptionConfigDefault = null
export const updateScheduledBotBodyCallbackEnabledDefault = false
export const updateScheduledBotBodyCallbackConfigSecretDefault = null
export const updateScheduledBotBodyCallbackConfigMethodDefault = "POST"
export const updateScheduledBotBodyCallbackConfigDefault = null
export const updateScheduledBotBodyJoinAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const updateScheduledBotBody = zod.object({
  bot_name: zod
    .string()
    .min(1)
    .max(updateScheduledBotBodyBotNameMax)
    .optional()
    .describe(
      "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
    ),
  bot_image: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
    ),
  meeting_url: zod
    .string()
    .url()
    .optional()
    .describe(
      'The URL of the meeting to join.\n\nMust be a valid HTTPS URL for a Microsoft Teams, Google Meet, or Zoom meeting.\n\nExample: \"https://zoom.us/j/123456789\" or \"https://meet.google.com/abc-defg-hij\"'
    ),
  allow_multiple_bots: zod
    .boolean()
    .default(updateScheduledBotBodyAllowMultipleBotsDefault)
    .describe(
      "Whether to allow multiple bots to join the same meeting.\n\nIf set to `false`, only a single bot will be allowed to join using the same meeting URL within the last 5 minutes. This prevents duplicate bots from joining the same meeting.\n\nIf set to `true` (default), multiple bots can join the same meeting URL.\n\nDefault: `true`"
    ),
  recording_mode: zod
    .enum(["audio_only", "speaker_view", "gallery_view"])
    .default(updateScheduledBotBodyRecordingModeDefault)
    .describe(
      "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
    ),
  entry_message: zod
    .string()
    .max(updateScheduledBotBodyEntryMessageMaxOne)
    .or(zod.null())
    .optional()
    .describe(
      "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
    ),
  timeout_config: zod
    .object({
      waiting_room_timeout: zod
        .number()
        .min(updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMin)
        .max(updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutMax)
        .default(updateScheduledBotBodyTimeoutConfigWaitingRoomTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      no_one_joined_timeout: zod
        .number()
        .min(updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMin)
        .max(updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutMax)
        .default(updateScheduledBotBodyTimeoutConfigNoOneJoinedTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
        ),
      silence_timeout: zod
        .number()
        .min(updateScheduledBotBodyTimeoutConfigSilenceTimeoutMin)
        .max(updateScheduledBotBodyTimeoutConfigSilenceTimeoutMax)
        .default(updateScheduledBotBodyTimeoutConfigSilenceTimeoutDefault)
        .describe(
          "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
        )
    })
    .default(updateScheduledBotBodyTimeoutConfigDefault)
    .describe(
      "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
    ),
  zoom_access_token_url: zod
    .string()
    .url()
    .or(zod.null())
    .optional()
    .describe(
      'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
    ),
  extra: zod
    .record(zod.string(), zod.any())
    .or(zod.null())
    .optional()
    .describe(
      "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
    ),
  streaming_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
    ),
  streaming_config: zod
    .object({
      input_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
        ),
      output_url: zod
        .string()
        .url()
        .or(zod.null())
        .optional()
        .describe(
          "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
        ),
      audio_frequency: zod
        .number()
        .or(zod.number())
        .or(zod.number())
        .or(zod.number())
        .describe(
          "Audio frequency in Hz. Supported values: 16000, 24000 (default), 32000, 48000 Hz."
        )
        .or(zod.null())
        .default(updateScheduledBotBodyStreamingConfigAudioFrequencyDefault)
        .describe("The audio frequency in Hz. Supported values: 24000 (default), 32000, 48000 Hz.")
    })
    .or(zod.null())
    .optional(),
  transcription_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
    ),
  transcription_config: zod
    .object({
      provider: zod
        .enum(["gladia"])
        .default(updateScheduledBotBodyTranscriptionConfigProviderDefault)
        .describe(
          "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
        ),
      api_key: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
        ),
      custom_params: zod
        .record(zod.string(), zod.any())
        .or(zod.null())
        .optional()
        .describe(
          "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
        )
    })
    .or(zod.null())
    .optional(),
  callback_enabled: zod
    .boolean()
    .optional()
    .describe(
      "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
    ),
  callback_config: zod
    .object({
      url: zod
        .string()
        .url()
        .describe("The URL to be called upon the completion or failure of the bot."),
      secret: zod
        .string()
        .or(zod.null())
        .optional()
        .describe(
          "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
        ),
      method: zod
        .enum(["POST", "PUT"])
        .default(updateScheduledBotBodyCallbackConfigMethodDefault)
        .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
    })
    .or(zod.null())
    .optional(),
  join_at: zod
    .string()
    .datetime({})
    .regex(updateScheduledBotBodyJoinAtRegExp)
    .optional()
    .describe(
      'Update the scheduled join time.\n\nISO8601 format. Must be at least 4 minutes in the future and cannot be more than 90 days in the future.\n\nExample: \"2025-12-25T10:00:00Z\"'
    )
})

export const updateScheduledBotResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})

/**
 * Cancel and delete a scheduled bot.
    
    The bot must be in `scheduled` status and the join time must be at least 4 minutes in the future. This ensures the bot can be updated before it starts processing. Once deleted, the scheduled bot cannot be recovered.
    
    **Status Requirements:** The bot must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be deleted via this endpoint. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Join Time Requirements:** The join time must be at least 4 minutes in the future. If the join time is too close, the request will fail with 409 Conflict. This ensures the bot can be cancelled before it starts processing.
    
    **Irreversible Operation:** Once a scheduled bot is deleted, it cannot be recovered. If you need to cancel a bot that is about to join, you should use the leave endpoint on the actual bot instance instead.
    
    **No Token Impact:** Since tokens are not reserved for scheduled bots, deleting a scheduled bot does not affect your token balance.
    
    Returns 404 if the scheduled bot is not found, or 409 if the bot's status does not allow deletion or the join time is too close.
 * @summary Delete scheduled bot
 */
export const deleteScheduledBotPathBotIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteScheduledBotParams = zod.object({
  bot_id: zod
    .string()
    .uuid()
    .regex(deleteScheduledBotPathBotIdRegExp)
    .describe(
      "The UUID of the scheduled bot to cancel/delete.\n\nThis is the unique identifier returned when creating a scheduled bot.\n\nNote: This performs a soft delete (sets status to 'cancelled'). The bot must be in 'scheduled' status and the join_at time must be at least 10 minutes in the future.\n\nExample: \"123e4567-e89b-12d3-a456-426614174000\""
    )
})

export const deleteScheduledBotResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod.string().describe("Success message")
  })
})
