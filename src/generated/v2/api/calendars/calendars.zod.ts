/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Meeting BaaS API
 * API for managing meeting bots, calendar integrations, and webhooks
 * OpenAPI spec version: 2.0.0
 */
import { z as zod } from "zod"

/**
 * Preview available calendars from a Google or Microsoft account before creating a connection.
    
    Requires OAuth credentials (client ID, client secret, refresh token) to authenticate and list calendars. This endpoint does not create a connection - it only lists the calendars that are available for the given OAuth credentials. Useful for allowing users to select which calendars to sync.
    
    **OAuth Credentials:** You must provide valid OAuth credentials for the calendar provider. The endpoint will use the refresh token to obtain an access token and list calendars. If the refresh token is invalid or expired, the request will fail with 401 Unauthorized.
    
    **Calendar Information:** Returns a list of calendars with their IDs, names, descriptions, and whether they are primary calendars. Calendar IDs differ between providers (Google uses email-like IDs, Microsoft uses GUIDs).
    
    **Use Case:** This endpoint is typically called before creating a calendar connection to show users which calendars are available. Users can then select which calendars they want to sync.
    
    Returns 401 if OAuth token refresh failed, or 403 if a Microsoft account license is required.
 * @summary List raw calendars (preview before creating connection)
 */
export const listRawCalendarsBodyOauthTenantIdDefault = "common"

export const listRawCalendarsBody = zod.object({
  calendar_platform: zod
    .enum(["google", "microsoft"])
    .describe(
      "The calendar platform to connect to. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365."
    ),
  oauth_client_id: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client ID for the calendar platform."),
  oauth_client_secret: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client secret for the calendar platform."),
  oauth_refresh_token: zod
    .string()
    .min(1)
    .describe(
      "The OAuth 2.0 refresh token obtained from the user's authorization. Must include 'offline_access' scope (Microsoft) or 'access_type=offline' (Google)."
    ),
  oauth_tenant_id: zod
    .string()
    .default(listRawCalendarsBodyOauthTenantIdDefault)
    .describe(
      "Azure AD tenant ID (required for Microsoft only, defaults to 'common'). Find it in Azure Portal > Azure Active Directory > Overview. Example: '12345678-1234-1234-1234-123456789012'. You can also use 'common', 'organizations', or 'consumers' for multi-tenant scenarios."
    )
})

export const listRawCalendarsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      id: zod
        .string()
        .describe(
          "The calendar ID from the calendar platform. Use this value as the 'raw_calendar_id' parameter when creating a calendar connection"
        ),
      name: zod
        .string()
        .describe("The display name of the calendar as shown in the calendar application"),
      email: zod
        .string()
        .describe(
          "The email address associated with the calendar. For Google Calendar, this is typically the calendar owner's email. For Microsoft, this is the calendar's email address"
        ),
      is_primary: zod
        .boolean()
        .describe(
          "Whether this is the user's primary/default calendar. The primary calendar is typically the main calendar associated with the user's account"
        )
    })
  )
})

/**
 * Connect a Google or Microsoft calendar to your account.
    
    The connection will automatically sync events and create push subscriptions for real-time updates. You must provide your own OAuth credentials (client ID, secret, refresh token). Once connected, the calendar will be synced immediately, and webhook subscriptions will be created for real-time event updates.
    
    **OAuth Credentials:** You must provide valid OAuth credentials for the calendar provider. The endpoint will validate the credentials by attempting to refresh the access token. If the refresh token is invalid or expired, the request will fail with 401 Unauthorized.
    
    **Initial Sync:** After creating the connection, an initial sync is performed automatically. This fetches all events from the calendar provider. The sync may take a few minutes for calendars with many events.
    
    **Push Subscriptions:** A push subscription is created automatically for real-time event updates. The subscription will send webhooks when events are created, updated, or cancelled.
    
    **Calendar Limits:** There may be limits on the number of calendar connections per team. If the limit is exceeded, the request will fail with 429 Status Code.
    
    **Duplicate Connections:** If a connection already exists for the same calendar ID and team, the request will fail with 409 Conflict. You can update an existing connection using the PATCH endpoint instead.
    
    Returns 201 with the newly created calendar connection. Returns 401 if OAuth token refresh failed, 429 if the calendar connection limit is exceeded, or 409 if the connection already exists.
 * @summary Create calendar connection
 */
export const createCalendarConnectionBodyOauthTenantIdDefault = "common"

export const createCalendarConnectionBody = zod.object({
  calendar_platform: zod
    .enum(["google", "microsoft"])
    .describe(
      "The calendar platform to connect to. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365."
    ),
  oauth_client_id: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client ID for the calendar platform."),
  oauth_client_secret: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client secret for the calendar platform."),
  oauth_refresh_token: zod
    .string()
    .min(1)
    .describe(
      "The OAuth 2.0 refresh token obtained from the user's authorization. Must include 'offline_access' scope (Microsoft) or 'access_type=offline' (Google)."
    ),
  oauth_tenant_id: zod
    .string()
    .default(createCalendarConnectionBodyOauthTenantIdDefault)
    .describe(
      "Azure AD tenant ID (required for Microsoft only, defaults to 'common'). Find it in Azure Portal > Azure Active Directory > Overview. Example: '12345678-1234-1234-1234-123456789012'. You can also use 'common', 'organizations', or 'consumers' for multi-tenant scenarios."
    ),
  raw_calendar_id: zod
    .string()
    .min(1)
    .describe(
      "The specific calendar ID to connect. Use the 'List Raw Calendars' endpoint to get available calendar IDs. For Google, this is typically the calendar email (e.g., 'primary' or 'user@gmail.com'). For Microsoft, this is the calendar's unique identifier."
    )
})

/**
 * Retrieve a paginated list of calendar connections.
    
    Supports filtering by calendar platform (google, microsoft) and connection status (active, error, revoked, permission_denied). Results are ordered by creation date (newest first). Use cursor-based pagination for efficient navigation.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many results are returned per page (default: 50, max: 250).
    
    **Filtering:**
    - `platform`: Filter by calendar platform (google, microsoft)
    - `status`: Filter by connection status (active, error, revoked, permission_denied)
    
    **Connection Status:**
    - `active`: Connection is working and syncing events
    - `error`: Connection has errors (OAuth token refresh failed, etc.)
    - `revoked`: OAuth access was revoked by the user
    - `permission_denied`: Insufficient permissions for the OAuth scopes
    
    Returns a paginated list of calendar connections with metadata including calendar ID, platform, account email, status, and last sync time.
 * @summary List calendar connections
 */
export const listCalendarsQueryLimitDefault = 50
export const listCalendarsQueryLimitMax = 250
export const listCalendarsQueryCursorDefault = null
export const listCalendarsQueryAccountEmailDefault = null

export const listCalendarsQueryParams = zod.object({
  limit: zod
    .number()
    .min(1)
    .max(listCalendarsQueryLimitMax)
    .describe(
      "Maximum number of calendars to return in a single request.\n\nLimits the number of results returned in a single API call.\n\nDefault: 50 Minimum: 1 Maximum: 250"
    ),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing `<isoDate>::<id>`. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MjAyNS0wMS0xNVQxMDozMDowMFo6OjEyMzQ1\" or \"LU1qQXlOM1UxTmpVME5qVXhNakUwTkRrPQ==\" (for backward pagination)'
    ),
  account_email: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'Filter calendars by account email address. This performs a case-insensitive partial match (ilike) on the email address associated with the calendar account.\n\nExample: \"example\" would match all calendars with email addresses containing \"example\" (e.g., \"example@domain.com\", \"user@example.com\").'
    ),
  calendar_platform: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter calendars by platform. It can be used to find calendars that are associated with a specific platform. Valid values are: \"google\", \"microsoft\".\n\nExample: \"google\" would match all Google Calendar connections.\n\nTo filter multiple platforms, use a comma-separated list of values. For example, \"google,microsoft\" would match all calendars from both platforms.'
    ),
  status: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter calendars by connection status(es). It can be used to find calendars that have any of the specified statuses. Valid values are one or more of: active, error, revoked, permission_denied.\n\nExample: \"active,error\" would match all calendars that are active or have errors.\n\nTo filter multiple statuses, use a comma-separated list of values.'
    )
})

export const listCalendarsResponseDataItemCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listCalendarsResponseDataItemSyncedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listCalendarsResponseDataItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const listCalendarsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      calendar_id: zod
        .string()
        .uuid()
        .regex(listCalendarsResponseDataItemCalendarIdRegExp)
        .describe(
          "The UUID of the calendar connection. Use this ID to reference the calendar in other API endpoints"
        ),
      calendar_platform: zod
        .enum(["google", "microsoft"])
        .describe(
          "The calendar platform. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365"
        ),
      account_email: zod
        .string()
        .describe(
          "The email address associated with the calendar account. This is the email of the calendar owner"
        ),
      status: zod
        .enum(["active", "error", "revoked", "permission_denied"])
        .describe(
          "The current status of the calendar connection. Possible values: 'active' (connection is working), 'error' (connection has errors), 'revoked' (OAuth access was revoked), 'permission_denied' (insufficient permissions)"
        ),
      synced_at: zod
        .string()
        .datetime({})
        .regex(listCalendarsResponseDataItemSyncedAtRegExpOne)
        .or(zod.null())
        .describe(
          "ISO 8601 timestamp of the last successful calendar sync. Null if the calendar has never been synced yet. Syncs happen automatically when events change, or can be triggered manually using the sync endpoint"
        ),
      created_at: zod
        .string()
        .datetime({})
        .regex(listCalendarsResponseDataItemCreatedAtRegExp)
        .describe(
          "ISO 8601 timestamp when the calendar connection was created and initially synced"
        )
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Retrieve detailed information about a specific calendar connection.
    
    Returns the calendar connection's configuration, sync status, subscription status, and last sync time. Includes information about the OAuth credentials (without exposing sensitive data) and the calendar's metadata.
    
    **Sync Status:** The response includes the last sync time and whether the connection is actively syncing. If the connection has errors, the error information is included.
    
    **Subscription Status:** Includes information about the push subscription, including when it was created and when it expires. Subscriptions expire after a certain period and need to be renewed using the resubscribe endpoint.
    
    **Calendar Metadata:** Includes the calendar's ID, name, platform, and account email. This information is fetched from the calendar provider during the initial sync.
    
    Returns 404 if the calendar connection is not found or does not belong to your team.
 * @summary Get calendar connection details
 */
export const getCalendarDetailsPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getCalendarDetailsParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(getCalendarDetailsPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar to retrieve.")
})

export const getCalendarDetailsResponseDataCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getCalendarDetailsResponseDataSubscriptionExpiresAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getCalendarDetailsResponseDataSyncedAtRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getCalendarDetailsResponseDataCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getCalendarDetailsResponseDataUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const getCalendarDetailsResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    calendar_id: zod
      .string()
      .uuid()
      .regex(getCalendarDetailsResponseDataCalendarIdRegExp)
      .describe(
        "The UUID of the calendar connection. Use this ID to reference the calendar in other API endpoints"
      ),
    calendar_platform: zod
      .enum(["google", "microsoft"])
      .describe(
        "The calendar platform. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365"
      ),
    account_email: zod
      .string()
      .describe(
        "The email address associated with the calendar account. This is the email of the calendar owner"
      ),
    status: zod
      .enum(["active", "error", "revoked", "permission_denied"])
      .describe(
        "The current status of the calendar connection. Possible values: 'active' (connection is working), 'error' (connection has errors), 'revoked' (OAuth access was revoked), 'permission_denied' (insufficient permissions)"
      ),
    status_message: zod
      .string()
      .or(zod.null())
      .describe(
        "A human-readable message providing additional context about the connection status. Null if there is no additional status message to display"
      ),
    subscription_id: zod
      .string()
      .or(zod.null())
      .describe(
        "The subscription ID assigned by the calendar provider (Google or Microsoft). This ID is used to manage the webhook subscription. Null if no subscription exists"
      ),
    subscription_expires_at: zod
      .string()
      .datetime({})
      .regex(getCalendarDetailsResponseDataSubscriptionExpiresAtRegExpOne)
      .or(zod.null())
      .describe(
        "ISO 8601 timestamp when the webhook subscription expires. Subscriptions typically expire after a certain period (e.g., 7 days for Google, 3 days for Microsoft) and need to be renewed. Null if no subscription exists"
      ),
    synced_at: zod
      .string()
      .datetime({})
      .regex(getCalendarDetailsResponseDataSyncedAtRegExpOne)
      .or(zod.null())
      .describe(
        "ISO 8601 timestamp of the last successful calendar sync. Null if the calendar has never been synced. Syncs fetch events from the calendar platform and update the local database"
      ),
    sync_status: zod
      .enum(["success", "failed", "partial"])
      .or(zod.null())
      .describe(
        "The status of the last sync operation. Null if no sync has been performed yet. Possible values when not null: 'success' (sync completed successfully), 'failed' (sync failed completely), 'partial' (sync completed but some events could not be processed)"
      ),
    sync_error: zod
      .string()
      .or(zod.null())
      .describe(
        "Error message from the last sync operation if it failed. This provides details about what went wrong during the sync. Null if the last sync was successful or if no sync has been performed"
      ),
    provider_metadata: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .describe(
        "Additional metadata returned by the calendar provider about this calendar. This may include calendar-specific settings, permissions, or other platform-specific information. Null if the provider did not return metadata or if metadata is not available"
      ),
    created_at: zod
      .string()
      .datetime({})
      .regex(getCalendarDetailsResponseDataCreatedAtRegExp)
      .describe("ISO 8601 timestamp when the calendar connection was created and initially synced"),
    updated_at: zod
      .string()
      .datetime({})
      .regex(getCalendarDetailsResponseDataUpdatedAtRegExp)
      .describe(
        "ISO 8601 timestamp when the calendar connection was last updated. This updates when connection settings change, credentials are refreshed, or subscription details are updated"
      )
  })
})

/**
 * Disconnect and delete a calendar connection.
    
    This will stop syncing events and remove all associated calendar data (events, event instances, series). The push subscription will be cancelled automatically. This operation is irreversible.
    
    **Data Deletion:** All calendar data associated with this connection will be deleted:
    - Event series and instances
    - Calendar bot schedules
    - Sync history
    
    **Subscription Cancellation:** The push subscription is cancelled automatically when the connection is deleted. You will no longer receive webhooks for this calendar.
    
    **Irreversible Operation:** Once a calendar connection is deleted, it cannot be recovered. All associated data is permanently removed. If you need to reconnect the calendar, you must create a new connection.
    
    **Bot Schedules:** If there are active calendar bot schedules for events in this calendar, they will be cancelled when the connection is deleted. Bots that have already joined meetings will continue to function normally.
    
    Returns 200 with confirmation of deletion. Returns 404 if the calendar connection is not found or does not belong to your team.
 * @summary Delete calendar connection
 */
export const deleteCalendarConnectionPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteCalendarConnectionParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(deleteCalendarConnectionPathCalendarIdRegExp)
    .describe(
      "The unique identifier of the calendar to delete. This will stop syncing events and remove all scheduled bots for this calendar. It will also delete all event instances and remove the calendar"
    )
})

export const deleteCalendarConnectionResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod
      .string()
      .describe(
        "Success message confirming that the calendar connection has been deleted. All associated event instances, series, and bot schedules have also been removed"
      )
  })
})

/**
 * Update a calendar connection with new OAuth credentials.
    
    Useful when refresh tokens expire or credentials need to be rotated. The connection will be validated and a new push subscription will be created. The old subscription will be cancelled automatically.
    
    **OAuth Credentials:** You can update the client ID, client secret, and refresh token. All fields are optional - only provided fields will be updated. The endpoint will validate the new credentials by attempting to refresh the access token.
    
    **Validation:** After updating credentials, the connection is validated by attempting to refresh the access token. If the refresh fails, the connection status is updated to `error` and the request may fail with 401 Unauthorized.
    
    **Subscription Renewal:** A new push subscription is created automatically after updating credentials. The old subscription is cancelled to prevent duplicate webhooks.
    
    **Use Cases:**
    - Refresh token expired and needs to be renewed
    - OAuth credentials rotated for security
    - Fixing connection errors by updating credentials
    
    Returns 200 with the updated calendar connection. Returns 401 if OAuth token refresh failed, 403 if permission is denied, or 404 if the calendar connection is not found.
 * @summary Update calendar connection
 */
export const updateCalendarConnectionPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const updateCalendarConnectionParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(updateCalendarConnectionPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar to update.")
})

export const updateCalendarConnectionBodyOauthTenantIdDefault = "common"

export const updateCalendarConnectionBody = zod.object({
  oauth_client_id: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client ID for the calendar platform."),
  oauth_client_secret: zod
    .string()
    .min(1)
    .describe("Your OAuth 2.0 client secret for the calendar platform."),
  oauth_refresh_token: zod
    .string()
    .min(1)
    .describe(
      "The OAuth 2.0 refresh token obtained from the user's authorization. Must include 'offline_access' scope (Microsoft) or 'access_type=offline' (Google)."
    ),
  oauth_tenant_id: zod
    .string()
    .default(updateCalendarConnectionBodyOauthTenantIdDefault)
    .describe(
      "Azure AD tenant ID (required for Microsoft only, defaults to 'common'). Find it in Azure Portal > Azure Active Directory > Overview. Example: '12345678-1234-1234-1234-123456789012'. You can also use 'common', 'organizations', or 'consumers' for multi-tenant scenarios."
    )
})

export const updateCalendarConnectionResponseDataCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const updateCalendarConnectionResponseDataUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const updateCalendarConnectionResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    calendar_id: zod
      .string()
      .uuid()
      .regex(updateCalendarConnectionResponseDataCalendarIdRegExp)
      .describe(
        "The UUID of the updated calendar connection. Use this ID to reference the calendar in other API endpoints"
      ),
    calendar_platform: zod
      .enum(["google", "microsoft"])
      .describe(
        "The calendar platform. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365"
      ),
    account_email: zod
      .string()
      .describe(
        "The email address associated with the calendar account. This is the email of the calendar owner"
      ),
    status: zod
      .enum(["active", "error", "revoked", "permission_denied"])
      .describe(
        "The current status of the calendar connection after the update. Possible values: 'active' (connection is working), 'error' (connection has errors), 'revoked' (OAuth access was revoked), 'permission_denied' (insufficient permissions)"
      ),
    updated_at: zod
      .string()
      .datetime({})
      .regex(updateCalendarConnectionResponseDataUpdatedAtRegExp)
      .describe(
        "ISO 8601 timestamp when the calendar connection was last updated with the new credentials or settings"
      )
  })
})

/**
 * Manually trigger a sync of calendar events.
    
    This will fetch all events from the calendar provider and update the calendar data. Events are normally synced automatically via push subscriptions, but you can use this endpoint to force a sync (e.g., after fixing connection errors or when you need immediate updates).
    
    **Sync Process:** The sync process fetches all events from the calendar provider. New events are added, updated events are modified, and cancelled events are marked as deleted. The sync may take a few minutes for calendars with many events.
    
    **Incremental vs Full Sync:** The endpoint performs a full sync, fetching all events from the calendar. Incremental syncs happen automatically via push subscriptions when events are created, updated, or cancelled.
    
    **Use Cases:**
    - Force a sync after fixing connection errors
    - Get immediate updates without waiting for push notifications
    - Recover from missed push notifications
    - Initial sync after creating a connection (though this happens automatically)
    
    **Response:** The response includes information about the sync operation, including how many events were synced. The actual event data is available via the list events endpoint.
    
    Returns 200 with sync results. Returns 401 if OAuth token refresh failed, or 404 if the calendar connection is not found.
 * @summary Sync calendar events
 */
export const syncCalendarPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const syncCalendarParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(syncCalendarPathCalendarIdRegExp)
    .describe(
      "The unique identifier of the calendar to sync. This will fetch the latest events from the calendar provider and update the materialized instances (for the next 30 days)."
    )
})

export const syncCalendarResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    message: zod
      .string()
      .describe(
        "Success message confirming that the calendar sync operation has been initiated. The sync will fetch the latest events from the calendar platform and update the local database"
      )
  })
})

/**
 * Renew or recreate the push subscription for a calendar connection.
    
    Useful when subscriptions expire or need to be refreshed. A new subscription will be created and the old one will be cancelled. Subscriptions expire after a certain period (3 days for Microsoft, longer for Google) and need to be renewed periodically.
    
    **Subscription Renewal:** The endpoint creates a new push subscription with the calendar provider. The old subscription is cancelled to prevent duplicate webhooks. The new subscription will send webhooks for all calendar events (created, updated, cancelled).
    
    **Subscription Expiration:** Subscriptions expire automatically after a certain period:
    - Microsoft: 3 days maximum
    - Google: Longer period (varies)
    
    When a subscription expires, you will stop receiving webhook notifications. Use this endpoint to renew the subscription before it expires.
    
    **Use Cases:**
    - Subscription is about to expire
    - Subscription has expired and webhooks stopped working
    - Need to refresh subscription for troubleshooting
    
    **Response:** The response includes information about the new subscription, including when it was created and when it expires.
    
    Returns 200 with subscription information. Returns 401 if OAuth token refresh failed, 403 if permission is denied, or 404 if the calendar connection is not found.
 * @summary Resubscribe to calendar webhooks
 */
export const resubscribeCalendarPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const resubscribeCalendarParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(resubscribeCalendarPathCalendarIdRegExp)
    .describe(
      "The unique identifier of the calendar to sync. This will fetch the latest events from the calendar provider and update the materialized instances (for the next 30 days)."
    )
})

export const resubscribeCalendarResponseDataCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const resubscribeCalendarResponseDataResubscribedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const resubscribeCalendarResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    calendar_id: zod
      .string()
      .uuid()
      .regex(resubscribeCalendarResponseDataCalendarIdRegExp)
      .describe(
        "The UUID of the calendar connection that was resubscribed. Use this ID to reference the calendar in other API endpoints"
      ),
    resubscribed_at: zod
      .string()
      .datetime({})
      .regex(resubscribeCalendarResponseDataResubscribedAtRegExp)
      .describe("ISO 8601 timestamp when the calendar connection was resubscribed")
  })
})

/**
 * Retrieve a paginated list of calendar events.
    
    Supports filtering by date range, status (confirmed, cancelled, tentative), and whether events are deleted. Results include whether a bot is scheduled for each event. Use cursor-based pagination for efficient navigation.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many results are returned per page (default: 50, max: 250).
    
    **Filtering:**
    - `start_after`: ISO 8601 timestamp - only return events starting after this time
    - `start_before`: ISO 8601 timestamp - only return events starting before this time
    - `status`: Filter by event status (confirmed, cancelled, tentative)
    - `include_deleted`: Include deleted events in results (default: false)
    
    **Event Information:** Each event includes its ID, title, start/end times, status, meeting URL (if available), meeting platform (if detected), and whether a bot is scheduled for the event.
    
    **Bot Scheduling:** The `bot_scheduled` field indicates whether a calendar bot schedule exists for this event. This does not mean the bot has joined - it means a bot is scheduled to join when the event starts.
    
    Returns a paginated list of calendar events with metadata.
 * @summary List calendar events
 */
export const listEventsPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const listEventsParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(listEventsPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar to list events from.")
})

export const listEventsQueryLimitDefault = 50
export const listEventsQueryLimitMax = 250
export const listEventsQueryCursorDefaultOne = null
export const listEventsQueryStartDateRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventsQueryEndDateRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventsQueryShowCancelledDefault = true

export const listEventsQueryParams = zod.object({
  limit: zod
    .number()
    .min(1)
    .max(listEventsQueryLimitMax)
    .describe(
      "Maximum number of events to return in a single request.\n\nLimits the number of results returned in a single API call.\n\nDefault: 50 Minimum: 1 Maximum: 250"
    ),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing `<isoDate>::<id>`. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MjAyNS0wMS0xNVQxMDozMDowMFo6OjEyMzQ1\" or \"LU1qQXlOM1UxTmpVME5qVXhNakUwTkRrPQ==\" (for backward pagination)'
    ),
  start_date: zod
    .string()
    .datetime({})
    .regex(listEventsQueryStartDateRegExpOne)
    .or(zod.null())
    .optional()
    .describe("Filter events starting on or after this date/time (ISO 8601 format)."),
  end_date: zod
    .string()
    .datetime({})
    .regex(listEventsQueryEndDateRegExpOne)
    .or(zod.null())
    .optional()
    .describe("Filter events ending on or before this date/time (ISO 8601 format)."),
  status: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter events by status(es). It can be used to find events that have any of the specified statuses. Valid values are one or more of: confirmed, cancelled, tentative.\n\nExample: \"confirmed,cancelled\" would match all events that are confirmed or cancelled.\n\nTo filter multiple statuses, use a comma-separated list of values.'
    ),
  show_cancelled: zod
    .boolean()
    .describe(
      "Whether to include cancelled events in the results. When set to 'false', only non-cancelled events are returned. Default: true"
    )
})

export const listEventsResponseDataItemSeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventsResponseDataItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventsResponseDataItemStartTimeRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventsResponseDataItemEndTimeRegExpOne =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventsResponseDataItemCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventsResponseDataItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const listEventsResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      series_id: zod
        .string()
        .uuid()
        .regex(listEventsResponseDataItemSeriesIdRegExp)
        .describe(
          "The UUID of the event series this instance belongs to. Every event instance (both one-off and recurring) is associated with a series. Use this ID when scheduling bots for all occurrences of a recurring series"
        ),
      event_type: zod
        .enum(["one_off", "recurring"])
        .describe(
          "The type of event. 'one_off' for single events that occur once, 'recurring' for events that are part of a recurring series with multiple occurrences"
        ),
      event_id: zod
        .string()
        .uuid()
        .regex(listEventsResponseDataItemEventIdRegExp)
        .describe("The UUID of the event instance"),
      title: zod.string().describe("The title of the event"),
      start_time: zod
        .string()
        .datetime({})
        .regex(listEventsResponseDataItemStartTimeRegExpOne)
        .describe("ISO 8601 timestamp when the event starts"),
      end_time: zod
        .string()
        .datetime({})
        .regex(listEventsResponseDataItemEndTimeRegExpOne)
        .describe("ISO 8601 timestamp when the event ends"),
      status: zod
        .enum(["confirmed", "cancelled", "tentative"])
        .describe(
          "The status of the event. Possible values: 'confirmed' (event is confirmed), 'cancelled' (event has been cancelled), 'tentative' (event is tentative)"
        ),
      is_exception: zod
        .boolean()
        .describe(
          "Whether this is an exception to a recurring series. True if this instance has been modified differently from the recurring pattern"
        ),
      meeting_url: zod
        .string()
        .or(zod.null())
        .describe(
          "The meeting URL extracted from the event. Null if the calendar platform did not include a meeting link in the event"
        ),
      meeting_platform: zod
        .enum(["zoom", "meet", "teams"])
        .or(zod.null())
        .describe(
          "The meeting platform detected from the meeting URL. Null if no meeting link was found in the event. Possible values: 'zoom', 'meet', or 'teams'"
        ),
      calendar_id: zod
        .string()
        .uuid()
        .regex(listEventsResponseDataItemCalendarIdRegExp)
        .describe("The UUID of the calendar connection this event belongs to"),
      bot_scheduled: zod
        .boolean()
        .describe(
          "Whether a bot has been scheduled for this event instance. True if a calendar bot schedule exists for this event"
        ),
      created_at: zod
        .string()
        .datetime({})
        .regex(listEventsResponseDataItemCreatedAtRegExp)
        .describe("ISO 8601 timestamp when this event instance was first synced into the system")
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Retrieve a paginated list of event series (both one-off and recurring events).
    
    Each series includes its associated event instances. Supports filtering by event type (one_off, recurring) and whether series are deleted. Use cursor-based pagination for efficient navigation.
    
    **Pagination:** Uses cursor-based pagination. Provide a `cursor` query parameter to fetch the next page. The `limit` parameter controls how many results are returned per page (default: 50, max: 250).
    
    **Event Types:**
    - `one_off`: Single events (not part of a recurring series)
    - `recurring`: Events that are part of a recurring series
    
    **Series Information:** Each series includes its series ID, event type, whether a bot is scheduled for all occurrences (`series_bot_scheduled`), and an array of event instances. For one-off events, the instances array contains a single instance. For recurring events, it contains all instances that have been synced.
    
    **Filtering:**
    - `event_type`: Filter by event type (one_off, recurring)
    - `include_deleted`: Include deleted series in results (default: false)
    
    **Bot Scheduling:** The `series_bot_scheduled` field indicates whether a calendar bot schedule exists for all occurrences of this series. Individual instances may have different bot scheduling status.
    
    Returns a paginated list of event series with their instances.
 * @summary List event series
 */
export const listEventSeriesPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const listEventSeriesParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(listEventSeriesPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar to list event series from.")
})

export const listEventSeriesQueryLimitDefault = 50
export const listEventSeriesQueryLimitMax = 250
export const listEventSeriesQueryCursorDefault = null
export const listEventSeriesQueryShowCancelledDefault = true

export const listEventSeriesQueryParams = zod.object({
  limit: zod
    .number()
    .min(1)
    .max(listEventSeriesQueryLimitMax)
    .describe(
      "Maximum number of event series to return in a single request.\n\nLimits the number of results returned in a single API call.\n\nDefault: 50 Minimum: 1 Maximum: 250"
    ),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      'The cursor to use for pagination.\n\nObtained from the `cursor` or `prev_cursor` field in the previous response.\n\nThe cursor is a base64-encoded string containing `<isoDate>::<id>`. To paginate backward, prefix the cursor with a `-` (minus sign).\n\nLeave as `null` to get the first page of results.\n\nExample: \"MjAyNS0wMS0xNVQxMDozMDowMFo6OjEyMzQ1\" or \"LU1qQXlOM1UxTmpVME5qVXhNakUwTkRrPQ==\" (for backward pagination)'
    ),
  event_type: zod
    .string()
    .or(zod.null())
    .or(zod.null())
    .optional()
    .describe(
      'Filter event series by type(s). It can be used to find event series that have any of the specified types. Valid values are one or more of: one_off, recurring.\n\nExample: \"one_off,recurring\" would match all event series that are one-off or recurring.\n\nTo filter multiple types, use a comma-separated list of values.'
    ),
  show_cancelled: zod
    .boolean()
    .describe(
      "Whether to include cancelled event instances in the results. When set to 'false', only non-cancelled event instances are returned. Note: This only affects event instances within series, not the series themselves. Default: true"
    )
})

export const listEventSeriesResponseDataItemSeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventSeriesResponseDataItemCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventSeriesResponseDataItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventSeriesResponseDataItemEventsItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventSeriesResponseDataItemEventsItemStartTimeRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventSeriesResponseDataItemEventsItemEndTimeRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const listEventSeriesResponseDataItemEventsItemCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const listEventSeriesResponseDataItemEventsItemCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const listEventSeriesResponse = zod.object({
  success: zod.boolean(),
  data: zod.array(
    zod.object({
      series_id: zod
        .string()
        .uuid()
        .regex(listEventSeriesResponseDataItemSeriesIdRegExp)
        .describe(
          "The UUID of the event series. Every event (both one-off and recurring) is associated with a series. Use this ID when scheduling bots for all occurrences of a recurring series"
        ),
      event_type: zod
        .enum(["one_off", "recurring"])
        .describe(
          "The type of event. 'one_off' for single events that occur once, 'recurring' for events that are part of a recurring series with multiple occurrences"
        ),
      calendar_id: zod
        .string()
        .uuid()
        .regex(listEventSeriesResponseDataItemCalendarIdRegExp)
        .describe("The UUID of the calendar connection this event series belongs to"),
      created_at: zod
        .string()
        .datetime({})
        .regex(listEventSeriesResponseDataItemCreatedAtRegExp)
        .describe("ISO 8601 timestamp when this event series was first synced into the system"),
      events: zod
        .array(
          zod.object({
            event_id: zod
              .string()
              .uuid()
              .regex(listEventSeriesResponseDataItemEventsItemEventIdRegExp)
              .describe("The UUID of the event instance"),
            title: zod.string().describe("The title of the event"),
            start_time: zod
              .string()
              .datetime({})
              .regex(listEventSeriesResponseDataItemEventsItemStartTimeRegExp)
              .describe("ISO 8601 timestamp when the event starts"),
            end_time: zod
              .string()
              .datetime({})
              .regex(listEventSeriesResponseDataItemEventsItemEndTimeRegExp)
              .describe("ISO 8601 timestamp when the event ends"),
            status: zod
              .enum(["confirmed", "cancelled", "tentative"])
              .describe(
                "The status of the event. Possible values: 'confirmed' (event is confirmed), 'cancelled' (event has been cancelled), 'tentative' (event is tentative)"
              ),
            is_exception: zod
              .boolean()
              .describe(
                "Whether this is an exception to a recurring series. True if this instance has been modified differently from the recurring pattern"
              ),
            meeting_url: zod
              .string()
              .or(zod.null())
              .describe(
                "The meeting URL extracted from the event. Null if the calendar platform did not include a meeting link in the event"
              ),
            meeting_platform: zod
              .enum(["zoom", "meet", "teams"])
              .or(zod.null())
              .describe(
                "The meeting platform detected from the meeting URL. Null if no meeting link was found in the event. Possible values: 'zoom', 'meet', or 'teams'"
              ),
            calendar_id: zod
              .string()
              .uuid()
              .regex(listEventSeriesResponseDataItemEventsItemCalendarIdRegExp)
              .describe("The UUID of the calendar connection this event belongs to"),
            bot_scheduled: zod
              .boolean()
              .describe(
                "Whether a bot has been scheduled for this event instance. True if a calendar bot schedule exists for this event"
              ),
            created_at: zod
              .string()
              .datetime({})
              .regex(listEventSeriesResponseDataItemEventsItemCreatedAtRegExp)
              .describe(
                "ISO 8601 timestamp when this event instance was first synced into the system"
              )
          })
        )
        .describe(
          "List of event instances that belong to this series. For one-off events, this array contains a single instance. For recurring events, this array contains all instances that have been synced (typically within a 30-day window)"
        )
    })
  ),
  cursor: zod.string().or(zod.null()).describe("Cursor for the next page (null if no more pages)"),
  prev_cursor: zod
    .string()
    .or(zod.null())
    .describe("Cursor for the previous page (null if on first page)")
})

/**
 * Retrieve detailed information about a specific calendar event.
    
    Returns comprehensive event information including attendees, meeting URL, meeting platform, status, and whether a bot is scheduled. Returns deleted events as well (use the `include_deleted` parameter or check the `deleted_at` field).
    
    **Event Details:** Includes all event metadata:
    - Title, description, location
    - Start and end times (ISO 8601 timestamps)
    - Status (confirmed, cancelled, tentative)
    - Attendees list
    - Meeting URL (if available)
    - Meeting platform (if detected from URL)
    - Whether it's an all-day event
    - Whether it's an exception to a recurring series
    
    **Bot Scheduling:** The `bot_scheduled` field indicates whether a calendar bot schedule exists for this event. If the event is part of a recurring series, the `series_bot_scheduled` field indicates whether a bot is scheduled for all occurrences.
    
    **Deleted Events:** Deleted events are included in the response. Check the `deleted_at` field to determine if an event has been deleted. Deleted events may still have associated bot schedules if they were scheduled before deletion.
    
    Returns 404 if the event is not found or does not belong to the specified calendar.
 * @summary Get event details
 */
export const getEventDetailsPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getEventDetailsPathEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const getEventDetailsParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(getEventDetailsPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar that contains the event."),
  event_id: zod
    .string()
    .uuid()
    .regex(getEventDetailsPathEventIdRegExp)
    .describe(
      "The unique identifier of the event to retrieve. This is a specific occurrence of an event (for recurring events) or the event itself (for one-time events)."
    )
})

export const getEventDetailsResponseDataEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getEventDetailsResponseDataSeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getEventDetailsResponseDataStartTimeRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getEventDetailsResponseDataEndTimeRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getEventDetailsResponseDataCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const getEventDetailsResponseDataCreatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/
export const getEventDetailsResponseDataUpdatedAtRegExp =
  /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/

export const getEventDetailsResponse = zod.object({
  success: zod.boolean(),
  data: zod.object({
    event_id: zod
      .string()
      .uuid()
      .regex(getEventDetailsResponseDataEventIdRegExp)
      .describe("The UUID of the event instance"),
    series_id: zod
      .string()
      .uuid()
      .regex(getEventDetailsResponseDataSeriesIdRegExp)
      .describe(
        "The UUID of the event series this instance belongs to. Every event instance (both one-off and recurring) is associated with a series. Use this ID when scheduling bots for all occurrences of a recurring series"
      ),
    event_type: zod
      .enum(["one_off", "recurring"])
      .describe(
        "The type of event. 'one_off' for single events that occur once, 'recurring' for events that are part of a recurring series with multiple occurrences"
      ),
    title: zod.string().describe("The title of the event as stored in the calendar"),
    description: zod
      .string()
      .or(zod.null())
      .describe(
        "The description of the event as returned by the calendar platform. Null if the calendar platform did not include a description for this event"
      ),
    location: zod
      .string()
      .or(zod.null())
      .describe(
        "The location of the event as returned by the calendar platform. Null if the calendar platform did not include a location for this event"
      ),
    start_time: zod
      .string()
      .datetime({})
      .regex(getEventDetailsResponseDataStartTimeRegExp)
      .describe("ISO 8601 timestamp when the event starts"),
    end_time: zod
      .string()
      .datetime({})
      .regex(getEventDetailsResponseDataEndTimeRegExp)
      .describe("ISO 8601 timestamp when the event ends"),
    timezone: zod
      .string()
      .or(zod.null())
      .describe(
        "The IANA timezone identifier for the event (e.g., 'America/New_York', 'Europe/London'). Null if the calendar platform did not provide timezone information or if the event is all-day"
      ),
    is_all_day: zod
      .boolean()
      .describe(
        "Whether this is an all-day event. True if the event spans entire days without specific start/end times"
      ),
    status: zod
      .enum(["confirmed", "cancelled", "tentative"])
      .describe(
        "The status of the event. Possible values: 'confirmed' (event is confirmed), 'cancelled' (event has been cancelled), 'tentative' (event is tentative)"
      ),
    organizer_email: zod
      .string()
      .or(zod.null())
      .describe(
        "The email address of the event organizer as returned by the calendar platform. Null if the calendar platform did not provide organizer information"
      ),
    organizer_name: zod
      .string()
      .or(zod.null())
      .describe(
        "The display name of the event organizer as returned by the calendar platform. Null if the calendar platform did not provide organizer name information"
      ),
    attendees: zod
      .array(
        zod.object({
          email: zod.string().describe("The email address of the attendee"),
          name: zod
            .string()
            .or(zod.null())
            .describe(
              "The display name of the attendee as returned by the calendar platform. Null if the calendar platform did not provide a display name for this attendee"
            ),
          response_status: zod
            .enum(["accepted", "declined", "tentative", "needsAction"])
            .describe(
              "The attendee's response status to the event invitation. Defaults to 'needsAction' if the calendar platform did not provide response status information. Possible values: 'accepted' (attendee accepted the invitation), 'declined' (attendee declined the invitation), 'tentative' (attendee responded as tentative), 'needsAction' (attendee has not responded yet)"
            ),
          organizer: zod
            .boolean()
            .optional()
            .describe(
              "Whether this attendee is the organizer of the event. Only present if the calendar platform provides this information"
            ),
          self: zod
            .boolean()
            .optional()
            .describe(
              "Whether this attendee represents the authenticated user who owns the calendar connection. Only present if the calendar platform provides this information"
            )
        })
      )
      .or(zod.null())
      .describe(
        "List of event attendees as returned by the calendar platform. Null if the calendar platform did not provide attendee information or if the event has no attendees"
      ),
    meeting_url: zod
      .string()
      .or(zod.null())
      .describe(
        "The meeting URL extracted from the event. Null if the calendar platform did not include a meeting link in the event"
      ),
    meeting_platform: zod
      .enum(["zoom", "meet", "teams"])
      .or(zod.null())
      .describe(
        "The meeting platform detected from the meeting URL. Null if no meeting link was found in the event. Possible values: 'zoom', 'meet', or 'teams'"
      ),
    calendar_id: zod
      .string()
      .uuid()
      .regex(getEventDetailsResponseDataCalendarIdRegExp)
      .describe("The UUID of the calendar connection this event belongs to"),
    calendar_platform: zod
      .enum(["google", "microsoft"])
      .describe(
        "The calendar platform where this event originates. Either 'google' for Google Calendar or 'microsoft' for Microsoft Outlook/365"
      ),
    bot_scheduled: zod
      .boolean()
      .describe(
        "Whether a bot has been scheduled for this event instance. True if a calendar bot schedule exists for this event"
      ),
    created_at: zod
      .string()
      .datetime({})
      .regex(getEventDetailsResponseDataCreatedAtRegExp)
      .describe("ISO 8601 timestamp when this event instance was first synced into the system"),
    updated_at: zod
      .string()
      .datetime({})
      .regex(getEventDetailsResponseDataUpdatedAtRegExp)
      .describe(
        "ISO 8601 timestamp when this event instance was last updated (either from a sync or from a webhook notification)"
      )
  })
})

/**
 * Schedule a bot to automatically join a calendar event.
    
    You can schedule for all occurrences of a recurring event or specific event instances. The bot will use the meeting URL from the event. Returns partial success if some events fail to schedule (e.g., if a bot is already scheduled or if the event doesn't have a meeting URL).
    
    **Scheduling Options:**
    - `series_id`: Schedule for all occurrences of a recurring series
    - `event_id`: Schedule for a specific event instance
    - `all_occurrences`: Schedule for all future occurrences (for recurring events)
    
    **Meeting URL Requirement:** The event must have a meeting URL. If the event doesn't have a meeting URL, the scheduling will fail for that event. The meeting platform is automatically detected from the URL.
    
    **Bot Configuration:** You can provide bot configuration (name, image, recording mode, transcription settings, etc.) that will be used for all scheduled bots. The configuration applies to all events you're scheduling for.
    
    **Partial Success:** If you're scheduling for multiple events (e.g., all occurrences of a series), some events may fail to schedule (e.g., if a bot is already scheduled). The response includes information about which events succeeded and which failed.
    
    **Token Reservation:** Tokens are NOT reserved at scheduling time. Token availability and daily bot cap are checked when each bot actually joins the meeting. If tokens are insufficient or the daily cap is reached at join time, the bot will fail with an appropriate error.
    
    **Status:** The calendar bot schedule starts in `scheduled` status and transitions to `completed` when the bot instance is created and queued to join. If the bot fails to join, it transitions to `failed` status.
    
    Returns 201 with scheduling results. Returns 404 if the event series or event is not found.
 * @summary Schedule bot for calendar event
 */
export const createCalendarBotPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const createCalendarBotParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(createCalendarBotPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar that contains the event.")
})

export const createCalendarBotBodyBotNameMax = 255
export const createCalendarBotBodyBotImageDefault = null
export const createCalendarBotBodyRecordingModeDefault = "speaker_view"
export const createCalendarBotBodyEntryMessageMaxOne = 500
export const createCalendarBotBodyEntryMessageDefault = null
export const createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const createCalendarBotBodyTimeoutConfigSilenceTimeoutDefault = 600
export const createCalendarBotBodyTimeoutConfigSilenceTimeoutMin = 300

export const createCalendarBotBodyTimeoutConfigSilenceTimeoutMax = 1800
export const createCalendarBotBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const createCalendarBotBodyZoomAccessTokenUrlDefault = null
export const createCalendarBotBodyExtraDefault = null
export const createCalendarBotBodyStreamingEnabledDefault = false
export const createCalendarBotBodyStreamingConfigInputUrlDefault = null
export const createCalendarBotBodyStreamingConfigOutputUrlDefault = null
export const createCalendarBotBodyStreamingConfigAudioFrequencyMaxOne = 9007199254740991
export const createCalendarBotBodyStreamingConfigAudioFrequencyDefault = 24000
export const createCalendarBotBodyStreamingConfigDefault = null
export const createCalendarBotBodyTranscriptionEnabledDefault = false
export const createCalendarBotBodyTranscriptionConfigProviderDefault = "gladia"
export const createCalendarBotBodyTranscriptionConfigApiKeyDefault = null
export const createCalendarBotBodyTranscriptionConfigCustomParamsDefault = null
export const createCalendarBotBodyTranscriptionConfigDefault = null
export const createCalendarBotBodyCallbackEnabledDefault = false
export const createCalendarBotBodyCallbackConfigSecretDefault = null
export const createCalendarBotBodyCallbackConfigMethodDefault = "POST"
export const createCalendarBotBodyCallbackConfigDefault = null
export const createCalendarBotBodySeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const createCalendarBotBodyAllOccurrencesDefault = false
export const createCalendarBotBodyEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const createCalendarBotBody = zod
  .object({
    bot_name: zod
      .string()
      .min(1)
      .max(createCalendarBotBodyBotNameMax)
      .describe(
        "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
      ),
    bot_image: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
      ),
    recording_mode: zod
      .enum(["audio_only", "speaker_view", "gallery_view"])
      .default(createCalendarBotBodyRecordingModeDefault)
      .describe(
        "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
      ),
    entry_message: zod
      .string()
      .max(createCalendarBotBodyEntryMessageMaxOne)
      .or(zod.null())
      .optional()
      .describe(
        "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
      ),
    timeout_config: zod
      .object({
        waiting_room_timeout: zod
          .number()
          .min(createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMin)
          .max(createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMax)
          .default(createCalendarBotBodyTimeoutConfigWaitingRoomTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        no_one_joined_timeout: zod
          .number()
          .min(createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMin)
          .max(createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMax)
          .default(createCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
          ),
        silence_timeout: zod
          .number()
          .min(createCalendarBotBodyTimeoutConfigSilenceTimeoutMin)
          .max(createCalendarBotBodyTimeoutConfigSilenceTimeoutMax)
          .default(createCalendarBotBodyTimeoutConfigSilenceTimeoutDefault)
          .describe(
            "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
          )
      })
      .default(createCalendarBotBodyTimeoutConfigDefault)
      .describe(
        "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
      ),
    zoom_access_token_url: zod
      .string()
      .url()
      .or(zod.null())
      .optional()
      .describe(
        'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
      ),
    extra: zod
      .record(zod.string(), zod.any())
      .or(zod.null())
      .optional()
      .describe(
        "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
      ),
    streaming_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable audio streaming for this bot. When enabled, the streaming_config property is used to provide the configuration."
      ),
    streaming_config: zod
      .object({
        input_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
          ),
        output_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
          ),
        audio_frequency: zod
          .number()
          .max(createCalendarBotBodyStreamingConfigAudioFrequencyMaxOne)
          .or(zod.null())
          .default(createCalendarBotBodyStreamingConfigAudioFrequencyDefault)
          .describe("The audio frequency in Hz. The default is 24000 Hz.")
      })
      .or(zod.null())
      .optional(),
    transcription_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable transcription for this bot. When enabled, the transcription_config property is used to customise the transcription provider and parameters."
      ),
    transcription_config: zod
      .object({
        provider: zod
          .enum(["gladia"])
          .default(createCalendarBotBodyTranscriptionConfigProviderDefault)
          .describe(
            "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
          ),
        api_key: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
          ),
        custom_params: zod
          .record(zod.string(), zod.any())
          .or(zod.null())
          .optional()
          .describe(
            "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
          )
      })
      .or(zod.null())
      .optional(),
    callback_enabled: zod
      .boolean()
      .optional()
      .describe(
        "Enable callback for this bot. When enabled, the callback_config property is used to provide the configuration."
      ),
    callback_config: zod
      .object({
        url: zod
          .string()
          .url()
          .describe("The URL to be called upon the completion or failure of the bot."),
        secret: zod
          .string()
          .or(zod.null())
          .optional()
          .describe(
            "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
          ),
        method: zod
          .enum(["POST", "PUT"])
          .default(createCalendarBotBodyCallbackConfigMethodDefault)
          .describe("The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'.")
      })
      .or(zod.null())
      .optional()
  })
  .and(
    zod.object({
      series_id: zod
        .string()
        .uuid()
        .regex(createCalendarBotBodySeriesIdRegExp)
        .describe(
          "The UUID of the event series to schedule bots for.\n\nBoth one-off and recurring events have a series_id. For recurring events, use 'all_occurrences' to schedule bots for all future occurrences."
        ),
      all_occurrences: zod
        .boolean()
        .describe(
          "Whether to schedule bots for all occurrences of the event series.\n\nIf `true`, bots will be scheduled for all future event instances in the series. If `false`, `event_id` must be provided to schedule a bot for a specific event instance.\n\nDefault: `false`"
        ),
      event_id: zod
        .string()
        .uuid()
        .regex(createCalendarBotBodyEventIdRegExp)
        .optional()
        .describe(
          "The UUID of a specific event instance to schedule a bot for.\n\nRequired when `all_occurrences` is `false`. Use this to schedule a bot for a single occurrence of a recurring event or a specific one-off event. If `all_occurrences` is `true`, this parameter is ignored."
        )
    })
  )

/**
 * Update one or more calendar bots for a calendar.
    
    You can target a single event or all occurrences in a series using `series_id`, `all_occurrences`, and `event_id` in the request body. The bot must be in `scheduled` status and the join time must be at least 4 minutes in the future.
    
    **Update Targets:**
    - `event_id`: Update bot for a specific event instance
    - `series_id`: Update bots for all occurrences of a series
    - `all_occurrences`: Update all future occurrences (for recurring events)
    
    **Updateable Fields:** You can update any bot configuration field (bot name, image, recording mode, transcription settings, etc.). All fields are optional - only provided fields will be updated.
    
    **Status Requirements:** The bot must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be updated. If the bot is in an invalid state, the request will fail with a 409 Conflict status.
    
    **Join Time Requirements:** The join time must be at least 4 minutes in the future. If the join time is too close, the request will fail with 409 Conflict. This ensures the bot can be updated before it starts processing.
    
    **Partial Updates:** If updating multiple bots (e.g., all occurrences of a series), some bots may fail to update (e.g., if they're not in `scheduled` status). The response includes information about which bots were updated and which failed.
    
    Returns 200 with update results. Returns 404 if the event or calendar bot schedule is not found, or 409 if the bot's status does not allow update.
 * @summary Update calendar bot
 */
export const updateCalendarBotPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const updateCalendarBotParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(updateCalendarBotPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar that contains the event.")
})

export const updateCalendarBotBodySeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const updateCalendarBotBodyAllOccurrencesDefault = false
export const updateCalendarBotBodyEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const updateCalendarBotBodyBotNameMax = 255
export const updateCalendarBotBodyBotImageDefault = null
export const updateCalendarBotBodyRecordingModeDefault = "speaker_view"
export const updateCalendarBotBodyEntryMessageMaxOne = 500
export const updateCalendarBotBodyEntryMessageDefault = null
export const updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutDefault = 600
export const updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMin = 120

export const updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMax = 1800
export const updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutDefault = 600
export const updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMin = 120

export const updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMax = 1800
export const updateCalendarBotBodyTimeoutConfigSilenceTimeoutDefault = 600
export const updateCalendarBotBodyTimeoutConfigSilenceTimeoutMin = 300

export const updateCalendarBotBodyTimeoutConfigSilenceTimeoutMax = 1800
export const updateCalendarBotBodyTimeoutConfigDefault = {
  waiting_room_timeout: 600,
  no_one_joined_timeout: 600,
  silence_timeout: 600
}
export const updateCalendarBotBodyZoomAccessTokenUrlDefault = null
export const updateCalendarBotBodyExtraDefault = null
export const updateCalendarBotBodyStreamingConfigInputUrlDefault = null
export const updateCalendarBotBodyStreamingConfigOutputUrlDefault = null
export const updateCalendarBotBodyStreamingConfigAudioFrequencyMaxOne = 9007199254740991
export const updateCalendarBotBodyStreamingConfigAudioFrequencyDefault = 24000
export const updateCalendarBotBodyTranscriptionConfigProviderDefault = "gladia"
export const updateCalendarBotBodyTranscriptionConfigApiKeyDefault = null
export const updateCalendarBotBodyTranscriptionConfigCustomParamsDefault = null
export const updateCalendarBotBodyCallbackConfigSecretDefault = null
export const updateCalendarBotBodyCallbackConfigMethodDefault = "POST"

export const updateCalendarBotBody = zod
  .object({
    series_id: zod
      .string()
      .uuid()
      .regex(updateCalendarBotBodySeriesIdRegExp)
      .describe(
        "The UUID of the event series to schedule bots for.\n\nBoth one-off and recurring events have a series_id. For recurring events, use 'all_occurrences' to schedule bots for all future occurrences."
      ),
    all_occurrences: zod
      .boolean()
      .describe(
        "Whether to schedule bots for all occurrences of the event series.\n\nIf `true`, bots will be scheduled for all future event instances in the series. If `false`, `event_id` must be provided to schedule a bot for a specific event instance.\n\nDefault: `false`"
      ),
    event_id: zod
      .string()
      .uuid()
      .regex(updateCalendarBotBodyEventIdRegExp)
      .optional()
      .describe(
        "The UUID of a specific event instance to schedule a bot for.\n\nRequired when `all_occurrences` is `false`. Use this to schedule a bot for a single occurrence of a recurring event or a specific one-off event. If `all_occurrences` is `true`, this parameter is ignored."
      )
  })
  .and(
    zod
      .object({
        bot_name: zod
          .string()
          .min(1)
          .max(updateCalendarBotBodyBotNameMax)
          .optional()
          .describe(
            "The name of the bot.\n\nThis name will be displayed as the bot's name in the meeting."
          ),
        bot_image: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            "The image URL of the bot's avatar.\n\nMust be a valid HTTPS URL pointing to a JPEG or PNG image. This image will be displayed as the bot's avatar in the meeting.\n\nThe recommended aspect ratio is 16:9 for best display across different platforms."
          ),
        recording_mode: zod
          .enum(["audio_only", "speaker_view", "gallery_view"])
          .default(updateCalendarBotBodyRecordingModeDefault)
          .describe(
            "The recording mode of the bot.\n\nDetermines what the bot records during the meeting:\n\n- `speaker_view`: Records the speaker's view (default). Shows the active speaker or presenter.\n- `audio_only`: Records only the audio without video.\n- `gallery_view`: Records the entire gallery view (coming soon).\n\nDefault: `speaker_view`"
          ),
        entry_message: zod
          .string()
          .max(updateCalendarBotBodyEntryMessageMaxOne)
          .or(zod.null())
          .optional()
          .describe(
            "The message that the bot will send when it joins the meeting.\n\nThis message will be posted in the meeting chat when the bot successfully joins.\n\nAvailable for Google Meet and Zoom meetings. Microsoft Teams does not support entry messages for guests outside of an organization.\n\nMaximum: 500 characters"
          ),
        timeout_config: zod
          .object({
            waiting_room_timeout: zod
              .number()
              .min(updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMin)
              .max(updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutMax)
              .default(updateCalendarBotBodyTimeoutConfigWaitingRoomTimeoutDefault)
              .describe(
                "The timeout in seconds for the bot to wait in the waiting room before leaving the meeting.\n\nIf the bot is placed in a waiting room and not admitted within this time, it will leave the meeting.\n\nNote: Google Meet has its own waiting room timeout (approximately 10 minutes). Setting a higher value for Google Meet meetings will have no effect, as Google Meet will deny entry to the bot after its own timeout.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
              ),
            no_one_joined_timeout: zod
              .number()
              .min(updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMin)
              .max(updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutMax)
              .default(updateCalendarBotBodyTimeoutConfigNoOneJoinedTimeoutDefault)
              .describe(
                "The timeout in seconds for the bot to wait for participants to join before leaving the meeting.\n\nIf no participants join the meeting within this time after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 2 minutes\nMaximum: 30 minutes"
              ),
            silence_timeout: zod
              .number()
              .min(updateCalendarBotBodyTimeoutConfigSilenceTimeoutMin)
              .max(updateCalendarBotBodyTimeoutConfigSilenceTimeoutMax)
              .default(updateCalendarBotBodyTimeoutConfigSilenceTimeoutDefault)
              .describe(
                "The timeout in seconds for the bot to wait for silence before leaving the meeting.\n\nIf no audio is detected for this duration after the bot joins, the bot will leave the meeting. Only applicable for Google Meet and Microsoft Teams meetings.\n\nDefault: 600 seconds (10 minutes)\nMinimum: 5 minutes\nMaximum: 30 minutes"
              )
          })
          .default(updateCalendarBotBodyTimeoutConfigDefault)
          .describe(
            "Configuration for automatic meeting exit behavior. For Google Meet and Microsoft Teams, the bot uses waiting_room_timeout to wait in the waiting room, then no_one_joined_timeout to wait for participants when first joining the meeting, and finally switches to silence_timeout monitoring once participants are detected. Zoom only uses waiting_room_timeout."
          ),
        zoom_access_token_url: zod
          .string()
          .url()
          .or(zod.null())
          .optional()
          .describe(
            'The URL to get the Zoom access token (ZAK - Zoom Access Token).\n\nThis is required for Zoom meetings where the bot needs to join in the absence of the host. The bot will make a GET request to this URL to retrieve the access token. Follow the guide in Zoom to understand how to get Zoom Access Token at https://developers.zoom.us/docs/api/users/#tag/users/get/users/me/zak.\n\n**Expected Response Format:**\n\n- **HTTP Method:** GET\n- **Response Status:** 2xx (success)\n- **Response Body:** Plain text (ASCII) containing the Zoom access token directly\n- **Content-Type:** `text/plain` (or any text-based content type)\n- **Timeout:** The request will timeout after 15 seconds\n\n**Important Requirements:**\n\n- The response body must be plain ASCII text (not JSON, not binary)\n- The token must be a valid C string (no null bytes in the middle)\n- The token should be the raw access token string, not wrapped in JSON or any other format\n- Example response body: `\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpZCI6MX0...\"`\n\n**Error Handling:**\n\n- If the request fails, times out, or returns non-ASCII data, the bot will fail to join the meeting\n- Ensure your endpoint is reliable and returns a valid token within the timeout window\n\nOnly applicable for Zoom meetings. Leave as `null` for Google Meet and Microsoft Teams meetings.\n\nExample: \"https://your-api.com/zoom-token\"'
          ),
        extra: zod
          .record(zod.string(), zod.any())
          .or(zod.null())
          .optional()
          .describe(
            "An optional extra configuration object for the bot.\n\nThis object can contain any custom key-value pairs that you want to associate with the bot. The data will be:\n\n- Included in all webhook event payloads (if a webhook endpoint is configured)\n- Part of the callback payload (if callback is enabled)\n- Returned when fetching the bot's details via the API\n\nUseful for storing custom metadata, tracking information, or any other data you need to correlate with the bot."
          ),
        streaming_enabled: zod
          .boolean()
          .optional()
          .describe(
            "Enable or disable audio streaming for this bot.\n\n- Set to `true` to enable streaming (requires `streaming_config`)\n- Set to `false` to disable streaming (do not provide `streaming_config`)\n- Omit this field to leave streaming configuration unchanged\n\nIf you want to change streaming settings, you must provide both `streaming_enabled` and `streaming_config` together."
          ),
        streaming_config: zod
          .object({
            input_url: zod
              .string()
              .url()
              .or(zod.null())
              .optional()
              .describe(
                "Websocket stream URL, which receives the audio sent to the bot, and the bot will stream the audio to the meeting."
              ),
            output_url: zod
              .string()
              .url()
              .or(zod.null())
              .optional()
              .describe(
                "Websocket stream URL, which the bot sends the audio to. This is used to stream the output audio to a destination."
              ),
            audio_frequency: zod
              .number()
              .max(updateCalendarBotBodyStreamingConfigAudioFrequencyMaxOne)
              .or(zod.null())
              .default(updateCalendarBotBodyStreamingConfigAudioFrequencyDefault)
              .describe("The audio frequency in Hz. The default is 24000 Hz.")
          })
          .optional()
          .describe(
            "The streaming configuration for the bot.\n\nRequired when `streaming_enabled` is `true`. Must not be provided when `streaming_enabled` is `false`.\n\n- `input_url`: Websocket stream URL that receives audio sent to the bot\n- `output_url`: Websocket stream URL where the bot sends audio\n- `audio_frequency`: Audio frequency in Hz (default: 24000)\n\nOmit this field to leave streaming configuration unchanged."
          ),
        transcription_enabled: zod
          .boolean()
          .optional()
          .describe(
            "Enable or disable transcription for this bot.\n\n- Set to `true` to enable transcription (requires `transcription_config`)\n- Set to `false` to disable transcription (do not provide `transcription_config`)\n- Omit this field to leave transcription configuration unchanged\n\nIf you want to change transcription settings, you must provide both `transcription_enabled` and `transcription_config` together."
          ),
        transcription_config: zod
          .object({
            provider: zod
              .enum(["gladia"])
              .default(updateCalendarBotBodyTranscriptionConfigProviderDefault)
              .describe(
                "The speech to text provider to use for the bot. The default and only supported provider is 'gladia'. More providers will be supported in the future."
              ),
            api_key: zod
              .string()
              .or(zod.null())
              .optional()
              .describe(
                "The API key to use for the speech to text provider. This can be provided to use your own API key for the speech to text provider. It consumes less tokens than using the default API key. It is available on 'Pro' plans and above."
              ),
            custom_params: zod
              .record(zod.string(), zod.any())
              .or(zod.null())
              .optional()
              .describe(
                "Custom parameters for the transcription provider. See the transcription provider's documentation for available options. For Gladia, see https://docs.gladia.io/api-reference/v2/pre-recorded/init"
              )
          })
          .optional()
          .describe(
            'The transcription configuration for the bot.\n\nRequired when `transcription_enabled` is `true`. Must not be provided when `transcription_enabled` is `false`.\n\n- `provider`: Speech-to-text provider (default: \"gladia\")\n- `api_key`: Your own API key for the provider (BYOK - available on Pro plans and above)\n- `custom_params`: Custom parameters for transcription (see Gladia API documentation)\n\nOmit this field to leave transcription configuration unchanged.'
          ),
        callback_enabled: zod
          .boolean()
          .optional()
          .describe(
            "Enable or disable callback for this bot.\n\n- Set to `true` to enable callback (requires `callback_config`)\n- Set to `false` to disable callback (do not provide `callback_config`)\n- Omit this field to leave callback configuration unchanged\n\nIf you want to change callback settings, you must provide both `callback_enabled` and `callback_config` together."
          ),
        callback_config: zod
          .object({
            url: zod
              .string()
              .url()
              .describe("The URL to be called upon the completion or failure of the bot."),
            secret: zod
              .string()
              .or(zod.null())
              .optional()
              .describe(
                "To ensure that you can validate the callback, this secret will be added to the request in the 'x-mb-secret' header"
              ),
            method: zod
              .enum(["POST", "PUT"])
              .default(updateCalendarBotBodyCallbackConfigMethodDefault)
              .describe(
                "The HTTP method to use for the callback. Allowed values are 'POST' or 'PUT'."
              )
          })
          .optional()
          .describe(
            "The callback configuration for the bot.\n\nRequired when `callback_enabled` is `true`. Must not be provided when `callback_enabled` is `false`.\n\n- `url`: The URL to be called upon completion or failure of the bot\n- `secret`: Secret for HMAC validation (sent in `x-mb-secret` header)\n- `method`: HTTP method (`POST` or `PUT`, default: `POST`)\n\nOmit this field to leave callback configuration unchanged."
          )
      })
      .describe(
        "Partial update of bot configuration. Only provide the fields you want to update. All fields are optional."
      )
  )

export const updateCalendarBotResponseDataItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const updateCalendarBotResponseErrorsItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const updateCalendarBotResponse = zod.object({
  success: zod.boolean(),
  data: zod
    .array(
      zod.object({
        event_id: zod
          .string()
          .uuid()
          .regex(updateCalendarBotResponseDataItemEventIdRegExp)
          .describe(
            "The UUID of the event instance that was successfully scheduled for bot recording"
          )
      })
    )
    .describe("Event instances whose calendar bots were successfully updated"),
  errors: zod
    .array(
      zod.object({
        event_id: zod
          .string()
          .uuid()
          .regex(updateCalendarBotResponseErrorsItemEventIdRegExp)
          .describe(
            "The UUID of the event instance that failed to be scheduled. Use this to identify which specific event could not be scheduled"
          ),
        code: zod
          .string()
          .describe(
            "Error code for programmatic handling. This is a machine-readable identifier that indicates the type of error that occurred"
          ),
        message: zod
          .string()
          .describe(
            "Human-readable error message explaining why the scheduling failed for this event instance"
          ),
        details: zod
          .string()
          .or(zod.null())
          .describe(
            "Additional error details providing more context about the failure. Null if no additional details are available"
          )
      })
    )
    .describe(
      "Array of errors for event instances whose calendar bots could not be updated. This array is empty if all requested event instances were successfully updated"
    )
})

/**
 * Cancel one or more scheduled calendar bots.
    
    You can target a single event or all occurrences in a series using `series_id`, `all_occurrences`, and `event_id` in the request body. Bots must be in `scheduled` status and the join time must be at least 4 minutes in the future.
    
    **Cancellation Targets:**
    - `event_id`: Cancel bot for a specific event instance
    - `series_id`: Cancel bots for all occurrences of a series
    - `all_occurrences`: Cancel all future occurrences (for recurring events)
    
    **Status Requirements:** Bots must be in `scheduled` status. Bots that have already joined (`completed`) or failed (`failed`) cannot be cancelled via this endpoint. If a bot is in an invalid state, that bot will fail to cancel, but other bots may still be cancelled.
    
    **Join Time Requirements:** The join time must be at least 4 minutes in the future. If the join time is too close, the request will fail with 409 Conflict. This ensures the bot can be updated before it starts processing.
    
    **Partial Cancellation:** If cancelling multiple bots (e.g., all occurrences of a series), some bots may fail to cancel (e.g., if they're not in `scheduled` status). The response includes information about which bots were cancelled and which failed.
    
    **Irreversible Operation:** Once a calendar bot is cancelled, it cannot be recovered. If you need to cancel a bot that is about to join, you should use the leave endpoint on the actual bot instance instead.
    
    **No Token Impact:** Since tokens are not reserved for calendar bots, cancelling a bot does not affect your token balance.
    
    Returns 200 with cancellation results. Returns 404 if the event or calendar bot schedule is not found, or 409 if the bot's status does not allow deletion.
 * @summary Cancel calendar bot
 */
export const deleteCalendarBotPathCalendarIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteCalendarBotParams = zod.object({
  calendar_id: zod
    .string()
    .uuid()
    .regex(deleteCalendarBotPathCalendarIdRegExp)
    .describe("The unique identifier of the calendar that contains the event.")
})

export const deleteCalendarBotBodySeriesIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const deleteCalendarBotBodyAllOccurrencesDefault = false
export const deleteCalendarBotBodyEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteCalendarBotBody = zod.object({
  series_id: zod
    .string()
    .uuid()
    .regex(deleteCalendarBotBodySeriesIdRegExp)
    .describe(
      "The UUID of the event series to schedule bots for.\n\nBoth one-off and recurring events have a series_id. For recurring events, use 'all_occurrences' to schedule bots for all future occurrences."
    ),
  all_occurrences: zod
    .boolean()
    .describe(
      "Whether to schedule bots for all occurrences of the event series.\n\nIf `true`, bots will be scheduled for all future event instances in the series. If `false`, `event_id` must be provided to schedule a bot for a specific event instance.\n\nDefault: `false`"
    ),
  event_id: zod
    .string()
    .uuid()
    .regex(deleteCalendarBotBodyEventIdRegExp)
    .optional()
    .describe(
      "The UUID of a specific event instance to schedule a bot for.\n\nRequired when `all_occurrences` is `false`. Use this to schedule a bot for a single occurrence of a recurring event or a specific one-off event. If `all_occurrences` is `true`, this parameter is ignored."
    )
})

export const deleteCalendarBotResponseDataItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/
export const deleteCalendarBotResponseErrorsItemEventIdRegExp =
  /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/

export const deleteCalendarBotResponse = zod.object({
  success: zod.boolean(),
  data: zod
    .array(
      zod.object({
        event_id: zod
          .string()
          .uuid()
          .regex(deleteCalendarBotResponseDataItemEventIdRegExp)
          .describe(
            "The UUID of the event instance that was successfully scheduled for bot recording"
          )
      })
    )
    .describe("Event instances whose calendar bots were successfully deleted/cancelled"),
  errors: zod
    .array(
      zod.object({
        event_id: zod
          .string()
          .uuid()
          .regex(deleteCalendarBotResponseErrorsItemEventIdRegExp)
          .describe(
            "The UUID of the event instance that failed to be scheduled. Use this to identify which specific event could not be scheduled"
          ),
        code: zod
          .string()
          .describe(
            "Error code for programmatic handling. This is a machine-readable identifier that indicates the type of error that occurred"
          ),
        message: zod
          .string()
          .describe(
            "Human-readable error message explaining why the scheduling failed for this event instance"
          ),
        details: zod
          .string()
          .or(zod.null())
          .describe(
            "Additional error details providing more context about the failure. Null if no additional details are available"
          )
      })
    )
    .describe(
      "Array of errors for event instances whose calendar bots could not be deleted. This array is empty if all requested event instances were successfully deleted"
    )
})
