/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Soniox Public API
 * OpenAPI spec version: 1.0.0
 */
import axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  CreateTemporaryApiKeyPayload,
  CreateTranscriptionPayload,
  GetFilesParams,
  GetTranscriptionsParams,
  UploadFileBody
} from '../schema';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import {
  TranscriptionMode,
  TranscriptionStatus
} from '../schema';
import type {
  CreateTemporaryApiKeyResponse,
  File,
  FileUrl,
  GetFilesResponse,
  GetModelsResponse,
  GetTranscriptionsResponse,
  Transcription,
  TranscriptionTranscript
} from '../schema';

/**
 * Retrieves list of uploaded files.
 * @summary Get files
 */
export const getFiles = <TData = AxiosResponse<GetFilesResponse>>(
    params?: GetFilesParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/files`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Uploads a new file.
 * @summary Upload file
 */
export const uploadFile = <TData = AxiosResponse<File>>(
    uploadFileBody: UploadFileBody, options?: AxiosRequestConfig
 ): Promise<TData> => {const formData = new FormData();
if(uploadFileBody.client_reference_id !== undefined && uploadFileBody.client_reference_id !== null) {
 formData.append(`client_reference_id`, uploadFileBody.client_reference_id)
 }
formData.append(`file`, uploadFileBody.file)

    return axios.post(
      `/v1/files`,
      formData,options
    );
  }

/**
 * Retrieve metadata for an uploaded file.
 * @summary Get file
 */
export const getFile = <TData = AxiosResponse<File>>(
    fileId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/files/${fileId}`,options
    );
  }

/**
 * Permanently deletes specified file.
 * @summary Delete file
 */
export const deleteFile = <TData = AxiosResponse<void>>(
    fileId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/v1/files/${fileId}`,options
    );
  }

/**
 * Get a temporary file URL. URL is valid for 1 hour.
 * @summary Get file URL
 */
export const getFileUrl = <TData = AxiosResponse<FileUrl>>(
    fileId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/files/${fileId}/url`,options
    );
  }

/**
 * Retrieves list of transcriptions.
 * @summary Get transcriptions
 */
export const getTranscriptions = <TData = AxiosResponse<GetTranscriptionsResponse>>(
    params?: GetTranscriptionsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/transcriptions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * Creates a new transcription.
 * @summary Create transcription
 */
export const createTranscription = <TData = AxiosResponse<Transcription>>(
    createTranscriptionPayload: CreateTranscriptionPayload, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/v1/transcriptions`,
      createTranscriptionPayload,options
    );
  }

/**
 * Retrieves detailed information about a specific transcription.
 * @summary Get transcription
 */
export const getTranscription = <TData = AxiosResponse<Transcription>>(
    transcriptionId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/transcriptions/${transcriptionId}`,options
    );
  }

/**
 * Permanently deletes a transcription and its associated files. Cannot delete transcriptions that are currently processing.
 * @summary Delete transcription
 */
export const deleteTranscription = <TData = AxiosResponse<void>>(
    transcriptionId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.delete(
      `/v1/transcriptions/${transcriptionId}`,options
    );
  }

/**
 * Retrieves the full transcript text and detailed tokens for a completed transcription. Only available for successfully completed transcriptions.
 * @summary Get transcription transcript
 */
export const getTranscriptionTranscript = <TData = AxiosResponse<TranscriptionTranscript>>(
    transcriptionId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/transcriptions/${transcriptionId}/transcript`,options
    );
  }

/**
 * Retrieves list of available models and their attributes.
 * @summary Get models
 */
export const getModels = <TData = AxiosResponse<GetModelsResponse>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.get(
      `/v1/models`,options
    );
  }

/**
 * Creates a short-lived API key for specific temporary use cases. The key will automatically expire after the specified duration.
 * @summary Create temporary API key
 */
export const createTemporaryApiKey = <TData = AxiosResponse<CreateTemporaryApiKeyResponse>>(
    createTemporaryApiKeyPayload: CreateTemporaryApiKeyPayload, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.post(
      `/v1/auth/temporary-api-key`,
      createTemporaryApiKeyPayload,options
    );
  }

export type GetFilesResult = AxiosResponse<GetFilesResponse>
export type UploadFileResult = AxiosResponse<File>
export type GetFileResult = AxiosResponse<File>
export type DeleteFileResult = AxiosResponse<void>
export type GetFileUrlResult = AxiosResponse<FileUrl>
export type GetTranscriptionsResult = AxiosResponse<GetTranscriptionsResponse>
export type CreateTranscriptionResult = AxiosResponse<Transcription>
export type GetTranscriptionResult = AxiosResponse<Transcription>
export type DeleteTranscriptionResult = AxiosResponse<void>
export type GetTranscriptionTranscriptResult = AxiosResponse<TranscriptionTranscript>
export type GetModelsResult = AxiosResponse<GetModelsResponse>
export type CreateTemporaryApiKeyResult = AxiosResponse<CreateTemporaryApiKeyResponse>


export const getGetFilesResponseMock = (overrideResponse: Partial< GetFilesResponse > = {}): GetFilesResponse => ({files: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), filename: faker.string.alpha(20), size: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined])})), next_page_cursor: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getUploadFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({id: faker.string.uuid(), filename: faker.string.alpha(20), size: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getGetFileResponseMock = (overrideResponse: Partial< File > = {}): File => ({id: faker.string.uuid(), filename: faker.string.alpha(20), size: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getGetFileUrlResponseMock = (overrideResponse: Partial< FileUrl > = {}): FileUrl => ({url: faker.string.alpha(20), ...overrideResponse})

export const getGetTranscriptionsResponseMock = (overrideResponse: Partial< GetTranscriptionsResponse > = {}): GetTranscriptionsResponse => ({transcriptions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), status: faker.helpers.arrayElement(Object.values(TranscriptionStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, model: faker.string.alpha(20), audio_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), file_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(),null,]), undefined]), filename: faker.string.alpha(20), language_hints: faker.helpers.arrayElement([faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))),null,]), undefined]), enable_speaker_diarization: faker.datatype.boolean(), enable_language_identification: faker.datatype.boolean(), audio_duration_ms: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), error_type: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_name: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_status_code: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined])})), next_page_cursor: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getCreateTranscriptionResponseMock = (overrideResponse: Partial< Transcription > = {}): Transcription => ({id: faker.string.uuid(), status: faker.helpers.arrayElement(Object.values(TranscriptionStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, model: faker.string.alpha(20), audio_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), file_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(),null,]), undefined]), filename: faker.string.alpha(20), language_hints: faker.helpers.arrayElement([faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))),null,]), undefined]), enable_speaker_diarization: faker.datatype.boolean(), enable_language_identification: faker.datatype.boolean(), audio_duration_ms: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), error_type: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_name: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_status_code: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getGetTranscriptionResponseMock = (overrideResponse: Partial< Transcription > = {}): Transcription => ({id: faker.string.uuid(), status: faker.helpers.arrayElement(Object.values(TranscriptionStatus)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, model: faker.string.alpha(20), audio_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), file_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(),null,]), undefined]), filename: faker.string.alpha(20), language_hints: faker.helpers.arrayElement([faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))),null,]), undefined]), enable_speaker_diarization: faker.datatype.boolean(), enable_language_identification: faker.datatype.boolean(), audio_duration_ms: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), error_type: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_name: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_auth_header_value: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), webhook_status_code: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), undefined]), client_reference_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), ...overrideResponse})

export const getGetTranscriptionTranscriptResponseMock = (overrideResponse: Partial< TranscriptionTranscript > = {}): TranscriptionTranscript => ({id: faker.string.uuid(), text: faker.string.alpha(20), tokens: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({text: faker.string.alpha(20), start_ms: faker.number.int({min: undefined, max: undefined}), end_ms: faker.number.int({min: undefined, max: undefined}), confidence: faker.number.int({min: undefined, max: undefined}), speaker: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined]), is_audio_event: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.datatype.boolean(),null,]), undefined]), translation_status: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20),null,]), undefined])})), ...overrideResponse})

export const getGetModelsResponseMock = (overrideResponse: Partial< GetModelsResponse > = {}): GetModelsResponse => ({models: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha(20), aliased_model_id: faker.helpers.arrayElement([faker.string.alpha(20),null,]), name: faker.string.alpha(20), context_version: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}),null,]), transcription_mode: faker.helpers.arrayElement(Object.values(TranscriptionMode)), languages: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({code: faker.string.alpha(20), name: faker.string.alpha(20)})), supports_language_hints_strict: faker.datatype.boolean(), translation_targets: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({target_language: faker.string.alpha(20), source_languages: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), exclude_source_languages: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20)))})), two_way_translation_pairs: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), one_way_translation: faker.helpers.arrayElement([faker.string.alpha(20),null,]), two_way_translation: faker.helpers.arrayElement([faker.string.alpha(20),null,])})), ...overrideResponse})

export const getCreateTemporaryApiKeyResponseMock = (overrideResponse: Partial< CreateTemporaryApiKeyResponse > = {}): CreateTemporaryApiKeyResponse => ({api_key: faker.string.alpha(20), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})


export const getGetFilesMockHandler = (overrideResponse?: GetFilesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetFilesResponse> | GetFilesResponse)) => {
  return http.get('https://api.soniox.com/v1/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetFilesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getUploadFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<File> | File)) => {
  return http.post('https://api.soniox.com/v1/files', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUploadFileResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetFileMockHandler = (overrideResponse?: File | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<File> | File)) => {
  return http.get('https://api.soniox.com/v1/files/:fileId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetFileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteFileMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.soniox.com/v1/files/:fileId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getGetFileUrlMockHandler = (overrideResponse?: FileUrl | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FileUrl> | FileUrl)) => {
  return http.get('https://api.soniox.com/v1/files/:fileId/url', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetFileUrlResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetTranscriptionsMockHandler = (overrideResponse?: GetTranscriptionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetTranscriptionsResponse> | GetTranscriptionsResponse)) => {
  return http.get('https://api.soniox.com/v1/transcriptions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTranscriptionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getCreateTranscriptionMockHandler = (overrideResponse?: Transcription | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Transcription> | Transcription)) => {
  return http.post('https://api.soniox.com/v1/transcriptions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateTranscriptionResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetTranscriptionMockHandler = (overrideResponse?: Transcription | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Transcription> | Transcription)) => {
  return http.get('https://api.soniox.com/v1/transcriptions/:transcriptionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTranscriptionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteTranscriptionMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('https://api.soniox.com/v1/transcriptions/:transcriptionId', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getGetTranscriptionTranscriptMockHandler = (overrideResponse?: TranscriptionTranscript | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<TranscriptionTranscript> | TranscriptionTranscript)) => {
  return http.get('https://api.soniox.com/v1/transcriptions/:transcriptionId/transcript', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTranscriptionTranscriptResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetModelsMockHandler = (overrideResponse?: GetModelsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetModelsResponse> | GetModelsResponse)) => {
  return http.get('https://api.soniox.com/v1/models', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetModelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getCreateTemporaryApiKeyMockHandler = (overrideResponse?: CreateTemporaryApiKeyResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateTemporaryApiKeyResponse> | CreateTemporaryApiKeyResponse)) => {
  return http.post('https://api.soniox.com/v1/auth/temporary-api-key', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateTemporaryApiKeyResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getSonioxPublicAPIMock = () => [
  getGetFilesMockHandler(),
  getUploadFileMockHandler(),
  getGetFileMockHandler(),
  getDeleteFileMockHandler(),
  getGetFileUrlMockHandler(),
  getGetTranscriptionsMockHandler(),
  getCreateTranscriptionMockHandler(),
  getGetTranscriptionMockHandler(),
  getDeleteTranscriptionMockHandler(),
  getGetTranscriptionTranscriptMockHandler(),
  getGetModelsMockHandler(),
  getCreateTemporaryApiKeyMockHandler()]
