/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Soniox Public API
 * OpenAPI spec version: 1.0.0
 */
import { z as zod } from "zod"

/**
 * Retrieves list of uploaded files.
 * @summary Get files
 */
export const getFilesQueryLimitDefault = 1000
export const getFilesQueryLimitMax = 1000

export const getFilesQueryParams = zod.object({
  limit: zod
    .number()
    .min(1)
    .max(getFilesQueryLimitMax)
    .default(getFilesQueryLimitDefault)
    .describe("Maximum number of files to return."),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe("Pagination cursor for the next page of results.")
})

export const getFilesResponse = zod
  .object({
    files: zod
      .array(
        zod
          .object({
            id: zod.string().uuid().describe("Unique identifier of the file."),
            filename: zod.string().describe("Name of the file."),
            size: zod.number().describe("Size of the file in bytes."),
            created_at: zod
              .string()
              .datetime({})
              .describe("UTC timestamp indicating when the file was uploaded."),
            client_reference_id: zod
              .string()
              .or(zod.null())
              .optional()
              .describe("Tracking identifier string.")
          })
          .describe("File metadata.")
      )
      .describe("List of uploaded files."),
    next_page_cursor: zod
      .string()
      .or(zod.null())
      .optional()
      .describe(
        "A pagination token that references the next page of results. When more data is available, this field contains a value to pass in the cursor parameter of a subsequent request. When null, no additional results are available."
      )
  })
  .describe("A list of files.")

/**
 * Uploads a new file.
 * @summary Upload file
 */
export const uploadFileBodyClientReferenceIdMaxOne = 256

export const uploadFileBody = zod.object({
  client_reference_id: zod
    .string()
    .max(uploadFileBodyClientReferenceIdMaxOne)
    .or(zod.null())
    .optional()
    .describe("Optional tracking identifier string. Does not need to be unique."),
  file: zod
    .instanceof(File)
    .describe(
      "The file to upload. Original file name will be used unless a custom filename is provided."
    )
})

/**
 * Retrieve metadata for an uploaded file.
 * @summary Get file
 */
export const getFileParams = zod.object({
  file_id: zod.string().uuid()
})

export const getFileResponse = zod
  .object({
    id: zod.string().uuid().describe("Unique identifier of the file."),
    filename: zod.string().describe("Name of the file."),
    size: zod.number().describe("Size of the file in bytes."),
    created_at: zod
      .string()
      .datetime({})
      .describe("UTC timestamp indicating when the file was uploaded."),
    client_reference_id: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("Tracking identifier string.")
  })
  .describe("File metadata.")

/**
 * Permanently deletes specified file.
 * @summary Delete file
 */
export const deleteFileParams = zod.object({
  file_id: zod.string().uuid()
})

/**
 * Get a temporary file URL. URL is valid for 1 hour.
 * @summary Get file URL
 */
export const getFileUrlParams = zod.object({
  file_id: zod.string().uuid()
})

export const getFileUrlResponse = zod
  .object({
    url: zod.string().describe("Temporary file URL.")
  })
  .describe("Temporary file URL.")

/**
 * Retrieves list of transcriptions.
 * @summary Get transcriptions
 */
export const getTranscriptionsQueryLimitDefault = 1000
export const getTranscriptionsQueryLimitMax = 1000

export const getTranscriptionsQueryParams = zod.object({
  limit: zod
    .number()
    .min(1)
    .max(getTranscriptionsQueryLimitMax)
    .default(getTranscriptionsQueryLimitDefault)
    .describe("Maximum number of transcriptions to return."),
  cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe("Pagination cursor for the next page of results.")
})

export const getTranscriptionsResponse = zod.object({
  transcriptions: zod
    .array(
      zod
        .object({
          id: zod.string().uuid().describe("Unique identifier for the transcription request."),
          status: zod
            .enum(["queued", "processing", "completed", "error"])
            .describe("Transcription status."),
          created_at: zod
            .string()
            .datetime({})
            .describe("UTC timestamp indicating when the transcription was created."),
          model: zod.string().describe("Speech-to-text model used for the transcription."),
          audio_url: zod
            .string()
            .or(zod.null())
            .optional()
            .describe("URL of the file being transcribed."),
          file_id: zod
            .string()
            .uuid()
            .or(zod.null())
            .optional()
            .describe("ID of the file being transcribed."),
          filename: zod.string().describe("Name of the file being transcribed."),
          language_hints: zod
            .array(zod.string())
            .or(zod.null())
            .optional()
            .describe(
              "Expected languages in the audio. If not specified, languages are automatically detected."
            ),
          enable_speaker_diarization: zod
            .boolean()
            .describe(
              "When `true`, speakers are identified and separated in the transcription output."
            ),
          enable_language_identification: zod
            .boolean()
            .describe("When `true`, language is detected for each part of the transcription."),
          audio_duration_ms: zod
            .number()
            .or(zod.null())
            .optional()
            .describe(
              "Duration of the audio in milliseconds. Only available after processing begins."
            ),
          error_type: zod
            .string()
            .or(zod.null())
            .optional()
            .describe(
              "Error type if transcription failed. `null` for successful or in-progress transcriptions."
            ),
          error_message: zod
            .string()
            .or(zod.null())
            .optional()
            .describe(
              "Error message if transcription failed. `null` for successful or in-progress transcriptions."
            ),
          webhook_url: zod
            .string()
            .or(zod.null())
            .optional()
            .describe(
              "URL to receive webhook notifications when transcription is completed or fails."
            ),
          webhook_auth_header_name: zod
            .string()
            .or(zod.null())
            .optional()
            .describe("Name of the authentication header sent with webhook notifications."),
          webhook_auth_header_value: zod
            .string()
            .or(zod.null())
            .optional()
            .describe(
              "Authentication header value. Always returned masked as `******************`."
            ),
          webhook_status_code: zod
            .number()
            .or(zod.null())
            .optional()
            .describe(
              "HTTP status code received from your server when webhook was delivered. `null` if not yet sent."
            ),
          client_reference_id: zod
            .string()
            .or(zod.null())
            .optional()
            .describe("Tracking identifier string.")
        })
        .describe("A transcription.")
    )
    .describe("List of transcriptions."),
  next_page_cursor: zod
    .string()
    .or(zod.null())
    .optional()
    .describe(
      "A pagination token that references the next page of results. When more data is available, this field contains a value to pass in the cursor parameter of a subsequent request. When null, no additional results are available."
    )
})

/**
 * Creates a new transcription.
 * @summary Create transcription
 */
export const createTranscriptionBodyModelMaxThree = 32
export const createTranscriptionBodyAudioUrlMaxOne = 4096
export const createTranscriptionBodyAudioUrlRegExpOne = /^https?:\/\/[^\s]+$/
export const createTranscriptionBodyLanguageHintsItemMax = 10
export const createTranscriptionBodyLanguageHintsMaxOne = 100
export const createTranscriptionBodyWebhookUrlMaxOne = 256
export const createTranscriptionBodyWebhookUrlRegExpOne = /^https?:\/\/[^\s]+$/
export const createTranscriptionBodyWebhookAuthHeaderNameMaxOne = 256
export const createTranscriptionBodyWebhookAuthHeaderValueMaxOne = 256
export const createTranscriptionBodyClientReferenceIdMaxOne = 256

export const createTranscriptionBody = zod.object({
  model: zod
    .string()
    .max(createTranscriptionBodyModelMaxThree)
    .describe("Speech-to-text model to use for the transcription."),
  audio_url: zod
    .string()
    .max(createTranscriptionBodyAudioUrlMaxOne)
    .regex(createTranscriptionBodyAudioUrlRegExpOne)
    .or(zod.null())
    .optional()
    .describe(
      "URL of the audio file to transcribe. Cannot be specified if `file_id` is specified."
    ),
  file_id: zod
    .string()
    .uuid()
    .or(zod.null())
    .optional()
    .describe(
      "ID of the uploaded file to transcribe. Cannot be specified if `audio_url` is specified."
    ),
  language_hints: zod
    .array(zod.string().max(createTranscriptionBodyLanguageHintsItemMax))
    .max(createTranscriptionBodyLanguageHintsMaxOne)
    .or(zod.null())
    .optional()
    .describe(
      "Expected languages in the audio. If not specified, languages are automatically detected."
    ),
  language_hints_strict: zod
    .boolean()
    .or(zod.null())
    .optional()
    .describe("When `true`, the model will rely more on language hints."),
  enable_speaker_diarization: zod
    .boolean()
    .or(zod.null())
    .optional()
    .describe("When `true`, speakers are identified and separated in the transcription output."),
  enable_language_identification: zod
    .boolean()
    .or(zod.null())
    .optional()
    .describe("When `true`, language is detected for each part of the transcription."),
  translation: zod
    .object({
      type: zod.enum(["one_way", "two_way"]),
      target_language: zod.string().or(zod.null()).optional(),
      language_a: zod.string().or(zod.null()).optional(),
      language_b: zod.string().or(zod.null()).optional()
    })
    .or(zod.null())
    .optional()
    .describe("Translation configuration."),
  context: zod
    .object({
      general: zod
        .array(
          zod.object({
            key: zod.string().describe('Item key (e.g. "Domain").'),
            value: zod.string().describe('Item value (e.g. "medicine").')
          })
        )
        .or(zod.null())
        .optional()
        .describe("General context items."),
      text: zod.string().or(zod.null()).optional().describe("Text context."),
      terms: zod
        .array(zod.string())
        .or(zod.null())
        .optional()
        .describe("Terms that might occur in speech."),
      translation_terms: zod
        .array(
          zod.object({
            source: zod.string().describe("Source term."),
            target: zod.string().describe("Target term to translate to.")
          })
        )
        .or(zod.null())
        .optional()
        .describe("Hints how to translate specific terms. Ignored if translation is not enabled.")
    })
    .or(zod.string())
    .or(zod.null())
    .optional()
    .describe(
      "Additional context to improve transcription accuracy and formatting of specialized terms."
    ),
  webhook_url: zod
    .string()
    .max(createTranscriptionBodyWebhookUrlMaxOne)
    .regex(createTranscriptionBodyWebhookUrlRegExpOne)
    .or(zod.null())
    .optional()
    .describe("URL to receive webhook notifications when transcription is completed or fails."),
  webhook_auth_header_name: zod
    .string()
    .max(createTranscriptionBodyWebhookAuthHeaderNameMaxOne)
    .or(zod.null())
    .optional()
    .describe("Name of the authentication header sent with webhook notifications."),
  webhook_auth_header_value: zod
    .string()
    .max(createTranscriptionBodyWebhookAuthHeaderValueMaxOne)
    .or(zod.null())
    .optional()
    .describe("Authentication header value sent with webhook notifications."),
  client_reference_id: zod
    .string()
    .max(createTranscriptionBodyClientReferenceIdMaxOne)
    .or(zod.null())
    .optional()
    .describe("Optional tracking identifier string. Does not need to be unique.")
})

/**
 * Retrieves detailed information about a specific transcription.
 * @summary Get transcription
 */
export const getTranscriptionParams = zod.object({
  transcription_id: zod.string().uuid()
})

export const getTranscriptionResponse = zod
  .object({
    id: zod.string().uuid().describe("Unique identifier for the transcription request."),
    status: zod
      .enum(["queued", "processing", "completed", "error"])
      .describe("Transcription status."),
    created_at: zod
      .string()
      .datetime({})
      .describe("UTC timestamp indicating when the transcription was created."),
    model: zod.string().describe("Speech-to-text model used for the transcription."),
    audio_url: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("URL of the file being transcribed."),
    file_id: zod
      .string()
      .uuid()
      .or(zod.null())
      .optional()
      .describe("ID of the file being transcribed."),
    filename: zod.string().describe("Name of the file being transcribed."),
    language_hints: zod
      .array(zod.string())
      .or(zod.null())
      .optional()
      .describe(
        "Expected languages in the audio. If not specified, languages are automatically detected."
      ),
    enable_speaker_diarization: zod
      .boolean()
      .describe("When `true`, speakers are identified and separated in the transcription output."),
    enable_language_identification: zod
      .boolean()
      .describe("When `true`, language is detected for each part of the transcription."),
    audio_duration_ms: zod
      .number()
      .or(zod.null())
      .optional()
      .describe("Duration of the audio in milliseconds. Only available after processing begins."),
    error_type: zod
      .string()
      .or(zod.null())
      .optional()
      .describe(
        "Error type if transcription failed. `null` for successful or in-progress transcriptions."
      ),
    error_message: zod
      .string()
      .or(zod.null())
      .optional()
      .describe(
        "Error message if transcription failed. `null` for successful or in-progress transcriptions."
      ),
    webhook_url: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("URL to receive webhook notifications when transcription is completed or fails."),
    webhook_auth_header_name: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("Name of the authentication header sent with webhook notifications."),
    webhook_auth_header_value: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("Authentication header value. Always returned masked as `******************`."),
    webhook_status_code: zod
      .number()
      .or(zod.null())
      .optional()
      .describe(
        "HTTP status code received from your server when webhook was delivered. `null` if not yet sent."
      ),
    client_reference_id: zod
      .string()
      .or(zod.null())
      .optional()
      .describe("Tracking identifier string.")
  })
  .describe("A transcription.")

/**
 * Permanently deletes a transcription and its associated files. Cannot delete transcriptions that are currently processing.
 * @summary Delete transcription
 */
export const deleteTranscriptionParams = zod.object({
  transcription_id: zod.string().uuid()
})

/**
 * Retrieves the full transcript text and detailed tokens for a completed transcription. Only available for successfully completed transcriptions.
 * @summary Get transcription transcript
 */
export const getTranscriptionTranscriptParams = zod.object({
  transcription_id: zod.string().uuid()
})

export const getTranscriptionTranscriptResponse = zod
  .object({
    id: zod
      .string()
      .uuid()
      .describe("Unique identifier of the transcription this transcript belongs to."),
    text: zod.string().describe("Complete transcribed text content."),
    tokens: zod
      .array(
        zod
          .object({
            text: zod.string().describe("Token text content."),
            start_ms: zod.number().describe("Start time of the token in milliseconds."),
            end_ms: zod.number().describe("End time of the token in milliseconds."),
            confidence: zod
              .number()
              .describe("Confidence score of the token, between 0.0 and 1.0."),
            speaker: zod
              .string()
              .or(zod.null())
              .optional()
              .describe("Speaker identifier. Only present when speaker diarization is enabled."),
            language: zod
              .string()
              .or(zod.null())
              .optional()
              .describe(
                "Detected language code for this token. Only present when language identification is enabled."
              ),
            is_audio_event: zod
              .boolean()
              .or(zod.null())
              .optional()
              .describe(
                "Boolean indicating if this token represents an audio event. Only present when audio event detection is enabled."
              ),
            translation_status: zod
              .string()
              .or(zod.null())
              .optional()
              .describe(
                'Translation status ("none", "original" or "translation"). Only when if translation is enabled.'
              )
          })
          .describe("The transcript token.")
      )
      .describe("List of detailed token information with timestamps and metadata.")
  })
  .describe("The transcription text.")

/**
 * Retrieves list of available models and their attributes.
 * @summary Get models
 */
export const getModelsResponse = zod.object({
  models: zod
    .array(
      zod.object({
        id: zod.string().describe("Unique identifier of the model."),
        aliased_model_id: zod
          .string()
          .or(zod.null())
          .describe("If this is an alias, the id of the aliased model."),
        name: zod.string().describe("Name of the model."),
        context_version: zod.number().or(zod.null()).describe("Version of context supported."),
        transcription_mode: zod
          .enum(["real_time", "async"])
          .describe("Transcription mode of the model."),
        languages: zod
          .array(
            zod.object({
              code: zod.string().describe("2-letter language code."),
              name: zod.string().describe("Language name.")
            })
          )
          .describe("List of languages supported by the model."),
        supports_language_hints_strict: zod.boolean(),
        translation_targets: zod
          .array(
            zod.object({
              target_language: zod.string(),
              source_languages: zod.array(zod.string()),
              exclude_source_languages: zod.array(zod.string())
            })
          )
          .describe(
            "List of supported one-way translation targets. If list is empty, check for one_way_translation field"
          ),
        two_way_translation_pairs: zod
          .array(zod.string())
          .describe(
            "List of supported two-way translation pairs.  If list is empty, check for two_way_translation field"
          ),
        one_way_translation: zod
          .string()
          .or(zod.null())
          .describe("When contains string 'all_languages', any laguage from languages can be used"),
        two_way_translation: zod
          .string()
          .or(zod.null())
          .describe(
            "When contains string 'all_languages',' any laguage pair from languages can be used"
          )
      })
    )
    .describe("List of available models and their attributes.")
})

/**
 * Creates a short-lived API key for specific temporary use cases. The key will automatically expire after the specified duration.
 * @summary Create temporary API key
 */
export const createTemporaryApiKeyBodyExpiresInSecondsMax = 3600
export const createTemporaryApiKeyBodyClientReferenceIdMaxOne = 256

export const createTemporaryApiKeyBody = zod.object({
  usage_type: zod
    .enum(["transcribe_websocket"])
    .describe("Intended usage of the temporary API key."),
  expires_in_seconds: zod
    .number()
    .min(1)
    .max(createTemporaryApiKeyBodyExpiresInSecondsMax)
    .describe("Duration in seconds until the temporary API key expires."),
  client_reference_id: zod
    .string()
    .max(createTemporaryApiKeyBodyClientReferenceIdMaxOne)
    .or(zod.null())
    .optional()
    .describe("Optional tracking identifier string. Does not need to be unique.")
})
