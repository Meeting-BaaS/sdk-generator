/*
 * AssemblyAI API
 *
 * AssemblyAI API
 *
 * The version of the OpenAPI document: 1.3.4
 * Contact: support@assemblyai.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};


/// struct for typed errors of method [`create_transcript`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTranscriptError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_transcript`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTranscriptError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_redacted_audio`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRedactedAudioError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subtitles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubtitlesError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transcript`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTranscriptError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transcript_paragraphs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTranscriptParagraphsError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transcript_sentences`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTranscriptSentencesError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_transcripts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTranscriptsError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadFileError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`word_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WordSearchError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    Status500(models::Error),
    Status503(),
    Status504(),
    UnknownValue(serde_json::Value),
}


/// <Note>To use our EU server for transcription, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Create a transcript from a media file that is accessible via a URL. 
pub async fn create_transcript(configuration: &configuration::Configuration, transcript_params: models::TranscriptParams) -> Result<models::Transcript, Error<CreateTranscriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_transcript_params = transcript_params;

    let uri_str = format!("{}/v2/transcript", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_transcript_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transcript`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transcript`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTranscriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To delete your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Remove the data from the transcript and mark it as deleted. <Warning>Files uploaded via the `/upload` endpoint are immediately deleted alongside the transcript when you make a DELETE request, ensuring your data is removed from our systems right away.</Warning> 
pub async fn delete_transcript(configuration: &configuration::Configuration, transcript_id: &str) -> Result<models::Transcript, Error<DeleteTranscriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;

    let uri_str = format!("{}/v2/transcript/{transcript_id}", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transcript`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transcript`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTranscriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve the redacted audio on the EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com` in the `GET` request above.</Note> Retrieve the redacted audio object containing the status and URL to the redacted audio. 
pub async fn get_redacted_audio(configuration: &configuration::Configuration, transcript_id: &str) -> Result<models::RedactedAudioResponse, Error<GetRedactedAudioError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;

    let uri_str = format!("{}/v2/transcript/{transcript_id}/redacted-audio", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RedactedAudioResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RedactedAudioResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRedactedAudioError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Export your transcript in SRT or VTT format to use with a video player for subtitles and closed captions. 
pub async fn get_subtitles(configuration: &configuration::Configuration, transcript_id: &str, subtitle_format: models::SubtitleFormat, chars_per_caption: Option<i32>) -> Result<String, Error<GetSubtitlesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;
    let p_path_subtitle_format = subtitle_format;
    let p_query_chars_per_caption = chars_per_caption;

    let uri_str = format!("{}/v2/transcript/{transcript_id}/{subtitle_format}", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id), subtitle_format=p_path_subtitle_format.to_string());
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_chars_per_caption {
        req_builder = req_builder.query(&[("chars_per_caption", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubtitlesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Get the transcript resource. The transcript is ready when the \"status\" is \"completed\". 
pub async fn get_transcript(configuration: &configuration::Configuration, transcript_id: &str) -> Result<models::Transcript, Error<GetTranscriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;

    let uri_str = format!("{}/v2/transcript/{transcript_id}", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Transcript`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Transcript`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTranscriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Get the transcript split by paragraphs. The API will attempt to semantically segment your transcript into paragraphs to create more reader-friendly transcripts. 
pub async fn get_transcript_paragraphs(configuration: &configuration::Configuration, transcript_id: &str) -> Result<models::ParagraphsResponse, Error<GetTranscriptParagraphsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;

    let uri_str = format!("{}/v2/transcript/{transcript_id}/paragraphs", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ParagraphsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ParagraphsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTranscriptParagraphsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Get the transcript split by sentences. The API will attempt to semantically segment the transcript into sentences to create more reader-friendly transcripts. 
pub async fn get_transcript_sentences(configuration: &configuration::Configuration, transcript_id: &str) -> Result<models::SentencesResponse, Error<GetTranscriptSentencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;

    let uri_str = format!("{}/v2/transcript/{transcript_id}/sentences", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SentencesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SentencesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTranscriptSentencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To retrieve your transcriptions on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Retrieve a list of transcripts you created. Transcripts are sorted from newest to oldest and can be retrieved for the last 90 days of usage. The previous URL always points to a page with older transcripts.  If you need to retrieve transcripts from more than 90 days ago please reach out to our Support team at support@assemblyai.com. 
pub async fn list_transcripts(configuration: &configuration::Configuration, limit: Option<i32>, status: Option<models::TranscriptStatus>, created_on: Option<String>, before_id: Option<&str>, after_id: Option<&str>, throttled_only: Option<bool>) -> Result<models::TranscriptList, Error<ListTranscriptsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_status = status;
    let p_query_created_on = created_on;
    let p_query_before_id = before_id;
    let p_query_after_id = after_id;
    let p_query_throttled_only = throttled_only;

    let uri_str = format!("{}/v2/transcript", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_before_id {
        req_builder = req_builder.query(&[("before_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after_id {
        req_builder = req_builder.query(&[("after_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_throttled_only {
        req_builder = req_builder.query(&[("throttled_only", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TranscriptList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TranscriptList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTranscriptsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload a media file to AssemblyAI's servers.  <Note>To upload a media file to our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> <Warning>Requests to transcribe uploaded files must use an API key from the same project as the key that was used to upload the file. If you use an API key from a different project you will get a `403` error and \"Cannot access uploaded file\" message.</Warning> 
pub async fn upload_file(configuration: &configuration::Configuration, body: Option<std::path::PathBuf>) -> Result<models::UploadedFile, Error<UploadFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/v2/upload", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    if let Some(param_value) = p_body_body {
        let file = TokioFile::open(param_value).await?;
        let stream = FramedRead::new(file, BytesCodec::new());
        req_builder = req_builder.body(reqwest::Body::wrap_stream(stream));
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadedFile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadedFile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// <Note>To search through a transcription created on our EU server, replace `api.assemblyai.com` with `api.eu.assemblyai.com`.</Note> Search through the transcript for keywords. You can search for individual words, numbers, or phrases containing up to five words or numbers. 
pub async fn word_search(configuration: &configuration::Configuration, transcript_id: &str, words: Vec<String>) -> Result<models::WordSearchResponse, Error<WordSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_transcript_id = transcript_id;
    let p_query_words = words;

    let uri_str = format!("{}/v2/transcript/{transcript_id}/word-search", configuration.base_path, transcript_id=crate::apis::urlencode(p_path_transcript_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "csv" {
        "multi" => req_builder.query(&p_query_words.into_iter().map(|p| ("words".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("words", &p_query_words.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WordSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WordSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WordSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

