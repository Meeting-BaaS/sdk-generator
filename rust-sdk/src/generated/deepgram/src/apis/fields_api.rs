/*
 * Deepgram API Specification
 *
 * APIs for speech-to-text transcription, text-to-speech synthesis, language understanding, and account management. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: devrel@deepgram.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`manage_v1_projects_billing_fields_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingFieldsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_fields_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageFieldsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Lists the accessors, deployment types, tags, and line items used for billing data in the specified time period. Use this endpoint if you want to filter your results from the Billing Breakdown endpoint and want to know what filters are available.
pub async fn manage_v1_projects_billing_fields_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>) -> Result<models::ListBillingFieldsV1Response, Error<ManageV1ProjectsBillingFieldsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v1/projects/{project_id}/billing/fields", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListBillingFieldsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListBillingFieldsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingFieldsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the features, models, tags, languages, and processing method used for requests in the specified project
pub async fn manage_v1_projects_usage_fields_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>) -> Result<models::UsageFieldsV1Response, Error<ManageV1ProjectsUsageFieldsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v1/projects/{project_id}/usage/fields", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageFieldsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageFieldsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageFieldsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

