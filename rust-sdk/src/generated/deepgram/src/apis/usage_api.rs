/*
 * Deepgram API Specification
 *
 * APIs for speech-to-text transcription, text-to-speech synthesis, language understanding, and account management. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: devrel@deepgram.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`manage_v1_projects_usage_breakdown_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageBreakdownGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_fields_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageFieldsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Retrieves the usage breakdown for a specific project, with various filter options by API feature or by groupings. Setting a feature (e.g. diarize) to true includes requests that used that feature, while false excludes requests that used it. Multiple true filters are combined with OR logic, while false filters use AND logic.
pub async fn manage_v1_projects_usage_breakdown_get(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, grouping: Option<&str>, accessor: Option<&str>, alternatives: Option<bool>, callback_method: Option<bool>, callback: Option<bool>, channels: Option<bool>, custom_intent_mode: Option<bool>, custom_intent: Option<bool>, custom_topic_mode: Option<bool>, custom_topic: Option<bool>, deployment: Option<&str>, detect_entities: Option<bool>, detect_language: Option<bool>, diarize: Option<bool>, dictation: Option<bool>, encoding: Option<bool>, endpoint: Option<&str>, extra: Option<bool>, filler_words: Option<bool>, intents: Option<bool>, keyterm: Option<bool>, keywords: Option<bool>, language: Option<bool>, measurements: Option<bool>, method: Option<&str>, model: Option<&str>, multichannel: Option<bool>, numerals: Option<bool>, paragraphs: Option<bool>, profanity_filter: Option<bool>, punctuate: Option<bool>, redact: Option<bool>, replace: Option<bool>, sample_rate: Option<bool>, search: Option<bool>, sentiment: Option<bool>, smart_format: Option<bool>, summarize: Option<bool>, tag: Option<&str>, topics: Option<bool>, utt_split: Option<bool>, utterances: Option<bool>, version: Option<bool>) -> Result<models::UsageBreakdownV1Response, Error<ManageV1ProjectsUsageBreakdownGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_grouping = grouping;
    let p_query_accessor = accessor;
    let p_query_alternatives = alternatives;
    let p_query_callback_method = callback_method;
    let p_query_callback = callback;
    let p_query_channels = channels;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_custom_topic = custom_topic;
    let p_query_deployment = deployment;
    let p_query_detect_entities = detect_entities;
    let p_query_detect_language = detect_language;
    let p_query_diarize = diarize;
    let p_query_dictation = dictation;
    let p_query_encoding = encoding;
    let p_query_endpoint = endpoint;
    let p_query_extra = extra;
    let p_query_filler_words = filler_words;
    let p_query_intents = intents;
    let p_query_keyterm = keyterm;
    let p_query_keywords = keywords;
    let p_query_language = language;
    let p_query_measurements = measurements;
    let p_query_method = method;
    let p_query_model = model;
    let p_query_multichannel = multichannel;
    let p_query_numerals = numerals;
    let p_query_paragraphs = paragraphs;
    let p_query_profanity_filter = profanity_filter;
    let p_query_punctuate = punctuate;
    let p_query_redact = redact;
    let p_query_replace = replace;
    let p_query_sample_rate = sample_rate;
    let p_query_search = search;
    let p_query_sentiment = sentiment;
    let p_query_smart_format = smart_format;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_utt_split = utt_split;
    let p_query_utterances = utterances;
    let p_query_version = version;

    let uri_str = format!("{}/v1/projects/{project_id}/usage/breakdown", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping {
        req_builder = req_builder.query(&[("grouping", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_alternatives {
        req_builder = req_builder.query(&[("alternatives", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_channels {
        req_builder = req_builder.query(&[("channels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_detect_entities {
        req_builder = req_builder.query(&[("detect_entities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_detect_language {
        req_builder = req_builder.query(&[("detect_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diarize {
        req_builder = req_builder.query(&[("diarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dictation {
        req_builder = req_builder.query(&[("dictation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint {
        req_builder = req_builder.query(&[("endpoint", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_extra {
        req_builder = req_builder.query(&[("extra", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filler_words {
        req_builder = req_builder.query(&[("filler_words", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyterm {
        req_builder = req_builder.query(&[("keyterm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keywords {
        req_builder = req_builder.query(&[("keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_measurements {
        req_builder = req_builder.query(&[("measurements", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_method {
        req_builder = req_builder.query(&[("method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multichannel {
        req_builder = req_builder.query(&[("multichannel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numerals {
        req_builder = req_builder.query(&[("numerals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_paragraphs {
        req_builder = req_builder.query(&[("paragraphs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profanity_filter {
        req_builder = req_builder.query(&[("profanity_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_punctuate {
        req_builder = req_builder.query(&[("punctuate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redact {
        req_builder = req_builder.query(&[("redact", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sample_rate {
        req_builder = req_builder.query(&[("sample_rate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smart_format {
        req_builder = req_builder.query(&[("smart_format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utt_split {
        req_builder = req_builder.query(&[("utt_split", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utterances {
        req_builder = req_builder.query(&[("utterances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageBreakdownV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageBreakdownV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageBreakdownGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the features, models, tags, languages, and processing method used for requests in the specified project
pub async fn manage_v1_projects_usage_fields_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>) -> Result<models::UsageFieldsV1Response, Error<ManageV1ProjectsUsageFieldsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v1/projects/{project_id}/usage/fields", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageFieldsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageFieldsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageFieldsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the usage for a specific project. Use Get Project Usage Breakdown for a more comprehensive usage summary.
#[deprecated]
pub async fn manage_v1_projects_usage_get(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, accessor: Option<&str>, alternatives: Option<bool>, callback_method: Option<bool>, callback: Option<bool>, channels: Option<bool>, custom_intent_mode: Option<bool>, custom_intent: Option<bool>, custom_topic_mode: Option<bool>, custom_topic: Option<bool>, deployment: Option<&str>, detect_entities: Option<bool>, detect_language: Option<bool>, diarize: Option<bool>, dictation: Option<bool>, encoding: Option<bool>, endpoint: Option<&str>, extra: Option<bool>, filler_words: Option<bool>, intents: Option<bool>, keyterm: Option<bool>, keywords: Option<bool>, language: Option<bool>, measurements: Option<bool>, method: Option<&str>, model: Option<&str>, multichannel: Option<bool>, numerals: Option<bool>, paragraphs: Option<bool>, profanity_filter: Option<bool>, punctuate: Option<bool>, redact: Option<bool>, replace: Option<bool>, sample_rate: Option<bool>, search: Option<bool>, sentiment: Option<bool>, smart_format: Option<bool>, summarize: Option<bool>, tag: Option<&str>, topics: Option<bool>, utt_split: Option<bool>, utterances: Option<bool>, version: Option<bool>) -> Result<models::UsageV1Response, Error<ManageV1ProjectsUsageGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_accessor = accessor;
    let p_query_alternatives = alternatives;
    let p_query_callback_method = callback_method;
    let p_query_callback = callback;
    let p_query_channels = channels;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_custom_topic = custom_topic;
    let p_query_deployment = deployment;
    let p_query_detect_entities = detect_entities;
    let p_query_detect_language = detect_language;
    let p_query_diarize = diarize;
    let p_query_dictation = dictation;
    let p_query_encoding = encoding;
    let p_query_endpoint = endpoint;
    let p_query_extra = extra;
    let p_query_filler_words = filler_words;
    let p_query_intents = intents;
    let p_query_keyterm = keyterm;
    let p_query_keywords = keywords;
    let p_query_language = language;
    let p_query_measurements = measurements;
    let p_query_method = method;
    let p_query_model = model;
    let p_query_multichannel = multichannel;
    let p_query_numerals = numerals;
    let p_query_paragraphs = paragraphs;
    let p_query_profanity_filter = profanity_filter;
    let p_query_punctuate = punctuate;
    let p_query_redact = redact;
    let p_query_replace = replace;
    let p_query_sample_rate = sample_rate;
    let p_query_search = search;
    let p_query_sentiment = sentiment;
    let p_query_smart_format = smart_format;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_utt_split = utt_split;
    let p_query_utterances = utterances;
    let p_query_version = version;

    let uri_str = format!("{}/v1/projects/{project_id}/usage", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_alternatives {
        req_builder = req_builder.query(&[("alternatives", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_channels {
        req_builder = req_builder.query(&[("channels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_detect_entities {
        req_builder = req_builder.query(&[("detect_entities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_detect_language {
        req_builder = req_builder.query(&[("detect_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diarize {
        req_builder = req_builder.query(&[("diarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dictation {
        req_builder = req_builder.query(&[("dictation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint {
        req_builder = req_builder.query(&[("endpoint", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_extra {
        req_builder = req_builder.query(&[("extra", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filler_words {
        req_builder = req_builder.query(&[("filler_words", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyterm {
        req_builder = req_builder.query(&[("keyterm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keywords {
        req_builder = req_builder.query(&[("keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_measurements {
        req_builder = req_builder.query(&[("measurements", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_method {
        req_builder = req_builder.query(&[("method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multichannel {
        req_builder = req_builder.query(&[("multichannel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numerals {
        req_builder = req_builder.query(&[("numerals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_paragraphs {
        req_builder = req_builder.query(&[("paragraphs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profanity_filter {
        req_builder = req_builder.query(&[("profanity_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_punctuate {
        req_builder = req_builder.query(&[("punctuate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redact {
        req_builder = req_builder.query(&[("redact", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sample_rate {
        req_builder = req_builder.query(&[("sample_rate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smart_format {
        req_builder = req_builder.query(&[("smart_format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utt_split {
        req_builder = req_builder.query(&[("utt_split", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utterances {
        req_builder = req_builder.query(&[("utterances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

