/*
 * Deepgram API Specification
 *
 * APIs for speech-to-text transcription, text-to-speech synthesis, language understanding, and account management. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: devrel@deepgram.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`agent_v1_settings_think_models_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AgentV1SettingsThinkModelsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_v1_tokens_grant`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthV1TokensGrantError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`listen_v1_media_transcribe`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListenV1MediaTranscribeError {
    Status400(models::ListenV1Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_projects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageProjectsDeleteError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_projects_keys_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageProjectsKeysCreateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_projects_keys_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageProjectsKeysDeleteError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_projects_members_scopes_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageProjectsMembersScopesUpdateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_projects_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageProjectsUpdateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_models_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ModelsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_models_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ModelsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_billing_balances_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingBalancesGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_billing_balances_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingBalancesListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_billing_breakdown_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingBreakdownListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_billing_fields_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingFieldsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_billing_purchases_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsBillingPurchasesListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsKeysGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_keys_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsKeysListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_leave`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsLeaveError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersDeleteError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_invites_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersInvitesCreateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_invites_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersInvitesDeleteError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_invites_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersInvitesListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_members_scopes_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsMembersScopesListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_models_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsModelsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_models_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsModelsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_requests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsRequestsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_requests_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsRequestsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_breakdown_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageBreakdownGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_fields_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageFieldsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`manage_v1_projects_usage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ManageV1ProjectsUsageGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`read_v1_text_analyze`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReadV1TextAnalyzeError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`self_hosted_v1_distribution_credentials_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelfHostedV1DistributionCredentialsCreateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`self_hosted_v1_distribution_credentials_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelfHostedV1DistributionCredentialsDeleteError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`self_hosted_v1_distribution_credentials_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelfHostedV1DistributionCredentialsGetError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`self_hosted_v1_distribution_credentials_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelfHostedV1DistributionCredentialsListError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`speak_v1_audio_generate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SpeakV1AudioGenerateError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Retrieves the available think models that can be used for AI agent processing
pub async fn agent_v1_settings_think_models_list(configuration: &configuration::Configuration, ) -> Result<models::AgentThinkModelsV1Response, Error<AgentV1SettingsThinkModelsListError>> {

    let uri_str = format!("{}/v1/agent/settings/think/models", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AgentThinkModelsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AgentThinkModelsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AgentV1SettingsThinkModelsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a temporary JSON Web Token (JWT) with a 30-second (by default) TTL and usage::write permission for core voice APIs, requiring an API key with Member or higher authorization. Tokens created with this endpoint will not work with the Manage APIs.
pub async fn auth_v1_tokens_grant(configuration: &configuration::Configuration, grant_v1_request: Option<models::GrantV1Request>) -> Result<models::GrantV1Response, Error<AuthV1TokensGrantError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_grant_v1_request = grant_v1_request;

    let uri_str = format!("{}/v1/auth/grant", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_grant_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GrantV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GrantV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthV1TokensGrantError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Transcribe audio and video using Deepgram's speech-to-text REST API
pub async fn listen_v1_media_transcribe(configuration: &configuration::Configuration, listen_v1_request_url: models::ListenV1RequestUrl, callback: Option<&str>, callback_method: Option<&str>, extra: Option<models::ListenV1MediaTranscribeExtraParameter>, sentiment: Option<bool>, summarize: Option<models::ListenV1MediaTranscribeSummarizeParameter>, tag: Option<models::ListenV1MediaTranscribeExtraParameter>, topics: Option<bool>, custom_topic: Option<models::ListenV1MediaTranscribeCustomTopicParameter>, custom_topic_mode: Option<&str>, intents: Option<bool>, custom_intent: Option<models::ListenV1MediaTranscribeCustomIntentParameter>, custom_intent_mode: Option<&str>, detect_entities: Option<bool>, detect_language: Option<models::ListenV1MediaTranscribeDetectLanguageParameter>, diarize: Option<bool>, dictation: Option<bool>, encoding: Option<&str>, filler_words: Option<bool>, keyterm: Option<Vec<String>>, keywords: Option<models::ListenV1MediaTranscribeExtraParameter>, language: Option<&str>, measurements: Option<bool>, model: Option<models::ListenV1MediaTranscribeModelParameter>, multichannel: Option<bool>, numerals: Option<bool>, paragraphs: Option<bool>, profanity_filter: Option<bool>, punctuate: Option<bool>, redact: Option<models::ListenV1MediaTranscribeRedactParameter>, replace: Option<models::ListenV1MediaTranscribeExtraParameter>, search: Option<models::ListenV1MediaTranscribeExtraParameter>, smart_format: Option<bool>, utterances: Option<bool>, utt_split: Option<f64>, version: Option<models::ListenV1MediaTranscribeVersionParameter>, mip_opt_out: Option<bool>) -> Result<models::ListenV1MediaTranscribe200Response, Error<ListenV1MediaTranscribeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_listen_v1_request_url = listen_v1_request_url;
    let p_query_callback = callback;
    let p_query_callback_method = callback_method;
    let p_query_extra = extra;
    let p_query_sentiment = sentiment;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_custom_topic = custom_topic;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_intents = intents;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_detect_entities = detect_entities;
    let p_query_detect_language = detect_language;
    let p_query_diarize = diarize;
    let p_query_dictation = dictation;
    let p_query_encoding = encoding;
    let p_query_filler_words = filler_words;
    let p_query_keyterm = keyterm;
    let p_query_keywords = keywords;
    let p_query_language = language;
    let p_query_measurements = measurements;
    let p_query_model = model;
    let p_query_multichannel = multichannel;
    let p_query_numerals = numerals;
    let p_query_paragraphs = paragraphs;
    let p_query_profanity_filter = profanity_filter;
    let p_query_punctuate = punctuate;
    let p_query_redact = redact;
    let p_query_replace = replace;
    let p_query_search = search;
    let p_query_smart_format = smart_format;
    let p_query_utterances = utterances;
    let p_query_utt_split = utt_split;
    let p_query_version = version;
    let p_query_mip_opt_out = mip_opt_out;

    let uri_str = format!("{}/v1/listen", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_extra {
        req_builder = req_builder.query(&[("extra", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_detect_entities {
        req_builder = req_builder.query(&[("detect_entities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_detect_language {
        req_builder = req_builder.query(&[("detect_language", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_diarize {
        req_builder = req_builder.query(&[("diarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dictation {
        req_builder = req_builder.query(&[("dictation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_filler_words {
        req_builder = req_builder.query(&[("filler_words", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyterm {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("keyterm".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("keyterm", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_keywords {
        req_builder = req_builder.query(&[("keywords", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_measurements {
        req_builder = req_builder.query(&[("measurements", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_multichannel {
        req_builder = req_builder.query(&[("multichannel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numerals {
        req_builder = req_builder.query(&[("numerals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_paragraphs {
        req_builder = req_builder.query(&[("paragraphs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profanity_filter {
        req_builder = req_builder.query(&[("profanity_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_punctuate {
        req_builder = req_builder.query(&[("punctuate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redact {
        req_builder = req_builder.query(&[("redact", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_smart_format {
        req_builder = req_builder.query(&[("smart_format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utterances {
        req_builder = req_builder.query(&[("utterances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utt_split {
        req_builder = req_builder.query(&[("utt_split", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_mip_opt_out {
        req_builder = req_builder.query(&[("mip_opt_out", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_listen_v1_request_url);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListenV1MediaTranscribe200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListenV1MediaTranscribe200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListenV1MediaTranscribeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes the specified project
pub async fn manage_projects_delete(configuration: &configuration::Configuration, project_id: &str) -> Result<models::DeleteProjectV1Response, Error<ManageProjectsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteProjectV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteProjectV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageProjectsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new API key with specified settings for the project
pub async fn manage_projects_keys_create(configuration: &configuration::Configuration, project_id: &str, create_key_v1_request: Option<models::CreateKeyV1Request>) -> Result<models::CreateKeyV1Response, Error<ManageProjectsKeysCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_create_key_v1_request = create_key_v1_request;

    let uri_str = format!("{}/v1/projects/{project_id}/keys", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_create_key_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateKeyV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateKeyV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageProjectsKeysCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an API key for a specific project
pub async fn manage_projects_keys_delete(configuration: &configuration::Configuration, project_id: &str, key_id: &str) -> Result<models::DeleteProjectKeyV1Response, Error<ManageProjectsKeysDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_key_id = key_id;

    let uri_str = format!("{}/v1/projects/{project_id}/keys/{key_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), key_id=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteProjectKeyV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteProjectKeyV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageProjectsKeysDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the scopes for a specific member
pub async fn manage_projects_members_scopes_update(configuration: &configuration::Configuration, project_id: &str, member_id: &str, update_project_member_scopes_v1_request: Option<models::UpdateProjectMemberScopesV1Request>) -> Result<models::UpdateProjectMemberScopesV1Response, Error<ManageProjectsMembersScopesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_member_id = member_id;
    let p_body_update_project_member_scopes_v1_request = update_project_member_scopes_v1_request;

    let uri_str = format!("{}/v1/projects/{project_id}/members/{member_id}/scopes", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), member_id=crate::apis::urlencode(p_path_member_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_update_project_member_scopes_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateProjectMemberScopesV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateProjectMemberScopesV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageProjectsMembersScopesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates the name or other properties of an existing project
pub async fn manage_projects_update(configuration: &configuration::Configuration, project_id: &str, update_project_v1_request: Option<models::UpdateProjectV1Request>) -> Result<models::UpdateProjectV1Response, Error<ManageProjectsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_update_project_v1_request = update_project_v1_request;

    let uri_str = format!("{}/v1/projects/{project_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_update_project_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateProjectV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateProjectV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageProjectsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns metadata for a specific public model
pub async fn manage_v1_models_get(configuration: &configuration::Configuration, model_id: &str) -> Result<models::GetModelV1Response, Error<ManageV1ModelsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_model_id = model_id;

    let uri_str = format!("{}/v1/models/{model_id}", configuration.base_path, model_id=crate::apis::urlencode(p_path_model_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetModelV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetModelV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ModelsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns metadata on all the latest public models. To retrieve custom models, use Get Project Models.
pub async fn manage_v1_models_list(configuration: &configuration::Configuration, include_outdated: Option<bool>) -> Result<models::ListModelsV1Response, Error<ManageV1ModelsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_include_outdated = include_outdated;

    let uri_str = format!("{}/v1/models", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_outdated {
        req_builder = req_builder.query(&[("include_outdated", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListModelsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListModelsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ModelsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves details about the specified balance
pub async fn manage_v1_projects_billing_balances_get(configuration: &configuration::Configuration, project_id: &str, balance_id: &str) -> Result<models::GetProjectBalanceV1Response, Error<ManageV1ProjectsBillingBalancesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_balance_id = balance_id;

    let uri_str = format!("{}/v1/projects/{project_id}/balances/{balance_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), balance_id=crate::apis::urlencode(p_path_balance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectBalanceV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectBalanceV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingBalancesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a list of outstanding balances for the specified project
pub async fn manage_v1_projects_billing_balances_list(configuration: &configuration::Configuration, project_id: &str) -> Result<models::ListProjectBalancesV1Response, Error<ManageV1ProjectsBillingBalancesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}/balances", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectBalancesV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectBalancesV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingBalancesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the billing summary for a specific project, with various filter options or by grouping options.
pub async fn manage_v1_projects_billing_breakdown_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, accessor: Option<&str>, deployment: Option<&str>, tag: Option<&str>, line_item: Option<&str>, grouping: Option<Vec<String>>) -> Result<models::BillingBreakdownV1Response, Error<ManageV1ProjectsBillingBreakdownListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_accessor = accessor;
    let p_query_deployment = deployment;
    let p_query_tag = tag;
    let p_query_line_item = line_item;
    let p_query_grouping = grouping;

    let uri_str = format!("{}/v1/projects/{project_id}/billing/breakdown", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_line_item {
        req_builder = req_builder.query(&[("line_item", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("grouping".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("grouping", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BillingBreakdownV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BillingBreakdownV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingBreakdownListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the accessors, deployment types, tags, and line items used for billing data in the specified time period. Use this endpoint if you want to filter your results from the Billing Breakdown endpoint and want to know what filters are available.
pub async fn manage_v1_projects_billing_fields_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>) -> Result<models::ListBillingFieldsV1Response, Error<ManageV1ProjectsBillingFieldsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v1/projects/{project_id}/billing/fields", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListBillingFieldsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListBillingFieldsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingFieldsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the original purchased amount on an order transaction
pub async fn manage_v1_projects_billing_purchases_list(configuration: &configuration::Configuration, project_id: &str, limit: Option<f64>) -> Result<models::ListProjectPurchasesV1Response, Error<ManageV1ProjectsBillingPurchasesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_limit = limit;

    let uri_str = format!("{}/v1/projects/{project_id}/purchases", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectPurchasesV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectPurchasesV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsBillingPurchasesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves information about the specified project
pub async fn manage_v1_projects_get(configuration: &configuration::Configuration, project_id: &str, limit: Option<f64>, page: Option<f64>) -> Result<models::GetProjectV1Response, Error<ManageV1ProjectsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_limit = limit;
    let p_query_page = page;

    let uri_str = format!("{}/v1/projects/{project_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves information about a specified API key
pub async fn manage_v1_projects_keys_get(configuration: &configuration::Configuration, project_id: &str, key_id: &str) -> Result<models::GetProjectKeyV1Response, Error<ManageV1ProjectsKeysGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_key_id = key_id;

    let uri_str = format!("{}/v1/projects/{project_id}/keys/{key_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), key_id=crate::apis::urlencode(p_path_key_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectKeyV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectKeyV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsKeysGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves all API keys associated with the specified project
pub async fn manage_v1_projects_keys_list(configuration: &configuration::Configuration, project_id: &str, status: Option<&str>) -> Result<models::ListProjectKeysV1Response, Error<ManageV1ProjectsKeysListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_status = status;

    let uri_str = format!("{}/v1/projects/{project_id}/keys", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectKeysV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectKeysV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsKeysListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes the authenticated account from the specific project
pub async fn manage_v1_projects_leave(configuration: &configuration::Configuration, project_id: &str) -> Result<models::LeaveProjectV1Response, Error<ManageV1ProjectsLeaveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}/leave", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaveProjectV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaveProjectV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsLeaveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves basic information about the projects associated with the API key
pub async fn manage_v1_projects_list(configuration: &configuration::Configuration, ) -> Result<models::ListProjectsV1Response, Error<ManageV1ProjectsListError>> {

    let uri_str = format!("{}/v1/projects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a member from the project using their unique member ID
pub async fn manage_v1_projects_members_delete(configuration: &configuration::Configuration, project_id: &str, member_id: &str) -> Result<models::DeleteProjectMemberV1Response, Error<ManageV1ProjectsMembersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_member_id = member_id;

    let uri_str = format!("{}/v1/projects/{project_id}/members/{member_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), member_id=crate::apis::urlencode(p_path_member_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteProjectMemberV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteProjectMemberV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates an invite for a specific project
pub async fn manage_v1_projects_members_invites_create(configuration: &configuration::Configuration, project_id: &str, create_project_invite_v1_request: Option<models::CreateProjectInviteV1Request>) -> Result<models::CreateProjectInviteV1Response, Error<ManageV1ProjectsMembersInvitesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_body_create_project_invite_v1_request = create_project_invite_v1_request;

    let uri_str = format!("{}/v1/projects/{project_id}/invites", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_create_project_invite_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateProjectInviteV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateProjectInviteV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersInvitesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes an invite for a specific project
pub async fn manage_v1_projects_members_invites_delete(configuration: &configuration::Configuration, project_id: &str, email: &str) -> Result<models::DeleteProjectInviteV1Response, Error<ManageV1ProjectsMembersInvitesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_email = email;

    let uri_str = format!("{}/v1/projects/{project_id}/invites/{email}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), email=crate::apis::urlencode(p_path_email));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteProjectInviteV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteProjectInviteV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersInvitesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a list of invites for a specific project
pub async fn manage_v1_projects_members_invites_list(configuration: &configuration::Configuration, project_id: &str) -> Result<models::ListProjectInvitesV1Response, Error<ManageV1ProjectsMembersInvitesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}/invites", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectInvitesV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectInvitesV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersInvitesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of members for a given project
pub async fn manage_v1_projects_members_list(configuration: &configuration::Configuration, project_id: &str) -> Result<models::ListProjectMembersV1Response, Error<ManageV1ProjectsMembersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}/members", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectMembersV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectMembersV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of scopes for a specific member
pub async fn manage_v1_projects_members_scopes_list(configuration: &configuration::Configuration, project_id: &str, member_id: &str) -> Result<models::ListProjectMemberScopesV1Response, Error<ManageV1ProjectsMembersScopesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_member_id = member_id;

    let uri_str = format!("{}/v1/projects/{project_id}/members/{member_id}/scopes", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), member_id=crate::apis::urlencode(p_path_member_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectMemberScopesV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectMemberScopesV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsMembersScopesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns metadata for a specific model
pub async fn manage_v1_projects_models_get(configuration: &configuration::Configuration, project_id: &str, model_id: &str) -> Result<models::GetModelV1Response, Error<ManageV1ProjectsModelsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_model_id = model_id;

    let uri_str = format!("{}/v1/projects/{project_id}/models/{model_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), model_id=crate::apis::urlencode(p_path_model_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetModelV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetModelV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsModelsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns metadata on all the latest models that a specific project has access to, including non-public models
pub async fn manage_v1_projects_models_list(configuration: &configuration::Configuration, project_id: &str, include_outdated: Option<bool>) -> Result<models::ListModelsV1Response, Error<ManageV1ProjectsModelsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_include_outdated = include_outdated;

    let uri_str = format!("{}/v1/projects/{project_id}/models", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_outdated {
        req_builder = req_builder.query(&[("include_outdated", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListModelsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListModelsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsModelsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific request for a specific project
pub async fn manage_v1_projects_requests_get(configuration: &configuration::Configuration, project_id: &str, request_id: &str) -> Result<models::GetProjectRequestV1Response, Error<ManageV1ProjectsRequestsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_request_id = request_id;

    let uri_str = format!("{}/v1/projects/{project_id}/requests/{request_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), request_id=crate::apis::urlencode(p_path_request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectRequestV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectRequestV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsRequestsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a list of requests for a specific project
pub async fn manage_v1_projects_requests_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, limit: Option<f64>, page: Option<f64>, accessor: Option<&str>, request_id: Option<&str>, deployment: Option<&str>, endpoint: Option<&str>, method: Option<&str>, status: Option<&str>) -> Result<models::ListProjectRequestsV1Response, Error<ManageV1ProjectsRequestsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_limit = limit;
    let p_query_page = page;
    let p_query_accessor = accessor;
    let p_query_request_id = request_id;
    let p_query_deployment = deployment;
    let p_query_endpoint = endpoint;
    let p_query_method = method;
    let p_query_status = status;

    let uri_str = format!("{}/v1/projects/{project_id}/requests", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_request_id {
        req_builder = req_builder.query(&[("request_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_endpoint {
        req_builder = req_builder.query(&[("endpoint", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_method {
        req_builder = req_builder.query(&[("method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectRequestsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectRequestsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsRequestsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the usage breakdown for a specific project, with various filter options by API feature or by groupings. Setting a feature (e.g. diarize) to true includes requests that used that feature, while false excludes requests that used it. Multiple true filters are combined with OR logic, while false filters use AND logic.
pub async fn manage_v1_projects_usage_breakdown_get(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, grouping: Option<&str>, accessor: Option<&str>, alternatives: Option<bool>, callback_method: Option<bool>, callback: Option<bool>, channels: Option<bool>, custom_intent_mode: Option<bool>, custom_intent: Option<bool>, custom_topic_mode: Option<bool>, custom_topic: Option<bool>, deployment: Option<&str>, detect_entities: Option<bool>, detect_language: Option<bool>, diarize: Option<bool>, dictation: Option<bool>, encoding: Option<bool>, endpoint: Option<&str>, extra: Option<bool>, filler_words: Option<bool>, intents: Option<bool>, keyterm: Option<bool>, keywords: Option<bool>, language: Option<bool>, measurements: Option<bool>, method: Option<&str>, model: Option<&str>, multichannel: Option<bool>, numerals: Option<bool>, paragraphs: Option<bool>, profanity_filter: Option<bool>, punctuate: Option<bool>, redact: Option<bool>, replace: Option<bool>, sample_rate: Option<bool>, search: Option<bool>, sentiment: Option<bool>, smart_format: Option<bool>, summarize: Option<bool>, tag: Option<&str>, topics: Option<bool>, utt_split: Option<bool>, utterances: Option<bool>, version: Option<bool>) -> Result<models::UsageBreakdownV1Response, Error<ManageV1ProjectsUsageBreakdownGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_grouping = grouping;
    let p_query_accessor = accessor;
    let p_query_alternatives = alternatives;
    let p_query_callback_method = callback_method;
    let p_query_callback = callback;
    let p_query_channels = channels;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_custom_topic = custom_topic;
    let p_query_deployment = deployment;
    let p_query_detect_entities = detect_entities;
    let p_query_detect_language = detect_language;
    let p_query_diarize = diarize;
    let p_query_dictation = dictation;
    let p_query_encoding = encoding;
    let p_query_endpoint = endpoint;
    let p_query_extra = extra;
    let p_query_filler_words = filler_words;
    let p_query_intents = intents;
    let p_query_keyterm = keyterm;
    let p_query_keywords = keywords;
    let p_query_language = language;
    let p_query_measurements = measurements;
    let p_query_method = method;
    let p_query_model = model;
    let p_query_multichannel = multichannel;
    let p_query_numerals = numerals;
    let p_query_paragraphs = paragraphs;
    let p_query_profanity_filter = profanity_filter;
    let p_query_punctuate = punctuate;
    let p_query_redact = redact;
    let p_query_replace = replace;
    let p_query_sample_rate = sample_rate;
    let p_query_search = search;
    let p_query_sentiment = sentiment;
    let p_query_smart_format = smart_format;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_utt_split = utt_split;
    let p_query_utterances = utterances;
    let p_query_version = version;

    let uri_str = format!("{}/v1/projects/{project_id}/usage/breakdown", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_grouping {
        req_builder = req_builder.query(&[("grouping", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_alternatives {
        req_builder = req_builder.query(&[("alternatives", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_channels {
        req_builder = req_builder.query(&[("channels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_detect_entities {
        req_builder = req_builder.query(&[("detect_entities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_detect_language {
        req_builder = req_builder.query(&[("detect_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diarize {
        req_builder = req_builder.query(&[("diarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dictation {
        req_builder = req_builder.query(&[("dictation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint {
        req_builder = req_builder.query(&[("endpoint", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_extra {
        req_builder = req_builder.query(&[("extra", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filler_words {
        req_builder = req_builder.query(&[("filler_words", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyterm {
        req_builder = req_builder.query(&[("keyterm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keywords {
        req_builder = req_builder.query(&[("keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_measurements {
        req_builder = req_builder.query(&[("measurements", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_method {
        req_builder = req_builder.query(&[("method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multichannel {
        req_builder = req_builder.query(&[("multichannel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numerals {
        req_builder = req_builder.query(&[("numerals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_paragraphs {
        req_builder = req_builder.query(&[("paragraphs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profanity_filter {
        req_builder = req_builder.query(&[("profanity_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_punctuate {
        req_builder = req_builder.query(&[("punctuate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redact {
        req_builder = req_builder.query(&[("redact", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sample_rate {
        req_builder = req_builder.query(&[("sample_rate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smart_format {
        req_builder = req_builder.query(&[("smart_format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utt_split {
        req_builder = req_builder.query(&[("utt_split", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utterances {
        req_builder = req_builder.query(&[("utterances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageBreakdownV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageBreakdownV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageBreakdownGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists the features, models, tags, languages, and processing method used for requests in the specified project
pub async fn manage_v1_projects_usage_fields_list(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>) -> Result<models::UsageFieldsV1Response, Error<ManageV1ProjectsUsageFieldsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;

    let uri_str = format!("{}/v1/projects/{project_id}/usage/fields", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageFieldsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageFieldsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageFieldsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the usage for a specific project. Use Get Project Usage Breakdown for a more comprehensive usage summary.
#[deprecated]
pub async fn manage_v1_projects_usage_get(configuration: &configuration::Configuration, project_id: &str, start: Option<String>, end: Option<String>, accessor: Option<&str>, alternatives: Option<bool>, callback_method: Option<bool>, callback: Option<bool>, channels: Option<bool>, custom_intent_mode: Option<bool>, custom_intent: Option<bool>, custom_topic_mode: Option<bool>, custom_topic: Option<bool>, deployment: Option<&str>, detect_entities: Option<bool>, detect_language: Option<bool>, diarize: Option<bool>, dictation: Option<bool>, encoding: Option<bool>, endpoint: Option<&str>, extra: Option<bool>, filler_words: Option<bool>, intents: Option<bool>, keyterm: Option<bool>, keywords: Option<bool>, language: Option<bool>, measurements: Option<bool>, method: Option<&str>, model: Option<&str>, multichannel: Option<bool>, numerals: Option<bool>, paragraphs: Option<bool>, profanity_filter: Option<bool>, punctuate: Option<bool>, redact: Option<bool>, replace: Option<bool>, sample_rate: Option<bool>, search: Option<bool>, sentiment: Option<bool>, smart_format: Option<bool>, summarize: Option<bool>, tag: Option<&str>, topics: Option<bool>, utt_split: Option<bool>, utterances: Option<bool>, version: Option<bool>) -> Result<models::UsageV1Response, Error<ManageV1ProjectsUsageGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_start = start;
    let p_query_end = end;
    let p_query_accessor = accessor;
    let p_query_alternatives = alternatives;
    let p_query_callback_method = callback_method;
    let p_query_callback = callback;
    let p_query_channels = channels;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_custom_topic = custom_topic;
    let p_query_deployment = deployment;
    let p_query_detect_entities = detect_entities;
    let p_query_detect_language = detect_language;
    let p_query_diarize = diarize;
    let p_query_dictation = dictation;
    let p_query_encoding = encoding;
    let p_query_endpoint = endpoint;
    let p_query_extra = extra;
    let p_query_filler_words = filler_words;
    let p_query_intents = intents;
    let p_query_keyterm = keyterm;
    let p_query_keywords = keywords;
    let p_query_language = language;
    let p_query_measurements = measurements;
    let p_query_method = method;
    let p_query_model = model;
    let p_query_multichannel = multichannel;
    let p_query_numerals = numerals;
    let p_query_paragraphs = paragraphs;
    let p_query_profanity_filter = profanity_filter;
    let p_query_punctuate = punctuate;
    let p_query_redact = redact;
    let p_query_replace = replace;
    let p_query_sample_rate = sample_rate;
    let p_query_search = search;
    let p_query_sentiment = sentiment;
    let p_query_smart_format = smart_format;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_utt_split = utt_split;
    let p_query_utterances = utterances;
    let p_query_version = version;

    let uri_str = format!("{}/v1/projects/{project_id}/usage", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end {
        req_builder = req_builder.query(&[("end", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_accessor {
        req_builder = req_builder.query(&[("accessor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_alternatives {
        req_builder = req_builder.query(&[("alternatives", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_channels {
        req_builder = req_builder.query(&[("channels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deployment {
        req_builder = req_builder.query(&[("deployment", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_detect_entities {
        req_builder = req_builder.query(&[("detect_entities", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_detect_language {
        req_builder = req_builder.query(&[("detect_language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_diarize {
        req_builder = req_builder.query(&[("diarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dictation {
        req_builder = req_builder.query(&[("dictation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_endpoint {
        req_builder = req_builder.query(&[("endpoint", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_extra {
        req_builder = req_builder.query(&[("extra", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filler_words {
        req_builder = req_builder.query(&[("filler_words", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keyterm {
        req_builder = req_builder.query(&[("keyterm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_keywords {
        req_builder = req_builder.query(&[("keywords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_measurements {
        req_builder = req_builder.query(&[("measurements", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_method {
        req_builder = req_builder.query(&[("method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_multichannel {
        req_builder = req_builder.query(&[("multichannel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numerals {
        req_builder = req_builder.query(&[("numerals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_paragraphs {
        req_builder = req_builder.query(&[("paragraphs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profanity_filter {
        req_builder = req_builder.query(&[("profanity_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_punctuate {
        req_builder = req_builder.query(&[("punctuate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_redact {
        req_builder = req_builder.query(&[("redact", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_replace {
        req_builder = req_builder.query(&[("replace", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sample_rate {
        req_builder = req_builder.query(&[("sample_rate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_smart_format {
        req_builder = req_builder.query(&[("smart_format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utt_split {
        req_builder = req_builder.query(&[("utt_split", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_utterances {
        req_builder = req_builder.query(&[("utterances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UsageV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UsageV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ManageV1ProjectsUsageGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Analyze text content using Deepgrams text analysis API
pub async fn read_v1_text_analyze(configuration: &configuration::Configuration, callback: Option<&str>, callback_method: Option<&str>, sentiment: Option<bool>, summarize: Option<models::ListenV1MediaTranscribeSummarizeParameter>, tag: Option<models::ListenV1MediaTranscribeExtraParameter>, topics: Option<bool>, custom_topic: Option<models::ListenV1MediaTranscribeCustomTopicParameter>, custom_topic_mode: Option<&str>, intents: Option<bool>, custom_intent: Option<models::ListenV1MediaTranscribeCustomIntentParameter>, custom_intent_mode: Option<&str>, language: Option<&str>, read_v1_request: Option<models::ReadV1Request>) -> Result<models::ReadV1Response, Error<ReadV1TextAnalyzeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_callback = callback;
    let p_query_callback_method = callback_method;
    let p_query_sentiment = sentiment;
    let p_query_summarize = summarize;
    let p_query_tag = tag;
    let p_query_topics = topics;
    let p_query_custom_topic = custom_topic;
    let p_query_custom_topic_mode = custom_topic_mode;
    let p_query_intents = intents;
    let p_query_custom_intent = custom_intent;
    let p_query_custom_intent_mode = custom_intent_mode;
    let p_query_language = language;
    let p_body_read_v1_request = read_v1_request;

    let uri_str = format!("{}/v1/read", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sentiment {
        req_builder = req_builder.query(&[("sentiment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_summarize {
        req_builder = req_builder.query(&[("summarize", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_topics {
        req_builder = req_builder.query(&[("topics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_topic {
        req_builder = req_builder.query(&[("custom_topic", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_custom_topic_mode {
        req_builder = req_builder.query(&[("custom_topic_mode", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_intents {
        req_builder = req_builder.query(&[("intents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_custom_intent {
        req_builder = req_builder.query(&[("custom_intent", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_custom_intent_mode {
        req_builder = req_builder.query(&[("custom_intent_mode", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_read_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReadV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReadV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReadV1TextAnalyzeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a set of distribution credentials for the specified project
pub async fn self_hosted_v1_distribution_credentials_create(configuration: &configuration::Configuration, project_id: &str, scopes: Option<Vec<String>>, provider: Option<&str>, create_project_distribution_credentials_v1_request: Option<models::CreateProjectDistributionCredentialsV1Request>) -> Result<models::CreateProjectDistributionCredentialsV1Response, Error<SelfHostedV1DistributionCredentialsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_scopes = scopes;
    let p_query_provider = provider;
    let p_body_create_project_distribution_credentials_v1_request = create_project_distribution_credentials_v1_request;

    let uri_str = format!("{}/v1/projects/{project_id}/self-hosted/distribution/credentials", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_scopes {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("scopes".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("scopes", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_provider {
        req_builder = req_builder.query(&[("provider", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_create_project_distribution_credentials_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateProjectDistributionCredentialsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateProjectDistributionCredentialsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelfHostedV1DistributionCredentialsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a set of distribution credentials for the specified project
pub async fn self_hosted_v1_distribution_credentials_delete(configuration: &configuration::Configuration, project_id: &str, distribution_credentials_id: &str) -> Result<models::GetProjectDistributionCredentialsV1Response, Error<SelfHostedV1DistributionCredentialsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_distribution_credentials_id = distribution_credentials_id;

    let uri_str = format!("{}/v1/projects/{project_id}/self-hosted/distribution/credentials/{distribution_credentials_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), distribution_credentials_id=crate::apis::urlencode(p_path_distribution_credentials_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectDistributionCredentialsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectDistributionCredentialsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelfHostedV1DistributionCredentialsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a set of distribution credentials for the specified project
pub async fn self_hosted_v1_distribution_credentials_get(configuration: &configuration::Configuration, project_id: &str, distribution_credentials_id: &str) -> Result<models::GetProjectDistributionCredentialsV1Response, Error<SelfHostedV1DistributionCredentialsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_path_distribution_credentials_id = distribution_credentials_id;

    let uri_str = format!("{}/v1/projects/{project_id}/self-hosted/distribution/credentials/{distribution_credentials_id}", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id), distribution_credentials_id=crate::apis::urlencode(p_path_distribution_credentials_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProjectDistributionCredentialsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProjectDistributionCredentialsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelfHostedV1DistributionCredentialsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists sets of distribution credentials for the specified project
pub async fn self_hosted_v1_distribution_credentials_list(configuration: &configuration::Configuration, project_id: &str) -> Result<models::ListProjectDistributionCredentialsV1Response, Error<SelfHostedV1DistributionCredentialsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;

    let uri_str = format!("{}/v1/projects/{project_id}/self-hosted/distribution/credentials", configuration.base_path, project_id=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListProjectDistributionCredentialsV1Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListProjectDistributionCredentialsV1Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelfHostedV1DistributionCredentialsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Convert text into natural-sounding speech using Deepgram's TTS REST API
pub async fn speak_v1_audio_generate(configuration: &configuration::Configuration, speak_v1_request: models::SpeakV1Request, callback: Option<&str>, callback_method: Option<&str>, mip_opt_out: Option<bool>, tag: Option<models::ListenV1MediaTranscribeExtraParameter>, bit_rate: Option<models::SpeakV1AudioGenerateBitRateParameter>, container: Option<models::SpeakV1AudioGenerateContainerParameter>, encoding: Option<models::SpeakV1AudioGenerateEncodingParameter>, model: Option<&str>, sample_rate: Option<models::SpeakV1AudioGenerateSampleRateParameter>) -> Result<reqwest::Response, Error<SpeakV1AudioGenerateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_speak_v1_request = speak_v1_request;
    let p_query_callback = callback;
    let p_query_callback_method = callback_method;
    let p_query_mip_opt_out = mip_opt_out;
    let p_query_tag = tag;
    let p_query_bit_rate = bit_rate;
    let p_query_container = container;
    let p_query_encoding = encoding;
    let p_query_model = model;
    let p_query_sample_rate = sample_rate;

    let uri_str = format!("{}/v1/speak", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_callback {
        req_builder = req_builder.query(&[("callback", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_callback_method {
        req_builder = req_builder.query(&[("callback_method", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_mip_opt_out {
        req_builder = req_builder.query(&[("mip_opt_out", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_bit_rate {
        req_builder = req_builder.query(&[("bit_rate", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_container {
        req_builder = req_builder.query(&[("container", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_encoding {
        req_builder = req_builder.query(&[("encoding", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_sample_rate {
        req_builder = req_builder.query(&[("sample_rate", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&p_body_speak_v1_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<SpeakV1AudioGenerateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

