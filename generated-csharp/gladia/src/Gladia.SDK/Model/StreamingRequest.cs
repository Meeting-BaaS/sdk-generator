// <auto-generated>
/*
 * Gladia Control API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Gladia.SDK.Client;

namespace Gladia.SDK.Model
{
    /// <summary>
    /// StreamingRequest
    /// </summary>
    public partial class StreamingRequest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StreamingRequest" /> class.
        /// </summary>
        /// <param name="encoding">The encoding format of the audio stream. Supported formats:  - PCM: 8, 16, 24, and 32 bits  - A-law: 8 bits  - μ-law: 8 bits   Note: No need to add WAV headers to raw audio as the API supports both formats.</param>
        /// <param name="bitDepth">The bit depth of the audio stream</param>
        /// <param name="sampleRate">The sample rate of the audio stream</param>
        /// <param name="channels">The number of channels of the audio stream (default to 1)</param>
        /// <param name="customMetadata">Custom metadata you can attach to this live transcription</param>
        /// <param name="model">The model used to process the audio. \&quot;solaria-1\&quot; is used by default.</param>
        /// <param name="endpointing">The endpointing duration in seconds. Endpointing is the duration of silence which will cause an utterance to be considered as finished (default to 0.05M)</param>
        /// <param name="maximumDurationWithoutEndpointing">The maximum duration in seconds without endpointing. If endpointing is not detected after this duration, current utterance will be considered as finished (default to 5M)</param>
        /// <param name="languageConfig">Specify the language configuration</param>
        /// <param name="preProcessing">Specify the pre-processing configuration</param>
        /// <param name="realtimeProcessing">Specify the realtime processing configuration</param>
        /// <param name="postProcessing">Specify the post-processing configuration</param>
        /// <param name="messagesConfig">Specify the websocket messages configuration</param>
        /// <param name="callback">If true, messages will be sent to configured url. (default to false)</param>
        /// <param name="callbackConfig">Specify the callback configuration</param>
        [JsonConstructor]
        public StreamingRequest(Option<StreamingSupportedEncodingEnum?> encoding = default, Option<StreamingSupportedBitDepthEnum?> bitDepth = default, Option<StreamingSupportedSampleRateEnum?> sampleRate = default, Option<int?> channels = default, Option<Dictionary<string, Object>?> customMetadata = default, Option<StreamingSupportedModels?> model = default, Option<decimal?> endpointing = default, Option<decimal?> maximumDurationWithoutEndpointing = default, Option<LanguageConfig?> languageConfig = default, Option<PreProcessingConfig?> preProcessing = default, Option<RealtimeProcessingConfig?> realtimeProcessing = default, Option<PostProcessingConfig?> postProcessing = default, Option<MessagesConfig?> messagesConfig = default, Option<bool?> callback = default, Option<CallbackConfig?> callbackConfig = default)
        {
            EncodingOption = encoding;
            BitDepthOption = bitDepth;
            SampleRateOption = sampleRate;
            ChannelsOption = channels;
            CustomMetadataOption = customMetadata;
            ModelOption = model;
            EndpointingOption = endpointing;
            MaximumDurationWithoutEndpointingOption = maximumDurationWithoutEndpointing;
            LanguageConfigOption = languageConfig;
            PreProcessingOption = preProcessing;
            RealtimeProcessingOption = realtimeProcessing;
            PostProcessingOption = postProcessing;
            MessagesConfigOption = messagesConfig;
            CallbackOption = callback;
            CallbackConfigOption = callbackConfig;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Encoding
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StreamingSupportedEncodingEnum?> EncodingOption { get; private set; }

        /// <summary>
        /// The encoding format of the audio stream. Supported formats:  - PCM: 8, 16, 24, and 32 bits  - A-law: 8 bits  - μ-law: 8 bits   Note: No need to add WAV headers to raw audio as the API supports both formats.
        /// </summary>
        /// <value>The encoding format of the audio stream. Supported formats:  - PCM: 8, 16, 24, and 32 bits  - A-law: 8 bits  - μ-law: 8 bits   Note: No need to add WAV headers to raw audio as the API supports both formats.</value>
        [JsonPropertyName("encoding")]
        public StreamingSupportedEncodingEnum? Encoding { get { return this.EncodingOption; } set { this.EncodingOption = new(value); } }

        /// <summary>
        /// Used to track the state of BitDepth
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StreamingSupportedBitDepthEnum?> BitDepthOption { get; private set; }

        /// <summary>
        /// The bit depth of the audio stream
        /// </summary>
        /// <value>The bit depth of the audio stream</value>
        [JsonPropertyName("bit_depth")]
        public StreamingSupportedBitDepthEnum? BitDepth { get { return this.BitDepthOption; } set { this.BitDepthOption = new(value); } }

        /// <summary>
        /// Used to track the state of SampleRate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StreamingSupportedSampleRateEnum?> SampleRateOption { get; private set; }

        /// <summary>
        /// The sample rate of the audio stream
        /// </summary>
        /// <value>The sample rate of the audio stream</value>
        [JsonPropertyName("sample_rate")]
        public StreamingSupportedSampleRateEnum? SampleRate { get { return this.SampleRateOption; } set { this.SampleRateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Model
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StreamingSupportedModels?> ModelOption { get; private set; }

        /// <summary>
        /// The model used to process the audio. \&quot;solaria-1\&quot; is used by default.
        /// </summary>
        /// <value>The model used to process the audio. \&quot;solaria-1\&quot; is used by default.</value>
        [JsonPropertyName("model")]
        public StreamingSupportedModels? Model { get { return this.ModelOption; } set { this.ModelOption = new(value); } }

        /// <summary>
        /// Used to track the state of Channels
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ChannelsOption { get; private set; }

        /// <summary>
        /// The number of channels of the audio stream
        /// </summary>
        /// <value>The number of channels of the audio stream</value>
        [JsonPropertyName("channels")]
        public int? Channels { get { return this.ChannelsOption; } set { this.ChannelsOption = new(value); } }

        /// <summary>
        /// Used to track the state of CustomMetadata
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, Object>?> CustomMetadataOption { get; private set; }

        /// <summary>
        /// Custom metadata you can attach to this live transcription
        /// </summary>
        /// <value>Custom metadata you can attach to this live transcription</value>
        /* <example>{user&#x3D;John Doe}</example> */
        [JsonPropertyName("custom_metadata")]
        public Dictionary<string, Object>? CustomMetadata { get { return this.CustomMetadataOption; } set { this.CustomMetadataOption = new(value); } }

        /// <summary>
        /// Used to track the state of Endpointing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<decimal?> EndpointingOption { get; private set; }

        /// <summary>
        /// The endpointing duration in seconds. Endpointing is the duration of silence which will cause an utterance to be considered as finished
        /// </summary>
        /// <value>The endpointing duration in seconds. Endpointing is the duration of silence which will cause an utterance to be considered as finished</value>
        [JsonPropertyName("endpointing")]
        public decimal? Endpointing { get { return this.EndpointingOption; } set { this.EndpointingOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaximumDurationWithoutEndpointing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<decimal?> MaximumDurationWithoutEndpointingOption { get; private set; }

        /// <summary>
        /// The maximum duration in seconds without endpointing. If endpointing is not detected after this duration, current utterance will be considered as finished
        /// </summary>
        /// <value>The maximum duration in seconds without endpointing. If endpointing is not detected after this duration, current utterance will be considered as finished</value>
        [JsonPropertyName("maximum_duration_without_endpointing")]
        public decimal? MaximumDurationWithoutEndpointing { get { return this.MaximumDurationWithoutEndpointingOption; } set { this.MaximumDurationWithoutEndpointingOption = new(value); } }

        /// <summary>
        /// Used to track the state of LanguageConfig
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<LanguageConfig?> LanguageConfigOption { get; private set; }

        /// <summary>
        /// Specify the language configuration
        /// </summary>
        /// <value>Specify the language configuration</value>
        [JsonPropertyName("language_config")]
        public LanguageConfig? LanguageConfig { get { return this.LanguageConfigOption; } set { this.LanguageConfigOption = new(value); } }

        /// <summary>
        /// Used to track the state of PreProcessing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<PreProcessingConfig?> PreProcessingOption { get; private set; }

        /// <summary>
        /// Specify the pre-processing configuration
        /// </summary>
        /// <value>Specify the pre-processing configuration</value>
        [JsonPropertyName("pre_processing")]
        public PreProcessingConfig? PreProcessing { get { return this.PreProcessingOption; } set { this.PreProcessingOption = new(value); } }

        /// <summary>
        /// Used to track the state of RealtimeProcessing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<RealtimeProcessingConfig?> RealtimeProcessingOption { get; private set; }

        /// <summary>
        /// Specify the realtime processing configuration
        /// </summary>
        /// <value>Specify the realtime processing configuration</value>
        [JsonPropertyName("realtime_processing")]
        public RealtimeProcessingConfig? RealtimeProcessing { get { return this.RealtimeProcessingOption; } set { this.RealtimeProcessingOption = new(value); } }

        /// <summary>
        /// Used to track the state of PostProcessing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<PostProcessingConfig?> PostProcessingOption { get; private set; }

        /// <summary>
        /// Specify the post-processing configuration
        /// </summary>
        /// <value>Specify the post-processing configuration</value>
        [JsonPropertyName("post_processing")]
        public PostProcessingConfig? PostProcessing { get { return this.PostProcessingOption; } set { this.PostProcessingOption = new(value); } }

        /// <summary>
        /// Used to track the state of MessagesConfig
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<MessagesConfig?> MessagesConfigOption { get; private set; }

        /// <summary>
        /// Specify the websocket messages configuration
        /// </summary>
        /// <value>Specify the websocket messages configuration</value>
        [JsonPropertyName("messages_config")]
        public MessagesConfig? MessagesConfig { get { return this.MessagesConfigOption; } set { this.MessagesConfigOption = new(value); } }

        /// <summary>
        /// Used to track the state of Callback
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> CallbackOption { get; private set; }

        /// <summary>
        /// If true, messages will be sent to configured url.
        /// </summary>
        /// <value>If true, messages will be sent to configured url.</value>
        [JsonPropertyName("callback")]
        public bool? Callback { get { return this.CallbackOption; } set { this.CallbackOption = new(value); } }

        /// <summary>
        /// Used to track the state of CallbackConfig
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<CallbackConfig?> CallbackConfigOption { get; private set; }

        /// <summary>
        /// Specify the callback configuration
        /// </summary>
        /// <value>Specify the callback configuration</value>
        [JsonPropertyName("callback_config")]
        public CallbackConfig? CallbackConfig { get { return this.CallbackConfigOption; } set { this.CallbackConfigOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class StreamingRequest {\n");
            sb.Append("  Encoding: ").Append(Encoding).Append("\n");
            sb.Append("  BitDepth: ").Append(BitDepth).Append("\n");
            sb.Append("  SampleRate: ").Append(SampleRate).Append("\n");
            sb.Append("  Channels: ").Append(Channels).Append("\n");
            sb.Append("  CustomMetadata: ").Append(CustomMetadata).Append("\n");
            sb.Append("  Model: ").Append(Model).Append("\n");
            sb.Append("  Endpointing: ").Append(Endpointing).Append("\n");
            sb.Append("  MaximumDurationWithoutEndpointing: ").Append(MaximumDurationWithoutEndpointing).Append("\n");
            sb.Append("  LanguageConfig: ").Append(LanguageConfig).Append("\n");
            sb.Append("  PreProcessing: ").Append(PreProcessing).Append("\n");
            sb.Append("  RealtimeProcessing: ").Append(RealtimeProcessing).Append("\n");
            sb.Append("  PostProcessing: ").Append(PostProcessing).Append("\n");
            sb.Append("  MessagesConfig: ").Append(MessagesConfig).Append("\n");
            sb.Append("  Callback: ").Append(Callback).Append("\n");
            sb.Append("  CallbackConfig: ").Append(CallbackConfig).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Channels (int) maximum
            if (this.ChannelsOption.IsSet && this.ChannelsOption.Value > (int)8)
            {
                yield return new ValidationResult("Invalid value for Channels, must be a value less than or equal to 8.", new [] { "Channels" });
            }

            // Channels (int) minimum
            if (this.ChannelsOption.IsSet && this.ChannelsOption.Value < (int)1)
            {
                yield return new ValidationResult("Invalid value for Channels, must be a value greater than or equal to 1.", new [] { "Channels" });
            }

            // Endpointing (decimal) maximum
            if (this.EndpointingOption.IsSet && this.EndpointingOption.Value > (decimal)10)
            {
                yield return new ValidationResult("Invalid value for Endpointing, must be a value less than or equal to 10.", new [] { "Endpointing" });
            }

            // Endpointing (decimal) minimum
            if (this.EndpointingOption.IsSet && this.EndpointingOption.Value < (decimal)0.01)
            {
                yield return new ValidationResult("Invalid value for Endpointing, must be a value greater than or equal to 0.01.", new [] { "Endpointing" });
            }

            // MaximumDurationWithoutEndpointing (decimal) maximum
            if (this.MaximumDurationWithoutEndpointingOption.IsSet && this.MaximumDurationWithoutEndpointingOption.Value > (decimal)60)
            {
                yield return new ValidationResult("Invalid value for MaximumDurationWithoutEndpointing, must be a value less than or equal to 60.", new [] { "MaximumDurationWithoutEndpointing" });
            }

            // MaximumDurationWithoutEndpointing (decimal) minimum
            if (this.MaximumDurationWithoutEndpointingOption.IsSet && this.MaximumDurationWithoutEndpointingOption.Value < (decimal)5)
            {
                yield return new ValidationResult("Invalid value for MaximumDurationWithoutEndpointing, must be a value greater than or equal to 5.", new [] { "MaximumDurationWithoutEndpointing" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="StreamingRequest" />
    /// </summary>
    public class StreamingRequestJsonConverter : JsonConverter<StreamingRequest>
    {
        /// <summary>
        /// Deserializes json to <see cref="StreamingRequest" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override StreamingRequest Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<StreamingSupportedEncodingEnum?> encoding = default;
            Option<StreamingSupportedBitDepthEnum?> bitDepth = default;
            Option<StreamingSupportedSampleRateEnum?> sampleRate = default;
            Option<int?> channels = default;
            Option<Dictionary<string, Object>?> customMetadata = default;
            Option<StreamingSupportedModels?> model = default;
            Option<decimal?> endpointing = default;
            Option<decimal?> maximumDurationWithoutEndpointing = default;
            Option<LanguageConfig?> languageConfig = default;
            Option<PreProcessingConfig?> preProcessing = default;
            Option<RealtimeProcessingConfig?> realtimeProcessing = default;
            Option<PostProcessingConfig?> postProcessing = default;
            Option<MessagesConfig?> messagesConfig = default;
            Option<bool?> callback = default;
            Option<CallbackConfig?> callbackConfig = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "encoding":
                            string? encodingRawValue = utf8JsonReader.GetString();
                            if (encodingRawValue != null)
                                encoding = new Option<StreamingSupportedEncodingEnum?>(StreamingSupportedEncodingEnumValueConverter.FromStringOrDefault(encodingRawValue));
                            break;
                        case "bit_depth":
                            string? bitDepthRawValue = utf8JsonReader.GetString();
                            if (bitDepthRawValue != null)
                                bitDepth = new Option<StreamingSupportedBitDepthEnum?>(StreamingSupportedBitDepthEnumValueConverter.FromStringOrDefault(bitDepthRawValue));
                            break;
                        case "sample_rate":
                            string? sampleRateRawValue = utf8JsonReader.GetString();
                            if (sampleRateRawValue != null)
                                sampleRate = new Option<StreamingSupportedSampleRateEnum?>(StreamingSupportedSampleRateEnumValueConverter.FromStringOrDefault(sampleRateRawValue));
                            break;
                        case "channels":
                            channels = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "custom_metadata":
                            customMetadata = new Option<Dictionary<string, Object>?>(JsonSerializer.Deserialize<Dictionary<string, Object>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "model":
                            string? modelRawValue = utf8JsonReader.GetString();
                            if (modelRawValue != null)
                                model = new Option<StreamingSupportedModels?>(StreamingSupportedModelsValueConverter.FromStringOrDefault(modelRawValue));
                            break;
                        case "endpointing":
                            endpointing = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "maximum_duration_without_endpointing":
                            maximumDurationWithoutEndpointing = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "language_config":
                            languageConfig = new Option<LanguageConfig?>(JsonSerializer.Deserialize<LanguageConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "pre_processing":
                            preProcessing = new Option<PreProcessingConfig?>(JsonSerializer.Deserialize<PreProcessingConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "realtime_processing":
                            realtimeProcessing = new Option<RealtimeProcessingConfig?>(JsonSerializer.Deserialize<RealtimeProcessingConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "post_processing":
                            postProcessing = new Option<PostProcessingConfig?>(JsonSerializer.Deserialize<PostProcessingConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "messages_config":
                            messagesConfig = new Option<MessagesConfig?>(JsonSerializer.Deserialize<MessagesConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "callback":
                            callback = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "callback_config":
                            callbackConfig = new Option<CallbackConfig?>(JsonSerializer.Deserialize<CallbackConfig>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (encoding.IsSet && encoding.Value == null)
                throw new ArgumentNullException(nameof(encoding), "Property is not nullable for class StreamingRequest.");

            if (bitDepth.IsSet && bitDepth.Value == null)
                throw new ArgumentNullException(nameof(bitDepth), "Property is not nullable for class StreamingRequest.");

            if (sampleRate.IsSet && sampleRate.Value == null)
                throw new ArgumentNullException(nameof(sampleRate), "Property is not nullable for class StreamingRequest.");

            if (channels.IsSet && channels.Value == null)
                throw new ArgumentNullException(nameof(channels), "Property is not nullable for class StreamingRequest.");

            if (customMetadata.IsSet && customMetadata.Value == null)
                throw new ArgumentNullException(nameof(customMetadata), "Property is not nullable for class StreamingRequest.");

            if (model.IsSet && model.Value == null)
                throw new ArgumentNullException(nameof(model), "Property is not nullable for class StreamingRequest.");

            if (endpointing.IsSet && endpointing.Value == null)
                throw new ArgumentNullException(nameof(endpointing), "Property is not nullable for class StreamingRequest.");

            if (maximumDurationWithoutEndpointing.IsSet && maximumDurationWithoutEndpointing.Value == null)
                throw new ArgumentNullException(nameof(maximumDurationWithoutEndpointing), "Property is not nullable for class StreamingRequest.");

            if (languageConfig.IsSet && languageConfig.Value == null)
                throw new ArgumentNullException(nameof(languageConfig), "Property is not nullable for class StreamingRequest.");

            if (preProcessing.IsSet && preProcessing.Value == null)
                throw new ArgumentNullException(nameof(preProcessing), "Property is not nullable for class StreamingRequest.");

            if (realtimeProcessing.IsSet && realtimeProcessing.Value == null)
                throw new ArgumentNullException(nameof(realtimeProcessing), "Property is not nullable for class StreamingRequest.");

            if (postProcessing.IsSet && postProcessing.Value == null)
                throw new ArgumentNullException(nameof(postProcessing), "Property is not nullable for class StreamingRequest.");

            if (messagesConfig.IsSet && messagesConfig.Value == null)
                throw new ArgumentNullException(nameof(messagesConfig), "Property is not nullable for class StreamingRequest.");

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback), "Property is not nullable for class StreamingRequest.");

            if (callbackConfig.IsSet && callbackConfig.Value == null)
                throw new ArgumentNullException(nameof(callbackConfig), "Property is not nullable for class StreamingRequest.");

            return new StreamingRequest(encoding, bitDepth, sampleRate, channels, customMetadata, model, endpointing, maximumDurationWithoutEndpointing, languageConfig, preProcessing, realtimeProcessing, postProcessing, messagesConfig, callback, callbackConfig);
        }

        /// <summary>
        /// Serializes a <see cref="StreamingRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="streamingRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, StreamingRequest streamingRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, streamingRequest, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="StreamingRequest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="streamingRequest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, StreamingRequest streamingRequest, JsonSerializerOptions jsonSerializerOptions)
        {
            if (streamingRequest.CustomMetadataOption.IsSet && streamingRequest.CustomMetadata == null)
                throw new ArgumentNullException(nameof(streamingRequest.CustomMetadata), "Property is required for class StreamingRequest.");

            if (streamingRequest.LanguageConfigOption.IsSet && streamingRequest.LanguageConfig == null)
                throw new ArgumentNullException(nameof(streamingRequest.LanguageConfig), "Property is required for class StreamingRequest.");

            if (streamingRequest.PreProcessingOption.IsSet && streamingRequest.PreProcessing == null)
                throw new ArgumentNullException(nameof(streamingRequest.PreProcessing), "Property is required for class StreamingRequest.");

            if (streamingRequest.RealtimeProcessingOption.IsSet && streamingRequest.RealtimeProcessing == null)
                throw new ArgumentNullException(nameof(streamingRequest.RealtimeProcessing), "Property is required for class StreamingRequest.");

            if (streamingRequest.PostProcessingOption.IsSet && streamingRequest.PostProcessing == null)
                throw new ArgumentNullException(nameof(streamingRequest.PostProcessing), "Property is required for class StreamingRequest.");

            if (streamingRequest.MessagesConfigOption.IsSet && streamingRequest.MessagesConfig == null)
                throw new ArgumentNullException(nameof(streamingRequest.MessagesConfig), "Property is required for class StreamingRequest.");

            if (streamingRequest.CallbackConfigOption.IsSet && streamingRequest.CallbackConfig == null)
                throw new ArgumentNullException(nameof(streamingRequest.CallbackConfig), "Property is required for class StreamingRequest.");

            if (streamingRequest.EncodingOption.IsSet)
            {
                var encodingRawValue = StreamingSupportedEncodingEnumValueConverter.ToJsonValue(streamingRequest.Encoding!.Value);
                writer.WriteString("encoding", encodingRawValue);
            }
            if (streamingRequest.BitDepthOption.IsSet)
            {
                var bitDepthRawValue = StreamingSupportedBitDepthEnumValueConverter.ToJsonValue(streamingRequest.BitDepth!.Value);
                writer.WriteNumber("bit_depth", bitDepthRawValue);
            }
            if (streamingRequest.SampleRateOption.IsSet)
            {
                var sampleRateRawValue = StreamingSupportedSampleRateEnumValueConverter.ToJsonValue(streamingRequest.SampleRate!.Value);
                writer.WriteNumber("sample_rate", sampleRateRawValue);
            }
            if (streamingRequest.ChannelsOption.IsSet)
                writer.WriteNumber("channels", streamingRequest.ChannelsOption.Value!.Value);

            if (streamingRequest.CustomMetadataOption.IsSet)
            {
                writer.WritePropertyName("custom_metadata");
                JsonSerializer.Serialize(writer, streamingRequest.CustomMetadata, jsonSerializerOptions);
            }
            if (streamingRequest.ModelOption.IsSet)
            {
                var modelRawValue = StreamingSupportedModelsValueConverter.ToJsonValue(streamingRequest.Model!.Value);
                writer.WriteString("model", modelRawValue);
            }
            if (streamingRequest.EndpointingOption.IsSet)
                writer.WriteNumber("endpointing", streamingRequest.EndpointingOption.Value!.Value);

            if (streamingRequest.MaximumDurationWithoutEndpointingOption.IsSet)
                writer.WriteNumber("maximum_duration_without_endpointing", streamingRequest.MaximumDurationWithoutEndpointingOption.Value!.Value);

            if (streamingRequest.LanguageConfigOption.IsSet)
            {
                writer.WritePropertyName("language_config");
                JsonSerializer.Serialize(writer, streamingRequest.LanguageConfig, jsonSerializerOptions);
            }
            if (streamingRequest.PreProcessingOption.IsSet)
            {
                writer.WritePropertyName("pre_processing");
                JsonSerializer.Serialize(writer, streamingRequest.PreProcessing, jsonSerializerOptions);
            }
            if (streamingRequest.RealtimeProcessingOption.IsSet)
            {
                writer.WritePropertyName("realtime_processing");
                JsonSerializer.Serialize(writer, streamingRequest.RealtimeProcessing, jsonSerializerOptions);
            }
            if (streamingRequest.PostProcessingOption.IsSet)
            {
                writer.WritePropertyName("post_processing");
                JsonSerializer.Serialize(writer, streamingRequest.PostProcessing, jsonSerializerOptions);
            }
            if (streamingRequest.MessagesConfigOption.IsSet)
            {
                writer.WritePropertyName("messages_config");
                JsonSerializer.Serialize(writer, streamingRequest.MessagesConfig, jsonSerializerOptions);
            }
            if (streamingRequest.CallbackOption.IsSet)
                writer.WriteBoolean("callback", streamingRequest.CallbackOption.Value!.Value);

            if (streamingRequest.CallbackConfigOption.IsSet)
            {
                writer.WritePropertyName("callback_config");
                JsonSerializer.Serialize(writer, streamingRequest.CallbackConfig, jsonSerializerOptions);
            }
        }
    }
}
