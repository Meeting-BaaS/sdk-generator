// <auto-generated>
/*
 * Gladia Control API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Gladia.SDK.Client;

namespace Gladia.SDK.Model
{
    /// <summary>
    /// TranslationConfigDTO
    /// </summary>
    public partial class TranslationConfigDTO : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TranslationConfigDTO" /> class.
        /// </summary>
        /// <param name="targetLanguages">Target language in &#x60;iso639-1&#x60; format you want the transcription translated to</param>
        /// <param name="model">Model you want the translation model to use to translate</param>
        /// <param name="matchOriginalUtterances">Align translated utterances with the original ones (default to true)</param>
        /// <param name="lipsync">Whether to apply lipsync to the translated transcription.  (default to true)</param>
        /// <param name="contextAdaptation">Enables or disables context-aware translation features that allow the model to adapt translations based on provided context. (default to true)</param>
        /// <param name="context">Context information to improve translation accuracy</param>
        /// <param name="informal">Forces the translation to use informal language forms when available in the target language. (default to false)</param>
        [JsonConstructor]
        public TranslationConfigDTO(List<TranslationLanguageCodeEnum> targetLanguages, Option<TranslationModelEnum?> model = default, Option<bool?> matchOriginalUtterances = default, Option<bool?> lipsync = default, Option<bool?> contextAdaptation = default, Option<string?> context = default, Option<bool?> informal = default)
        {
            TargetLanguages = targetLanguages;
            ModelOption = model;
            MatchOriginalUtterancesOption = matchOriginalUtterances;
            LipsyncOption = lipsync;
            ContextAdaptationOption = contextAdaptation;
            ContextOption = context;
            InformalOption = informal;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of Model
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TranslationModelEnum?> ModelOption { get; private set; }

        /// <summary>
        /// Model you want the translation model to use to translate
        /// </summary>
        /// <value>Model you want the translation model to use to translate</value>
        [JsonPropertyName("model")]
        public TranslationModelEnum? Model { get { return this.ModelOption; } set { this.ModelOption = new(value); } }

        /// <summary>
        /// Target language in &#x60;iso639-1&#x60; format you want the transcription translated to
        /// </summary>
        /// <value>Target language in &#x60;iso639-1&#x60; format you want the transcription translated to</value>
        /* <example>[en]</example> */
        [JsonPropertyName("target_languages")]
        public List<TranslationLanguageCodeEnum> TargetLanguages { get; set; }

        /// <summary>
        /// Used to track the state of MatchOriginalUtterances
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> MatchOriginalUtterancesOption { get; private set; }

        /// <summary>
        /// Align translated utterances with the original ones
        /// </summary>
        /// <value>Align translated utterances with the original ones</value>
        [JsonPropertyName("match_original_utterances")]
        public bool? MatchOriginalUtterances { get { return this.MatchOriginalUtterancesOption; } set { this.MatchOriginalUtterancesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Lipsync
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> LipsyncOption { get; private set; }

        /// <summary>
        /// Whether to apply lipsync to the translated transcription. 
        /// </summary>
        /// <value>Whether to apply lipsync to the translated transcription. </value>
        [JsonPropertyName("lipsync")]
        public bool? Lipsync { get { return this.LipsyncOption; } set { this.LipsyncOption = new(value); } }

        /// <summary>
        /// Used to track the state of ContextAdaptation
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> ContextAdaptationOption { get; private set; }

        /// <summary>
        /// Enables or disables context-aware translation features that allow the model to adapt translations based on provided context.
        /// </summary>
        /// <value>Enables or disables context-aware translation features that allow the model to adapt translations based on provided context.</value>
        [JsonPropertyName("context_adaptation")]
        public bool? ContextAdaptation { get { return this.ContextAdaptationOption; } set { this.ContextAdaptationOption = new(value); } }

        /// <summary>
        /// Used to track the state of Context
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ContextOption { get; private set; }

        /// <summary>
        /// Context information to improve translation accuracy
        /// </summary>
        /// <value>Context information to improve translation accuracy</value>
        [JsonPropertyName("context")]
        public string? Context { get { return this.ContextOption; } set { this.ContextOption = new(value); } }

        /// <summary>
        /// Used to track the state of Informal
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> InformalOption { get; private set; }

        /// <summary>
        /// Forces the translation to use informal language forms when available in the target language.
        /// </summary>
        /// <value>Forces the translation to use informal language forms when available in the target language.</value>
        [JsonPropertyName("informal")]
        public bool? Informal { get { return this.InformalOption; } set { this.InformalOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TranslationConfigDTO {\n");
            sb.Append("  TargetLanguages: ").Append(TargetLanguages).Append("\n");
            sb.Append("  Model: ").Append(Model).Append("\n");
            sb.Append("  MatchOriginalUtterances: ").Append(MatchOriginalUtterances).Append("\n");
            sb.Append("  Lipsync: ").Append(Lipsync).Append("\n");
            sb.Append("  ContextAdaptation: ").Append(ContextAdaptation).Append("\n");
            sb.Append("  Context: ").Append(Context).Append("\n");
            sb.Append("  Informal: ").Append(Informal).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="TranslationConfigDTO" />
    /// </summary>
    public class TranslationConfigDTOJsonConverter : JsonConverter<TranslationConfigDTO>
    {
        /// <summary>
        /// Deserializes json to <see cref="TranslationConfigDTO" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override TranslationConfigDTO Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<List<TranslationLanguageCodeEnum>?> targetLanguages = default;
            Option<TranslationModelEnum?> model = default;
            Option<bool?> matchOriginalUtterances = default;
            Option<bool?> lipsync = default;
            Option<bool?> contextAdaptation = default;
            Option<string?> context = default;
            Option<bool?> informal = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "target_languages":
                            targetLanguages = new Option<List<TranslationLanguageCodeEnum>?>(JsonSerializer.Deserialize<List<TranslationLanguageCodeEnum>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "model":
                            string? modelRawValue = utf8JsonReader.GetString();
                            if (modelRawValue != null)
                                model = new Option<TranslationModelEnum?>(TranslationModelEnumValueConverter.FromStringOrDefault(modelRawValue));
                            break;
                        case "match_original_utterances":
                            matchOriginalUtterances = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "lipsync":
                            lipsync = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "context_adaptation":
                            contextAdaptation = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "context":
                            context = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "informal":
                            informal = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!targetLanguages.IsSet)
                throw new ArgumentException("Property is required for class TranslationConfigDTO.", nameof(targetLanguages));

            if (targetLanguages.IsSet && targetLanguages.Value == null)
                throw new ArgumentNullException(nameof(targetLanguages), "Property is not nullable for class TranslationConfigDTO.");

            if (model.IsSet && model.Value == null)
                throw new ArgumentNullException(nameof(model), "Property is not nullable for class TranslationConfigDTO.");

            if (matchOriginalUtterances.IsSet && matchOriginalUtterances.Value == null)
                throw new ArgumentNullException(nameof(matchOriginalUtterances), "Property is not nullable for class TranslationConfigDTO.");

            if (lipsync.IsSet && lipsync.Value == null)
                throw new ArgumentNullException(nameof(lipsync), "Property is not nullable for class TranslationConfigDTO.");

            if (contextAdaptation.IsSet && contextAdaptation.Value == null)
                throw new ArgumentNullException(nameof(contextAdaptation), "Property is not nullable for class TranslationConfigDTO.");

            if (context.IsSet && context.Value == null)
                throw new ArgumentNullException(nameof(context), "Property is not nullable for class TranslationConfigDTO.");

            if (informal.IsSet && informal.Value == null)
                throw new ArgumentNullException(nameof(informal), "Property is not nullable for class TranslationConfigDTO.");

            return new TranslationConfigDTO(targetLanguages.Value!, model, matchOriginalUtterances, lipsync, contextAdaptation, context, informal);
        }

        /// <summary>
        /// Serializes a <see cref="TranslationConfigDTO" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="translationConfigDTO"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, TranslationConfigDTO translationConfigDTO, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, translationConfigDTO, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="TranslationConfigDTO" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="translationConfigDTO"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, TranslationConfigDTO translationConfigDTO, JsonSerializerOptions jsonSerializerOptions)
        {
            if (translationConfigDTO.TargetLanguages == null)
                throw new ArgumentNullException(nameof(translationConfigDTO.TargetLanguages), "Property is required for class TranslationConfigDTO.");

            if (translationConfigDTO.ContextOption.IsSet && translationConfigDTO.Context == null)
                throw new ArgumentNullException(nameof(translationConfigDTO.Context), "Property is required for class TranslationConfigDTO.");

            writer.WritePropertyName("target_languages");
            JsonSerializer.Serialize(writer, translationConfigDTO.TargetLanguages, jsonSerializerOptions);
            if (translationConfigDTO.ModelOption.IsSet)
            {
                var modelRawValue = TranslationModelEnumValueConverter.ToJsonValue(translationConfigDTO.Model!.Value);
                writer.WriteString("model", modelRawValue);
            }
            if (translationConfigDTO.MatchOriginalUtterancesOption.IsSet)
                writer.WriteBoolean("match_original_utterances", translationConfigDTO.MatchOriginalUtterancesOption.Value!.Value);

            if (translationConfigDTO.LipsyncOption.IsSet)
                writer.WriteBoolean("lipsync", translationConfigDTO.LipsyncOption.Value!.Value);

            if (translationConfigDTO.ContextAdaptationOption.IsSet)
                writer.WriteBoolean("context_adaptation", translationConfigDTO.ContextAdaptationOption.Value!.Value);

            if (translationConfigDTO.ContextOption.IsSet)
                writer.WriteString("context", translationConfigDTO.Context);

            if (translationConfigDTO.InformalOption.IsSet)
                writer.WriteBoolean("informal", translationConfigDTO.InformalOption.Value!.Value);
        }
    }
}
